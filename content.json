{"meta":{"title":"梦云智","subtitle":"一起做着靠谱的事情，这就是我们。","description":"河北工业大学梦云智软件开发团队日志","author":"梦云智","url":"http://www.mengyunzhi.cn"},"pages":[{"title":"分类","date":"2017-09-26T07:05:27.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"categories/index.html","permalink":"http://www.mengyunzhi.cn/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"标签","date":"2017-09-26T07:07:30.000Z","updated":"2017-12-29T06:58:04.840Z","comments":true,"path":"tags/index.html","permalink":"http://www.mengyunzhi.cn/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-12-29T06:58:04.832Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/12/29/hello-world/","link":"","permalink":"http://www.mengyunzhi.cn/2017/12/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]},{"title":"如何启动测量项目","slug":"how-to-start-measurement-project","date":"2017-12-29T06:08:37.000Z","updated":"2017-12-29T06:58:05.336Z","comments":true,"path":"2017/12/29/how-to-start-measurement-project/","link":"","permalink":"http://www.mengyunzhi.cn/2017/12/29/how-to-start-measurement-project/","excerpt":"作为程序开发人员，启动项目是开发的第一步。那么，我们如何才能启动测量项目呢，为什么要这样设计。本篇文章为您简单介绍一下。","text":"作为程序开发人员，启动项目是开发的第一步。那么，我们如何才能启动测量项目呢，为什么要这样设计。本篇文章为您简单介绍一下。 如何启动测量项目1.拉取最新的开发分支，分别启动GatewayApplication、ResourceApplication2.切换到Webapp目录下，grunt serve启动前台。3.访问： http://localhost:8080 如果不能正常启动项目，建议idea重新导入项目 原因说明我们可以观察到，当我们grunt serve启动前台时，实际上启动的是8083端口，为什么通过8080端口才能访问前台呢？我们访问http://localhost:8080 ，实际上是访问GatewayApplication应用程序，Gateway想当于代理的作用，我们观察Gateway的配置信息。123456789101112131415161718192021222324ribbon.eureka.enabled=false# 资源地址zuul.routes.resource.path=/resource/**# 不排除任何header信息zuul.routes.resource.sensitiveHeaders=zuul.routes.resource.url=$&#123;resource.url:http://localhost:8081&#125;# 认证地址(获取accessToken)zuul.routes.oauthToken.path=/oauth/token# 携带前缀转发数据zuul.routes.oauthToken.stripPrefix=falsezuul.routes.oauthToken.sensitiveHeaders=zuul.routes.oauthToken.url=$&#123;oauth.url:http://localhost:8082&#125;# 认证地址(其它)zuul.routes.oauth.path=/oauth/**# 携带前缀转发数据zuul.routes.oauth.url=$&#123;oauth.url:http://localhost:8082&#125;# 其它地址zuul.routes.ui.path=/**zuul.routes.ui.url=$&#123;ui.url:http://localhost:8083&#125;server.port=$&#123;port:8080&#125; 1.首先我们可以从以下代码中看出，Gateway的端口是80801server.port=$&#123;port:8080&#125; 2.而当我们访问http://localhost:8080 时，Gateway把路由转发到了8083端口，所以就访问到了前台界面。代码如下：12zuul.routes.ui.path=/**zuul.routes.ui.url=$&#123;ui.url:http://localhost:8083&#125; 3.登陆前台界面，打开网络选项卡我们可以看到，后台的api信息是以http://localhost:8080/resource/开头的，代码如下：12zuul.routes.resource.path=/resource/**zuul.routes.resource.url=$&#123;resource.url:http://localhost:8081&#125; 这样，当我们访问的路由是以/resource/开头时，就转发到了8081端口。 总结通过Gateway应用程序，即使在前后台分离的情况下，也可以避免跨域的问题，即：协议、域名、端口号都是一样的。从而提高了用户的安全指数。","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://www.mengyunzhi.cn/tags/SpringMvc/"},{"name":"gateway","slug":"gateway","permalink":"http://www.mengyunzhi.cn/tags/gateway/"}]},{"title":"计量项目前台部分Controller之间的关系","slug":"instrument-audit","date":"2017-11-22T09:20:01.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/11/22/instrument-audit/","link":"","permalink":"http://www.mengyunzhi.cn/2017/11/22/instrument-audit/","excerpt":"最简单的编程就是看着图编程。最难维护的项目就是一张图都没有的项目。此文章简介一下自己在修改前台过程中整理的部分功能模块是整理的类图。","text":"最简单的编程就是看着图编程。最难维护的项目就是一张图都没有的项目。此文章简介一下自己在修改前台过程中整理的部分功能模块是整理的类图。 类的继承之间的关系 左边这个分支是查看的功能，右边这个分支是审核的功能。Controller之间的关系基本就是这样的。 V层和C层之间的图 我想这样更有助于我们理解整个的文件的结构。 简单的时序图 这个时序图主要是讲了一下用户在我的工作的时候点击查看按钮发生的事情，调用相应的方法获取获取哪个Controller。然后进获取相应的数据。这只是是一个很粗糙的博客，想说的就是当我们在查看一个项目代码的时候如果自己不理解一定要自己画图记录代码的流程。","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[]},{"title":"java-exception-handling","slug":"java-exception-handling","date":"2017-11-20T13:06:27.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/11/20/java-exception-handling/","link":"","permalink":"http://www.mengyunzhi.cn/2017/11/20/java-exception-handling/","excerpt":"在开发 程序的过程中，我们可能经常会和异常打交道，那么出现异常时我们应该怎么处理呢，我们一起来学习一下。","text":"在开发 程序的过程中，我们可能经常会和异常打交道，那么出现异常时我们应该怎么处理呢，我们一起来学习一下。 基本异常处理java提供了在程序中处理某些特定类型条件的方法，能够把程序或方法划分为正常情况或异常情况两部分。异常是一个对象，创建这个对象的过程，也被称为抛出异常。实例如下：12345678910public void LearnException(int i) &#123; try &#123; if (i &lt; 1) &#123; throw new ArithmeticException(&quot;请传入大于0的整数&quot;); &#125; int result = 100/i; &#125; catch (ArithmeticException e) &#123; System.out.println(&quot;出现异常了&quot;); &#125;&#125; 从上面这个例子我们可以看出，java处理异常的基本方式有try-throw-catch三元组成。 try语句块。try是尝试的意思，try语句块中的代码通常是你不能百分之百的确定，但是你想进行一次尝试。它的基本轮廓如下； 12345 try &#123; Code_To_Try Possibly_Throw_An_Exception More_Code&#125; throw语句块。上述的例子，也等同与如下代码： 12ArithmeticException arithmeticException = new ArithmeticException(&quot;请传入大于0的整数&quot;);throw arithmeticException; 实际上，就是new一个异常对象，然后抛出的过程。当异常被抛出时，该块中的代码停止执行，跳出try语句块。 catch语句块。其格式如下： 123 catch (ArithmeticException e) &#123; Handling_Exception&#125; 标识符e就像一个参数，接收刚才抛出的异常，所以e的类型必须等同于抛出的异常类型，否则不能捕获异常。 定义自己的异常类 我们也可以自己定义一个异常类，但必须继承已经定义好的异常类的。代码如下： 12345678 public class DivideByZeroException extends Exception &#123; public DivideByZeroException() &#123; super(&quot;请传入大于0的整数&quot;); // 调用基类Exception的构造器 &#125; public DivideByZeroException(String message) &#123; super(message); // 调用基类Exception的构造器 &#125;&#125; 调用方法如下： 12345678 try &#123; if (i &lt; 1) &#123; throw new DivideByZeroException(); &#125; int result = 100/i;&#125; catch (DivideByZeroException e) &#123; System.out.println(&quot;出现异常了&quot;);&#125; 当我们自己定义异常类时，我们需要注意一下三点： 如果你没有更合理的理由使用其他的异常类作为基类，那么就使用Exception作为基类。 你定义的异常类至少定义了两个构造器——一个默认构造器，一个拥有String参数的构造器。通常情况下，自己定义的异常类都要保留getMessage方法。 在每一个构造器中，你应该以对基类构造器的调用作为开始，使用super调用。 如果你在写代码时就已经清楚可能会抛出异常，那么最后自己定义一个异常，这样当出现异常时，我们就更容易区分你的异常和预定义类中的异常。 声明异常 有时候我们需要延迟处理异常。比如你有一个代码块可能会抛出异常，但你并不想在这个代码块中捕获异常。因为可能某些程序调用该方法抛出异常后应该简单的终止程序，而另一程序调用该方法抛出异常后要做一些其他的处理。所以，当出现类似这种情况时，我们需要在在方法头部声明异常。代码如下： 12345public void LearnException(int i) throws DivideByZeroException &#123; Code_To_Try throw new DivideByZeroException(); More_Code&#125; 如果方法抛出了异常，方法调用立即结束。在方法的首部声明异常的一个好处是，我们可以清楚的区分可能有异常的方法和没有异常的方法，易于阅读。 关键字throw用于抛出异常，throws用于声明异常。 异常的种类所有的java异常可以分为两类：可控异常，不可控异常。上述的异常属于可控异常，即：异常必须在catch快中捕获或者在方法的首部声明。不可控异常也称为运行时异常（RuntimeException），当出现此类异常时，通常我们应该修正自己的代码，而不是添加catch语句块。 多重捕获和finally 多重捕获。一个try语句块可以抛出任意数量的异常，这些异常可以是不同的类型，因为一个catch语句块只能捕获一种异常，所以一个try语句块可以使用多个catch语句块。 finally关键字 。无论代码是否发生异常，finally中的代码块总会被执行。代码如下：123456789try &#123; // do sth&#125; catch (DivideByZeroException e1) &#123; // do sth&#125; catch (IOException) &#123; // do sth&#125; finally &#123; // do sth&#125; 总结 我们应该在什么时候抛出异常呢？在 When to throw an exception? 中，推荐：当发现当前代码块的基本假设是错误时，应该抛出异常。 对于所有的异常都捕获Exception是否可行？可行但是不推荐。最好catch更为精确的异常。 在catch语句块中使用e.printStackTrace()是一个好的习惯么？并不推荐使用这种方法，很多情况下，并不能正确的提示代码出错的位置和相关信息。最好使用在控制台打印的方法。 error—错误 ： 是指程序无法处理的错误.比如内存溢出、端口占用、断言错误等。 参考文献： 《Java程序设计与问题解决》 Java 异常处理 When to throw an exception? Why is exception.printStackTrace() considered bad practice?","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.mengyunzhi.cn/tags/java/"}]},{"title":"ArrayList、LinkedList和HashSet的学习总结","slug":"java-dynamic-data-structure","date":"2017-11-15T01:00:51.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/11/15/java-dynamic-data-structure/","link":"","permalink":"http://www.mengyunzhi.cn/2017/11/15/java-dynamic-data-structure/","excerpt":"java中，一旦程序定义了数组的长度，就不能修改这个数组的长度了。如果我们需要修改数组的长度，我们可以使用ArrayList，以达到改变数组长度的目的。","text":"java中，一旦程序定义了数组的长度，就不能修改这个数组的长度了。如果我们需要修改数组的长度，我们可以使用ArrayList，以达到改变数组长度的目的。 类ArrayListArrayList的缺点： ArrayList比数组的效率低 ArrayList只能存储对象，不能包含基本类型，比如int、double。 ArrayList的语法：1ArrayList &lt;Base_Type&gt; Variable = new ArrayList&lt;Base_Type&gt;(Capacity); 其中，Base_Type必须为类类型，不能为基本类型。Capacity（容量）表示为这个数据项分配内存空间，如果不传值，默认初始容量为10个数据项。如果初始化给了足够大的初始容量，那么系统就不需要频繁的分配内存了，程序将会运行的更快。反之，如果你吧初始容量弄得太大，就会浪费储存空间。我们对是否分配容量做一个测试，代码实例：1234567891011121314151617181920public class ListDemo &#123; static long timeList(List&lt;String&gt; st) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; st.add(String.valueOf(i)); &#125; return System.currentTimeMillis() - start; &#125; public static void main (String args[]) &#123; System.out.println(&quot;assign capacity ArrayList = &quot; + timeList(new ArrayList&lt;String&gt;(100000))); System.out.println(&quot;default ArrayList = &quot; + timeList(new ArrayList&lt;String&gt;())); &#125; &#125; 结果如下：12assign capacity ArrayList = 22default ArrayList = 13 jdk7之前，我们应该这样实例化ArrayList1List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;(); jdk7开始，我们可以这样1List&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); 不仅方便了我们书写，也使代码有更强的可读性。 类LinkedList类LinkedList的基本用法同上，但是LinkedList内部使用双向链表的数据结构，只有在需要时才分配内存，删除元素时随即释放内存。 类ArrayList和类LinkedList的比较 类LinkedList插入元素效率高，但访问元素效率低。 类ArrayList访问元素效率高，但插入效率低。他们的效率相差多少，我们通过实例来了解（仅修改main方法）：1234567public static void main (String args[]) &#123; System.out.println(&quot;time for ArrayList = &quot; + timeList(new ArrayList&lt;String&gt;())); System.out.println(&quot;time for LinkedList = &quot; + timeList(new LinkedList&lt;String&gt;()));&#125; 运行结果：12time for ArrayList = 22time for LinkedList = 13 如果我们指定位置添加元素，将第六行代码st.add(String.valueOf(i));修改为st.add(0, String.valueOf(i));运行结果为：12time for ArrayList = 915time for LinkedList = 11 为什么会差这么多呢，因为每插入一个元素，arraylist都要吧所有的元素都后移，而LinkedList指需要增加一个新的结点，并调整一下对应关系就可以了。我们进行一次新增元素，再进行一次查看元素，他们的效率相差多少呢？将timeList修改为如下所示：1234567891011static long timeList(List&lt;String&gt; st) &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 100000; i++) &#123; st.add(String.valueOf(i)); &#125; for (int i = 0; i &lt; 10000; i++) &#123; st.get(i); &#125; return System.currentTimeMillis() - start;&#125; 结果如下123time for ArrayList = 17time for LinkedList = 156 因此，我们在进行相同次数的查找和添加元素的情况下，ArrayList效率较高。因此，我们使用ArrayList的次数会更多一些。 Collection API的层次结构通过上面的学习，我们对动态数据结构有了基本的认识，那么java中关于数组的接口和实现类的层次结构是什么样的呢？如下图：由上图可知，Iterable接口、Collection接口中定义的方法，几个实现类都实现了，只不过他们的具体实现方法会有所差异。同样的，ArrayList和LinkedList都是List接口的实现类，所以他们的方法名都是一样的，但是具体的实现方法有所差异。 Set接口和List接口1.Set对应的中文名是集合，有两个特点： 不含重复元素 无序 2.List接口类似于书续重的序列，也有两个特点： 可含重复的元素 有序 类HashSetHashSet继承了Set接口的特性，值得注意的是，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法中使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果。因为new一个HashSet，实际上是new HashMap，并以这个对象的hashCode为key，这个对象本身为value储存。当对象的hashcode改变后，我们可以使用迭代器进行删除的操作，代码如下：12345678Iterator&lt;MandatoryInstrument&gt; iterator = mandatoryInstrumentList.iterator();while (iterator.hasNext()) &#123; MandatoryInstrument mandatoryInstrument = iterator.next(); if (mandatoryInstrument.getCheckDepartment() == null) &#123; iterator.remove(); continue; &#125;&#125; iteratoriterator（迭代器）是什么？eg：123for (int i = 0; i &lt; 10000; i++) &#123; st.get(i);&#125; 那么，i就是一个迭代器——能够以合理的方式一次访问一个元素、遍历整个数组或者链表的变量。从一个元素走到另一个元素的过程就是是迭代（iterable）","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.mengyunzhi.cn/tags/java/"}]},{"title":"java中json和object相互转换","slug":"how-to-convert-json-to-from-object-Gson","date":"2017-10-21T13:25:02.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/10/21/how-to-convert-json-to-from-object-Gson/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/21/how-to-convert-json-to-from-object-Gson/","excerpt":"我们经常会用到json和oject类型的相互转换，这篇文章记录了通过gson进行object和json的相互转换。","text":"我们经常会用到json和oject类型的相互转换，这篇文章记录了通过gson进行object和json的相互转换。 gson 依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt; object转换为json123456789// 1.新建一个对象FromMessage fromMessage = new FromMessage();fromMessage.setContent(&quot;test&quot;);fromMessage.setIsRead(Boolean.FALSE);// 2.将对象转化为json字符串Gson gson = new Gson();String jsonString = gson.toJson(fromMessage);System.out.println(jsonString); // &#123;&quot;content&quot;:&quot;test&quot;,&quot;isRead&quot;:false&#125; json转化为object1234Gson gson = new Gson();String jsonString = &quot;&#123;\\&quot;content\\&quot;:\\&quot;test\\&quot;,\\&quot;isRead\\&quot;:false&#125;&quot;;FromMessage fromMessage1 = gson.fromJson(jsonString, FromMessage.class);System.out.println(fromMessage1); //Message&#123;id=null, content=&apos;test&apos;, title=&apos;null&apos;, isRead=false, fromDepartment=null, toDepartment=null, firstReadTime=null, firstReadUser=null, createUser=null, createTime=null&#125; 参考文章：How to convert Java object to JSON string","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"object","slug":"object","permalink":"http://www.mengyunzhi.cn/tags/object/"},{"name":"json","slug":"json","permalink":"http://www.mengyunzhi.cn/tags/json/"}]},{"title":"angular和springmvc实现批量删除","slug":"angular-spring-batch-delete","date":"2017-10-21T13:24:41.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/10/21/angular-spring-batch-delete/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/21/angular-spring-batch-delete/","excerpt":"昨天实现了批量删除的功能，看到了stackoverflow和百度上均有相关的问题，于是决定记录一下。前台angularjs，后台SpringMvc。","text":"昨天实现了批量删除的功能，看到了stackoverflow和百度上均有相关的问题，于是决定记录一下。前台angularjs，后台SpringMvc。 checkbox使用123&lt;tr ng-repeat=&quot;(key, object) in data.content&quot;&gt; &lt;td&gt;&lt;input icheck type=&quot;checkbox&quot; ng-model=&quot;object._checked&quot;&gt;&lt;/td&gt;&lt;/tr&gt; 当用户勾选复选框后，对象的_checked属性值为true，我们通过下面这个函数获取勾选的object,可以把这个函数放在公共service中，方便框架的其他地方调用。类似的，我们也可以根据自己的需求，修改_checked属性。123456789101112131415161718192021/** * 由某个数组中 筛选中被选中的元素，组成新的数组并返回 * @param &#123;array&#125; lists 原数组 * @param &#123;string&#125; key 健值 默认为 _checked * @return &#123;array&#125; 选中元素组成的数组 * @author 梦云智 http://www.mengyunzhi.com * @DateTime 2017-10-17T15:05:18+0800 */self.getCheckedElementsByListsAndKey = function(lists, key) &#123; if (typeof(key) === &apos;undefined&apos;) &#123; key = &apos;_checked&apos;; &#125; var tempList = []; angular.forEach(lists, function(list) &#123; if (typeof(list[key]) !== &apos;undefined&apos; &amp;&amp; list[key] === true) &#123; tempList.push(list); &#125; &#125;); return tempList;&#125;; 前后台对接前台http请求12345678var data = [1, 3, 4]; // 假设要删除id为1,3,4的记录$http.delete(&apos;/FromMessage/batchDelete/&apos; + data) .then(function success(response)&#123; if (callback) &#123;callback(response.status);&#125; &#125;, function error(response)&#123; alert(&apos;FromMessage.batchDelete error: &apos;, response); if (callback) &#123;callback(response.status);&#125; &#125;); 后台代码123456@ResponseStatus(HttpStatus.NO_CONTENT) @DeleteMapping(&quot;/batchDelete/&#123;fromMessageIds&#125;&quot;) public void batchDelete(@ApiParam(value = &quot;消息id数组&quot;) @PathVariable List&lt;Integer&gt; fromMessageIds) &#123; fromMessageService.batchDelete(fromMessageIds); return; &#125; 后台接受到的是一个数组。如果把数组放到delete方法的body中，由于不符合api规范，会被tomcat或这spring丢弃，后台就不能正确的接受body信息。 单元测试功能实现后，为了降低代码的维护成本，我们进行单元测试。这里给出示例代码：12345logger.info(&quot;模拟请求&quot;);this.mockMvc.perform(delete(&quot;/FromMessage/batchDelete/&quot; + fromMessage.getId() + &apos;,&apos; + fromMessage1.getId()).header(&quot;x-auth-token&quot;, xAuthToken)).andDo(document(&quot;FromMessage_batchDelete&quot;, preprocessResponse(prettyPrint()))).andExpect(status().is(204)); 注意请求的url1/FromMessage/batchDelete/2,3 总结在进行开发的时候，实现复选框选中、后台接收数组等功能，感觉之前都实现过，但是由于记得不清楚，测试了多次也没能通过，还是及时的google能够节约解决问题的时间。","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://www.mengyunzhi.cn/tags/angularjs/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"http://www.mengyunzhi.cn/tags/SpringMvc/"}]},{"title":"angular中使用ng-include后controller中$watch失去作用","slug":"includ-watch-angular","date":"2017-10-21T10:53:51.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/10/21/includ-watch-angular/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/21/includ-watch-angular/","excerpt":"有的时候为了实现代码复用，我们会使用ng-include复用部分代码。","text":"有的时候为了实现代码复用，我们会使用ng-include复用部分代码。 问题简化about.js 1234567angular.module(&apos;angularTestApp&apos;) .controller(&apos;AboutCtrl&apos;, function ($scope) &#123; $scope.num = 0; $scope.$watch(&quot;num&quot;, function () &#123; console.log($scope.num); &#125;); &#125;); about.html123&lt;p&gt;This is the about view.&lt;/p&gt;&lt;div ng-include=&quot;&apos;views/include.html&apos;&quot;&gt;&lt;/div&gt;&#123;&#123;num&#125;&#125; include.html 1234&lt;div&gt; &lt;input type=&quot;text&quot; ng-model=&quot;num&quot;&gt; &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; 如果我们运行这段代码就会发现一个问题，当我们改变num的值的时候控制台并没有打印num的值。 原因这是因为我们使用ng-include的时候会会创建一个child scope。然后两个scope的作用域是相互隔离的，所以include.html中的ng-model绑定的是自己的scope, 所以about.js中的num不会发生改变。 解决办法将include.html做如下修改 1234&lt;div&gt; &lt;input type=&quot;text&quot; ng-model=&quot;$parent.num&quot;&gt; &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;/div&gt; 参考文献ng-model not working inside ng-include","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.mengyunzhi.cn/tags/angular/"}]},{"title":"如何使用U盘启动的方式更新macos","slug":"Create-a-bootable-installer-for-macOS","date":"2017-10-20T15:58:32.000Z","updated":"2017-12-29T06:58:04.828Z","comments":true,"path":"2017/10/20/Create-a-bootable-installer-for-macOS/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/20/Create-a-bootable-installer-for-macOS/","excerpt":"苹果系统出现问题，我们往往可以很快的将系统恢复为出厂设置。官方教程： https://support.apple.com/zh-cn/HT204904\n那么当我们想对原有系统进行升级呢？此时，我们就需要下载macos的新系统，然后采用U盘的形式安装了。","text":"苹果系统出现问题，我们往往可以很快的将系统恢复为出厂设置。官方教程： https://support.apple.com/zh-cn/HT204904 那么当我们想对原有系统进行升级呢？此时，我们就需要下载macos的新系统，然后采用U盘的形式安装了。 参考官方英文教程： https://support.apple.com/en-us/HT201372 简单描述下步骤： 格式化U盘需要注意两点： 格式应该选择：Mac OS 扩展（日志式） 名称应该起个简短的，不要有空格。比如起名为：OSX 将系统写入U盘 双击下载的dmg文件，并进行安装。 安装成功后，将在 所有程序 中看到一个名为： 安装 mac os xx 打开 安装 mac os xx，但不要点继续，就打开放着就可以。 确认自己当前系统的版本点小苹果，关于本机。 使用createinstallmedia命令进行U盘写入不同的系统，createinstallmedia 不同，命令也不完全相同，这个需要参考官方文档。 我的方法是，输入/Applications/Install后，按tab键自动补全，然后与官方文档相对应，就能清楚自己的版本号了。 替换命令中的U盘名称比如我们的起名为OSX, 则将命令中的 /Volumes/MyVolume 换为 /Volumes/OSX 当然了，你也可以把U盘起名为：MyVolume，这样在输入命令时就不需要变更了。 示例如下：123456789101112bogon:Applications apple$ sudo Install\\ macOS\\ High\\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/OSX/Password:Ready to start.To continue we need to erase the volume at /Volumes/OSX/.If you wish to continue type (Y) then press return: YErasing Disk: 0%... 10%... 20%... 30%...100%...Copying installer files to disk...Copy complete.Making disk bootable...Copying boot files...Copy complete.Done. 然后，我们就可以按https://support.apple.com/zh-cn/HT204904的说明来重新安装操作系统了。 以下内容是关于组建funsion driver的funsion driver = 一块机器 + 一块SSD。组建容量高速度快的硬盘驱动器。 不更新系统，只是想组建funsion driver，请直接参考官网地址，如下https://support.apple.com/zh-cn/HT207584","raw":null,"content":null,"categories":[{"name":"panjie","slug":"panjie","permalink":"http://www.mengyunzhi.cn/categories/panjie/"}],"tags":[{"name":"macos","slug":"macos","permalink":"http://www.mengyunzhi.cn/tags/macos/"}]},{"title":"review(审阅)pull request的方法","slug":"how-to-review-pull-request","date":"2017-10-19T01:58:11.000Z","updated":"2017-12-29T06:58:04.828Z","comments":true,"path":"2017/10/19/how-to-review-pull-request/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/19/how-to-review-pull-request/","excerpt":"在团队开发的过程中，我们需要将自己开发的代码使用pull request的方式提交至github中。本文中，我们给出当我们看到别人提交的代码时，如何快速的来审阅这次代码提交。","text":"在团队开发的过程中，我们需要将自己开发的代码使用pull request的方式提交至github中。本文中，我们给出当我们看到别人提交的代码时，如何快速的来审阅这次代码提交。 首先，假设我们有以下pull request. 拉取项目1git pull 找到提交分支如下图，我们查看到，当前的pull request是由reviewPullRequest提交上来的。 切换到提交分支如果我们正在进行同一项目的开发，那么我们可以先将自己的代码进行commit。 切换至提交pull request的分支reviewPullRequest。 1git checkout &lt;reviewPullRequest&gt; 查看效果或是代码此时，我们便可以启用本地环境来查看效果了。 如果我们查看是readme.md文档，那么还可以直接登录github官网，然后在官网上直接切换分支后在线阅览readme.md的效果。 代码审阅完毕后，我们需要在github中给出审核的意见： 三种意见： Commnet 不同意 Approve 同意 Request changes 修改后同意","raw":null,"content":null,"categories":[],"tags":[{"name":"github","slug":"github","permalink":"http://www.mengyunzhi.cn/tags/github/"}]},{"title":"如何启动团队的hexo的博客","slug":"how-to-start-team-hexo-bolg","date":"2017-10-19T01:44:17.000Z","updated":"2017-12-29T06:58:04.828Z","comments":true,"path":"2017/10/19/how-to-start-team-hexo-bolg/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/19/how-to-start-team-hexo-bolg/","excerpt":"本文中，我们将说明，如果在本地配置团队的hexo博客工具准备： nodejs, git","text":"本文中，我们将说明，如果在本地配置团队的hexo博客工具准备： nodejs, git clone 项目git clone https://github.com/yunzhiclub/hexo.git hexo 进入项目目录cd hexo 新建自己的分支git checkout -b &lt;newBranch&gt; &lt;abc&gt; 表示此项为必填项，在实际使用中，将abc替换为自己的内容。 安装依赖npm installbower install 启动项目hexo server项目启动后，将在控制台收到1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 我们可以找开http://localhost:4000/来查看项目，并在控制台中使用Ctrl+C来终止服务。 新建文章hexo new title将新建一篇文章，控制台同时提醒我们新建文章的位置。 最后，编辑文章，保存，将新的文章添加到git中，并提交pull request 参考文档","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.mengyunzhi.cn/tags/hexo/"}]},{"title":"学习hebinate继承映射关系","slug":"Learning-to-use-entity-inheritance-with-JPA-and-Hibernate","date":"2017-10-17T09:18:58.000Z","updated":"2017-12-29T06:58:04.828Z","comments":true,"path":"2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/","excerpt":"做计量项目我的消息模块时，消息分为接收消息和发送消息，如果把消息放在一个实体中，当删除发送消息时，对应的接受消息也被删除了，因此决定使用继承的方法。我们通过这个问题学习ＪＰＡ主要的三种映射策略。","text":"做计量项目我的消息模块时，消息分为接收消息和发送消息，如果把消息放在一个实体中，当删除发送消息时，对应的接受消息也被删除了，因此决定使用继承的方法。我们通过这个问题学习ＪＰＡ主要的三种映射策略。 问题还原假设有三个类animal、cat、dog。cat、dog继承animal类那我们应该通过什么方法生成数据表，生成几张数据表呢，哪种方法最优呢？ 单表继承策略单表继承，就是这几个类共用一个数据表。代码如下：123456789101112131415161718192021222324@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 继承（策略 = 单表继承）@DiscriminatorColumn(name = &quot;DB_TYPE&quot;) // 鉴别的列名为 DB_TYPE，将在数据表中生成该字段，用与区分子表类型public abstract class Animal implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String age; // 省略constructor 、getters、setters&#125;@Entity@DiscriminatorValue(&quot;Cat&quot;)public class Cat extends Animal &#123; private String weight;&#125;@Entity@DiscriminatorValue(&quot;Dog&quot;)public class Dog extends Animal &#123; private String height;&#125; 生成了一张数据表： 这种方法不仅简单，而且性能也是最优的。因为每个子类使用了@Entity注解，子类的属性都会被映射到Animal表的列中。 这种方法在子类中使用@NotNull注解会被hibernate忽略，因为如果你定义了Dog类的height属性不能为null，但是当保存cat类的数据时，height必然为null。 JOINED策略代码如下：12345678910111213141516171819@Entity@Inheritance(strategy = InheritanceType.JOINED) // 继承（策略 = TABLE_PER_CLASS）public abstract class Animal &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) // 不能使用自动生成主键策略 private Long id; private String age;&#125;@Entitypublic class Dog extends Animal &#123; private String height;&#125;@Entitypublic class Cat extends Animal &#123; private String weight;&#125; 此时生成了三张表我们可以看到dog和cat表中并没有age属性当我们想获取age属性时，我们通过左链接的方式取值。 TABLE_PER_CLASS策略这种策略不能使用自动生成主键的策略，代码如下：12345678910111213141516171819@Entity@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // 继承（策略 = TABLE_PER_CLASS）public class Animal &#123; @Id //@GeneratedValue(strategy = GenerationType.AUTO) // 不能使用自动生成主键策略 private Long id; private String age;&#125;@Entitypublic class Cat extends Animal &#123; private String weight;&#125;@Entitypublic class Dog extends Animal &#123; private String height;&#125; 生成了三张数据表：如果把Animal改为abstract类，则只会生成两张表 总结学习了以上三种方式，那么我们在什么情况下使用他们呢？ 当父类的属性较多时，我们使用InheritanceType.SINGLE_TABLE策略，已达到最少可为空的列的数量。 当父类的属性较少，而子类的属性较多时，我们使用InheritanceType.JOINED策略。 当我们很少对父类进行操作时，我们使用InheritanceType.TABLE_PER_CLASS策略，这种方法倾向于把每一个类对应一个具体的表。","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://www.mengyunzhi.cn/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.mengyunzhi.cn/tags/Hibernate/"}]},{"title":"FreeBSD如何更新freebsd的port tree","slug":"how-to-update-port-tree","date":"2017-10-13T08:26:23.000Z","updated":"2017-12-29T06:58:04.828Z","comments":true,"path":"2017/10/13/how-to-update-port-tree/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/13/how-to-update-port-tree/","excerpt":"在使用freebsd系统进行软件安装时，如果该软件发生了安全问题，则freebsd的ports服务器会更新其对应的版本。此时，如果我们的本地服务器未更新到最新的ports，则会提示“该软件发现了安全问题，请更新ports tree后再来安装”的提示。\n问题描述比如，我在安装nodejs时，报了以下错误：123456789===&gt;  node-8.1.3 has known vulnerabilities:node-8.1.3 is vulnerable:node.js -- multiple vulnerabilitiesWWW: https://vuxml.FreeBSD.org/freebsd/3eff66c5-66c9-11e7-aa1d-3d2e663cef42.html1 problem(s) in the installed packages found.=&gt; Please update your ports tree and try again.=&gt; Note: Vulnerable ports are marked as such even if there is no update available.=&gt; If you wish to ignore this vulnerability rebuild with 'make DISABLE_VULNERABILITIES=yes'\n我们常说小白，小白只所以白，往往是由于我们发现错误后，根本就不看错误给我的提示，然后就胡乱的进行一通错误的排查。而错误提醒却恰恰是解决这个问题关键。\n是的，我们往往在开发程序时，也会把一些重要的话输出出来，来提醒使用者他那底错在哪了。告别小白，从看错误提示开始.","text":"在使用freebsd系统进行软件安装时，如果该软件发生了安全问题，则freebsd的ports服务器会更新其对应的版本。此时，如果我们的本地服务器未更新到最新的ports，则会提示“该软件发现了安全问题，请更新ports tree后再来安装”的提示。 问题描述比如，我在安装nodejs时，报了以下错误：123456789===&gt; node-8.1.3 has known vulnerabilities:node-8.1.3 is vulnerable:node.js -- multiple vulnerabilitiesWWW: https://vuxml.FreeBSD.org/freebsd/3eff66c5-66c9-11e7-aa1d-3d2e663cef42.html1 problem(s) in the installed packages found.=&gt; Please update your ports tree and try again.=&gt; Note: Vulnerable ports are marked as such even if there is no update available.=&gt; If you wish to ignore this vulnerability rebuild with 'make DISABLE_VULNERABILITIES=yes' 我们常说小白，小白只所以白，往往是由于我们发现错误后，根本就不看错误给我的提示，然后就胡乱的进行一通错误的排查。而错误提醒却恰恰是解决这个问题关键。 是的，我们往往在开发程序时，也会把一些重要的话输出出来，来提醒使用者他那底错在哪了。告别小白，从看错误提示开始. 解决的方法，当然是上述的提示进行操作了。 Please update your ports tree and try again =》 请更新你的ports tree后再次尝试。 GOOGLE关键字有了上面的错误提示，此时，我们google时，方向就更明确了。我们以freebsd update ports tree来进行搜索。很快，将会获得我们想要的答案。比如，我查询时，获取了以下信息： Portsnap is the tool we will use to update our ports tree. It is fast, and simple to use. The first time you run portsnap, it needs to download the entire ports tree, which is a download in the tens of megabytes. portsnap fetchportsnap extract Henceforth, anytime you want to update your ports tree, you will only have to run this command: portsnap fetch update 碰到英文如果读不懂的话，就慢点读，找自己认识的单词读，先尝试了解这个文章的大概意思。当然，最重要的还是坚持。如果对比英文水平，应该是大一的水平最强，越往后水平越差。如果你不幸在大一大二期间没有阅读过英文的站点，这时候你选择的不应该是放弃，而是比别人多下一番功夫。 我简单的译一下上面的英文： 我们可以使用Portsnap这个工具来更新我们的ports tree。Portsnap使用起来即简单又高效。如果你在本服务器上第一次使用Portsnaphe，则需要下载整个ports tree。当然了，下载的东西会很多。以下是首次使用的两个命令。 portsnap fetchportsnap extract 当下次我们再更新ports tree时，只需要使用以下命令就可以了。 portsnap fetch update 总结问题并不复杂。解决问题的难易取决于英文阅读能力的高低。简单的事情重复做，你就是专家。在平常的学习时，我们离不开使用google查找一些问题。当某个问题你是参考某个英文站点解决的，那么请多花些时间在你刚刚参考的英文页面上，尝试性的翻译大多数的英文单词，来彻底的搞明白这个帮你解决了问题的页面到底说了些什么。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"freebsd","slug":"freebsd","permalink":"http://www.mengyunzhi.cn/tags/freebsd/"}]},{"title":"SpringMVC+Angularjs上传图片","slug":"SpringMVC-Angularjs-upload-image","date":"2017-10-10T07:24:23.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/10/10/SpringMVC-Angularjs-upload-image/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/10/SpringMVC-Angularjs-upload-image/","excerpt":"最近，完成了图片上传的功能，中间也遇到了一些问题，本文记录了上传图片的代码段，希望下次开发相同的功能时尽可能的节约时间。环境：后台SpringMvc，前台angularjs，前台插件angular-file-upload  。","text":"最近，完成了图片上传的功能，中间也遇到了一些问题，本文记录了上传图片的代码段，希望下次开发相同的功能时尽可能的节约时间。环境：后台SpringMvc，前台angularjs，前台插件angular-file-upload 。 开发思路 开发顺序：先开发前台，再开发后台。从而避免开发后台的功能后，前台不需要此功能的情况。 前台开发：我们把图片作为一个指令，以方便在各个模块中的使用。引入angular-file-upload插件。 后台应该建立图片相关实体，后台获取到图片后，对文件流进行sha1或md5加密，判断如果后台服务器已经存在相同的图片，则不在上传该图片，直接引用之前上传的图片，以节约服务器资源。类似地，删除图片时，也应该判断是否改图片被引用多次，如果被引用多次，则不需要删除服务器中的图片，只删除图片实体中的那一条记录即可。如果用户要删除的图片只被引用一次，则删除图片实体中的记录，并删除服务器中的图片，释放服务器资源。同时，参考官方文档 ，并根据前台需求，完成后台功能代码。 通过这种方法，如果用户上传较大的文件，且服务器之前已经上传过相同的文件，那么就可以实现秒传，同时节约了服务器的资源。所以，有时我们在一些平台上（如迅雷）上传几百兆或者几个Ｇ的文件，也可秒传，并不是网速很快，而是因为服务器上已经存在相同的文件。 给出附件实体实例12345678910111213141516171819202122232425262728293031323334353637383940414243@Entity@ApiModel(value = &quot;Attachment (附件)&quot;, description = &quot;附件&quot;)public class Attachment implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @ManyToOne @ApiModelProperty(&quot;操作用户&quot;) private User operator; @ApiModelProperty(&quot;sha1值&quot;) private String sha1; @ApiModelProperty(&quot;md5值&quot;) private String md5; @ApiModelProperty(&quot;附件扩展名&quot;) private String ext; @ApiModelProperty(&quot;附件大小&quot;) private String size; @ApiModelProperty(&quot;附件上传时间&quot;) private Long createTime; @ApiModelProperty(&quot;附件更新时间&quot;) private Long updateTime; @ApiModelProperty(&quot;附件名称&quot;) private String name; @ApiModelProperty(&quot;附件存储路径&quot;) private String savePath; @ApiModelProperty(&quot;附件存储名称&quot;) private String saveName; @ApiModelProperty(&quot;MIME类型&quot;) private String MIME; // 省略constructor、getters、setters 前台代码界面的效果图如下： 前台代码放在github上，代码地址：https://github.com/chuhang123/blog/tree/master/2017/uploadImage 。 在前台代码中，我们需要对图片标题长度过滤 ，代码如下：12345678910111213// 长度为２０return function (input) &#123; var r=/[^\\x00-\\xff]/g; if(input.replace(r,&quot;mm&quot;).length&lt;=20)&#123;return input;&#125; var m=Math.floor(20/2); for(var i=m;i&lt;input.length;i++)&#123; if(input.substr(0,i).replace(r,&quot;mm&quot;).length&gt;=20)&#123; return input.substr(0,i)+&quot;...&quot;; &#125; &#125; return input;&#125;; 显示图片的缩略图 ，并根据项目需求请求后台代码。 后台代码在后台的附件控制器中建立三个请求借口：删除、上传、图片访问入口。同时参考官方文档 。 如上图所示，需要注意４个地方： 预览图片时，我们要根据图片的保存名称来浏览图片，我们要使用{saveName:.+}获取图片的名称，否则不能正确获取图片的名称。 参考官方教程浏览图片时，控制台会抛出HttpMessageNotWritableException异常，我们需要设置响应信息的内容类型，就把这个异常给解决了。 官方文档是把文件流放在响应信息中，但这种方式相当消耗服务器的资源，假设一个图片１Ｍ，有１００个并发请求，那么就要消耗服务器１００Ｍ的内存，那么如果有更多的并发请求，那么就非常消耗资源。所以等项目上线后把开放图片路径，以节约服务器资源。 上传的图片类型为MultipartFile, 所以前台的请求内容类型应该为Content-Type:multipart/form-data，请求实例如下：1234567var formData = new FormData();formData.append(&apos;attachment&apos;, image);$http.post(url, formData, &#123;transformRequest: angular.identity,headers: &#123;&apos;Content-Type&apos;: undefined&#125;&#125;)........ 设置图片大小上限，在配置文件中增加如下代码： 123// 设置图片最大为３Ｍspring.http.multipart.max-file-size=3072KB spring.http.multipart.max-request-size=3072KB 当其他实体和附件相关时，比如强检申请：附件=1：n，因为可能还会有很多实体和附件相关联，因此在强检申请实体中使用@OneToMany单向映射较为合适。为了操作方便，通过使用 @JoinColumn不再建立中间表。 12@OneToMany @JoinColumn(name = &quot;mandatoryInstrumentApply_id&quot;) 因为我们需要对MultipartFile类型的文件进行sha1、md5加密，所以这里给出hash加密算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 根据指定的算法加密文件数据, 返回固定长度的十六进制小写哈希值 * * @param multipartFile 需要加密的文件 * @param algorithm 加密算法, 例如: MD5, SHA-1, SHA-256, SHA-512 等 */ static String encrypt(MultipartFile multipartFile, String algorithm) throws Exception &#123; InputStream in = null; try &#123; // 1. 根据算法名称获实现了算法的加密实例 MessageDigest digest = MessageDigest.getInstance(algorithm); in = multipartFile.getInputStream(); byte[] buf = new byte[1024]; int len = -1; while ((len = in.read(buf)) != -1) &#123; // 2. 文件数据通常比较大, 使用 update() 方法逐步添加 digest.update(buf, 0, len); &#125; // 3. 计算数据的哈希值, 添加完数据后 digest() 方法只能被调用一次 byte[] cipher = digest.digest(); // 4. 将结果转换为十六进制小写 return bytesToString(cipher); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (Exception e) &#123; // nothing &#125; &#125; &#125; &#125; // 将字节转为字符串 static String bytesToString(byte[] bytes) &#123; if (bytes == null || bytes.length == 0) &#123; return null; &#125; StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(HEXES[(b &gt;&gt; 4) &amp; 0x0F]); stringBuilder.append(HEXES[b &amp; 0x0F]); &#125; return stringBuilder.toString(); &#125; // 十六进制字符数组 static char[] HEXES = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos; &#125;; 总结这次附件上传花费了较长的时间，一方面水平不够，一方面有些追求完美，从而耽误了时间，所以完成任务是第一位的，切忌追求完美。望以后注意。","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://www.mengyunzhi.cn/tags/SpringMVC/"},{"name":"angular","slug":"angular","permalink":"http://www.mengyunzhi.cn/tags/angular/"}]},{"title":"学习JPA的@OneToMany注解","slug":"Learning-JPA-OneToMany","date":"2017-10-09T07:05:43.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/10/09/Learning-JPA-OneToMany/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/09/Learning-JPA-OneToMany/","excerpt":"","text":"在JPA中，最常用的关系大概就是一对多了。假设实体A、B的关系为A:B=1:n，通常情况下，我们会在B实体中使用@ManyToOne的注解。但是有时我们需要在A实体中使用@OneToMany的注解，那么我们应该怎么办呢？ 以下代码中，假设实体One和Many的关系为One:Many=1:n 单向映射@OneToMany我们只在One实体中使用注解，代码如下12345678910111213141516171819@Entitypublic class One &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @OneToMany private List&lt;Many&gt; manys = new ArrayList&lt;&gt;(); // 省略构造函数，getters and setters&#125;@Entitypublic class Many &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name;&#125; 生成的数据表如下：1234567891011121314151617181920212223MariaDB [springmvc]&gt; select * from one;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from many;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from one_manys;+--------+----------+| one_id | manys_id |+--------+----------+| 1 | 1 |+--------+----------+1 row in set (0.00 sec) 现在，我们如果想要在中间表中存一条记录，就必须先要保证many实体中存在一条记录，然后保存one对象时设置和many的关联关系？代码如下：123456789101112logger.info(&quot;新建One实体&quot;);One one = new One();logger.info(&quot;新建并保存Many实体&quot;);Many many = new Many(&quot;test&quot;);manyRepository.save(many); // 能不能省略这行代码呢？logger.info(&quot;保存&quot;);List&lt;Many&gt; manies = new ArrayList&lt;&gt;();manies.add(many);one.setManys(manies);oneRepository.save(one); 我们能不能省略manyRepository.save(many);，答案是可以的。直接在One实体中的@OneToMany注解后面加入括号(cascade = CascadeType.ALL, orphanRemoval = true)，JPA仍然会自动保存many实体。 此时，如果我们把Many实体表中id为1的记录删除，会报一个外键约束的错误，我们需要先把one_manys表中的记录删除，才可以删除Many实体表中id为1的记录。这样是不是有点麻烦呢？有没有办法直接删除Many实体中的记录呢？我们在One实体中增加一个注解@JoinColumn就可以了，代码如下： 12345678910@Entitypublic class One &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @OneToMany @JoinColumn(name = &quot;many_id&quot;) private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();&#125; 数据表的结构如下：123456789101112131415161718MariaDB [springmvc]&gt; select * from one;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from many;+----+------+---------+| id | name | many_id |+----+------+---------+| 1 | test | 1 |+----+------+---------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from one_manys;ERROR 1146 (42S02): Table &apos;springmvc.one_manys&apos; doesn&apos;t exist 这样就不会增加中间表了，此时我们可以直接删除many实体中的记录了。 双向映射@OneToMany代码如下：12345678910111213141516171819@Entitypublic class Many &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @ManyToOne private One one;&#125;@Entitypublic class One &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; @OneToMany private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();&#125; 生成的数据表如下：1234567891011121314151617181920212223MariaDB [springmvc]&gt; select * from one_manys;+--------+----------+| one_id | manys_id |+--------+----------+| 1 | 1 |+--------+----------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from many;+----+------+--------+| id | name | one_id |+----+------+--------+| 1 | test | 1 |+----+------+--------+1 row in set (0.00 sec)MariaDB [springmvc]&gt; select * from one;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec) 总结我们经常会用到实体间的关系，但是往往在实际的项目中，由于项目过于庞大，增加了学习成本。因此，比较好的学习方法就是在一个测试的项目中学习，减少学习成本。 参考链接：The best way to map a @OneToMany relationship with JPA and Hibernate","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://www.mengyunzhi.cn/tags/JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.mengyunzhi.cn/tags/Hibernate/"}]},{"title":"js的浅拷贝和深拷贝学习","slug":"js-deep-copy-and-shallow-copy","date":"2017-10-08T08:31:00.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/10/08/js-deep-copy-and-shallow-copy/","link":"","permalink":"http://www.mengyunzhi.cn/2017/10/08/js-deep-copy-and-shallow-copy/","excerpt":"最近做项目时，发现把A赋值给B，当我改变B时，A也随之改变了。google了一下，了解到在js中，当一个变量复制另一个变量时，其实复制的是一个地址，改变其中一个变量，另一个也会随之改变。\n这种复制分两种情况：拷贝引用（浅拷贝）和拷贝实例（深拷贝）","text":"最近做项目时，发现把A赋值给B，当我改变B时，A也随之改变了。google了一下，了解到在js中，当一个变量复制另一个变量时，其实复制的是一个地址，改变其中一个变量，另一个也会随之改变。 这种复制分两种情况：拷贝引用（浅拷贝）和拷贝实例（深拷贝） 浅copy 拷贝原对象的引用 123456var o1 = &#123;a: 1&#125;;var o2 = o1;console.log(o1 === o2); // =&gt;trueo2.a = 2; console.log(o1.a); // =&gt; 2 拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用 12345678910var o1 = [&apos;darko&apos;, &#123;age: 22&#125;];var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的浅拷贝对象console.log(o1 === o2); // =&gt; false，说明o2拷贝的是o1的一个实例o2[0] = &apos;lee&apos;;console.log(o1[0]); // =&gt; &quot;darko&quot; o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响o2[1].age = 23;console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响 浅copy实现123456789101112function shallowClone(source) &#123; if (!source || typeof source !== &apos;object&apos;) &#123; throw new Error(&apos;error arguments&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125; 深copy深copy有两种方法 使用JSON.stringify和JSON.parse。JSON.parse(JSON.stringify(object))。这种方法只能copy对象的属性，不能copy对象的方法。 使用递归的方法实现1234567891011121314151617function deepClone(source)&#123; if(!source || typeof source !== &apos;object&apos;)&#123; throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for(var keys in source)&#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; 参考链接： JavaScript中的浅拷贝和深拷贝 javascript中的深拷贝和浅拷贝？","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.mengyunzhi.cn/tags/js/"}]},{"title":"多关键字实体的更新方法","slug":"how-to-update-entity-of-multiple-key","date":"2017-09-30T00:31:44.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/09/30/how-to-update-entity-of-multiple-key/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/30/how-to-update-entity-of-multiple-key/","excerpt":"假设我们有以下实体，该实体共有4个属性，其中有2个属性组成了组合主键。\n\n下面，简单阐述下如何正确的实现对上述实体类型的更新操作。","text":"假设我们有以下实体，该实体共有4个属性，其中有2个属性组成了组合主键。 下面，简单阐述下如何正确的实现对上述实体类型的更新操作。 操作习惯在进行更新时，按以往的方法，我们只需要设置好这个实体的主键，然后调用save方法，就可以了。如下:12345@Overridepublic void saveOrUpdate(DeviceInstrument deviceInstrument) &#123; deviceInstrumentRepository.save(deviceInstrument); return;&#125; 结果：失败。 有则更新，无则插入那么我们换种思路：造成前面的方法失效的原因：可能是SpringMVC在进行save操作时，不能够区分是插入还是更新。 解决方法：在进行数据保存前，先查找是否有历史记录。如果有，执行更新操作；没有，则执行插入操作。 代码如下： 1234567891011121314@Overridepublic void saveOrUpdate(DeviceInstrument deviceInstrument) &#123; DeviceInstrument oldDeviceInstrument = deviceInstrumentRepository.findOne(deviceInstrument.getId()); if (null == oldDeviceInstrument) &#123; logger.info(\"新记录，保存\"); deviceInstrumentRepository.save(deviceInstrument); &#125; else &#123; logger.info(\"老记录，更新\"); oldDeviceInstrument.setAccuracy(deviceInstrument.getAccuracy()); oldDeviceInstrument.setMeasureScale(deviceInstrument.getMeasureScale()); deviceInstrumentRepository.save(oldDeviceInstrument); &#125; return;&#125; 对此，我也写了单元测试，单元测试显示成功的更新了数据。但是，正常调用过程中，数据表的数据仍然未改变。我猜想可能是由于SpringMVC的缓存机制，数据没有成功更新吧。看来还需要进一步对单元测试与SpringMVC的JPA加强学习。 先删除，再插入通过前面尝试，我猜想可能是多主键时，udpate并没有起作用，也就是说，想使用update的方法来直接更新实体信息这个思路是错误的。 解决方法：先删除原有的记录，然后再插入一条新的记录。代码如下： 1234567891011@Overridepublic void saveOrUpdate(DeviceInstrument deviceInstrument) &#123; DeviceInstrument oldDeviceInstrument = deviceInstrumentRepository.findOne(deviceInstrument.getId()); if (null != oldDeviceInstrument) &#123; logger.info(\"老记录，先删除原记录\"); deviceInstrumentRepository.delete(oldDeviceInstrument); &#125; deviceInstrumentRepository.save(deviceInstrument); return;&#125; 无论是单元测试还是生产环境，上述代码都得到了期待的结果。 总结在多主键表中，我们需要使用先删除再插入的方法来实现更新操作。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://www.mengyunzhi.cn/tags/SpringMVC/"},{"name":"JPA","slug":"JPA","permalink":"http://www.mengyunzhi.cn/tags/JPA/"}]},{"title":"在angularjs中，设置元素不可见替代隐藏元素的方法","slug":"Make-element-visibility-but-not-hidden-in-AngularJs","date":"2017-09-28T05:33:34.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/","excerpt":"在AngularJS中，我们都知道使用ng-hide来隐藏元素。但有时候，我们需要的却是元素不可见。\n此时，我们需要使用ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;来代替ng-hide=&quot;express&quot;。其中，express为变量或是表达式。\n元素不可见与元素隐藏有什么关系呢？\n在CSS中:隐藏元素 = display: none元素不可见 = visibility: hidden\n下面，我们通过下面的小例子，来看看具体他们的区别，以及元素不可见的应用场景。","text":"在AngularJS中，我们都知道使用ng-hide来隐藏元素。但有时候，我们需要的却是元素不可见。 此时，我们需要使用ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;来代替ng-hide=&quot;express&quot;。其中，express为变量或是表达式。 元素不可见与元素隐藏有什么关系呢？ 在CSS中:隐藏元素 = display: none元素不可见 = visibility: hidden 下面，我们通过下面的小例子，来看看具体他们的区别，以及元素不可见的应用场景。 实例在计量的项目中，我们需要对精确度进行排序，假设现在效果如下： 点击上、下图标时，可以改变精确度的顺序。 需求我们的实际需求是这样的： 即，使用visibility: hidden，不显示（同时，仍然占有原来的位置）第一条的“向上箭头”，不显示（同时，仍然占有原来的位置）最后一条的“向下箭头”。代码段为：1ng-style=\"&#123;'visibility': $last ? 'hidden' : 'visible'&#125;\" 其中，$last为变量或是表达式。 ng-hide我们将第一条的visibility: hidden，更改为ng-hide修改前：1&lt;a href=\"javascript:void(0);\" ng-style=\"&#123;'visibility': $first ? 'hidden' : 'visible'&#125;\" ng-click=\"upAccuracy(data)\"&gt;&amp;nbsp;&lt;i class=\"fa fa-caret-square-o-up text-success\"&gt;&lt;/i&gt;&amp;nbsp;&lt;/a&gt;&amp;nbsp; 修改后：1&lt;a href=\"javascript:void(0);\" ng-hide=\"$first\" ng-click=\"upAccuracy(data)\"&gt;&amp;nbsp;&lt;i class=\"fa fa-caret-square-o-up text-success\"&gt;&lt;/i&gt;&amp;nbsp;&lt;/a&gt;&amp;nbsp; 修改后效果： 我们看到，通过ng-hide后，后面的元素视为该元素不存在，所以占用了隐藏元素原来的位置。而使用ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;后，虽然其隐藏掉了，但后面的元素依然视该元素存在。近而保持了格式的统一。 参考：https://stackoverflow.com/questions/26927585/visibility-hidden-in-angularjs google关键字：ng-hide visibility hidden","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.mengyunzhi.cn/tags/AngularJS/"}]},{"title":"统计实验数据的步骤","slug":"The-steps-of-laboratory-data-statistics-data","date":"2017-09-28T03:01:34.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/09/28/The-steps-of-laboratory-data-statistics-data/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/28/The-steps-of-laboratory-data-statistics-data/","excerpt":"本年一次的数据统计总是耗费过多的时间，现将统计步骤总结如下：","text":"本年一次的数据统计总是耗费过多的时间，现将统计步骤总结如下： 安装统计软件该软件建议安装在win7上。进行QQ邮箱，查找关键字：实验室统计软件及数据。下载相关的软件及往年的数据。安装后，将往年的数据解压到安装软件对应的数据的位置上。 注意：如果软件进行重新安装，那么卸载后，还需要手工删除原来的程序文件夹，否则在安装过程中，不提示使用钥匙盘，将报错。 较验历史数据当使用新库（教务处给的），替换掉原来的老库时，需要对数据较验。发现较验错误后，查看是否为新库的字段与老库不一致造成了问题，如果出现该问题，则需要在数据维护时注意。 获取实验数据找到本学年所有实验室1-16周的实验数据，并整理到A4纸上。统计的格式如下： 课程名称 实验教师 上课班级 上课总人数 实验室 获取班级人数班级人数可以找楼下教学秘书获取，也可以查看年末的监考信息，在监考信息中，有每个班级的人数。计算后，补充到整理的A4纸上，以备录入。 数据录入如果有新教师加入，需要先进行教师管理，维护新的教师信息。 修改本学年的实验数据，除需要保证所有的 * 的字段都正确以外，还需要选择任课教师，填写上课班级。注意：同一门课程可以合并。 建议安装VF软件，统一删除上学年有，而本学年没有数据。在软件中，逐条删除设置的不合理。 删除完不该存在历史数据后，添加新的数据。 如果是新课程，则需要先维护课程名以及课程对应的多个实验名。该信息，需要参考教学计划，教学计划找主老师协助。 较验数据数据填写完毕后，点击数据较验，较验系统数据。正常来讲，如果开始较难过数据，就已经早早的发现基本库发生的变化，在填写数据时，肯定也已经注意到了。所以此时的较验压力会小很多。 备份数据点击 系统维护 数据备份 选择所有的数据进行备份，然后进行备份文件夹，打包发给教务处。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"tute","slug":"tute","permalink":"http://www.mengyunzhi.cn/tags/tute/"}]},{"title":"如何在本地使用hexo发表文章","slug":"how-to-use-hexo-in-local","date":"2017-09-28T00:57:14.000Z","updated":"2017-12-29T06:58:04.832Z","comments":true,"path":"2017/09/28/how-to-use-hexo-in-local/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/28/how-to-use-hexo-in-local/","excerpt":"安装hexohexo是nodejs下的一个小软件，我们需要使用npm进行安装.\n1$ npm install -g hexo-cli\n\nhexo在创建新项目时，会使用git命令。如果你是新队员，那么在安装hexo-cli前，还需要安装github或git。\n\nclone团队项目项目地址： https://github.com/yunzhiclub/hexoclone后，使用命令行，进入所在文件夹。进行npm依赖安装：","text":"安装hexohexo是nodejs下的一个小软件，我们需要使用npm进行安装. 1$ npm install -g hexo-cli hexo在创建新项目时，会使用git命令。如果你是新队员，那么在安装hexo-cli前，还需要安装github或git。 clone团队项目项目地址： https://github.com/yunzhiclub/hexoclone后，使用命令行，进入所在文件夹。进行npm依赖安装： 1$ npm install clone主题团队blog的主题在原第三方主题的基础上，进行了个性化的设置。设置后的内容上传到了团队的仓库中，当前团队应用的主题为：hext(具体可以查看根目录下的.travis.yml文件)。我们依然在项目的根目录下，执行以下命令。1$ git clone --depth=1 https://github.com/mengyunzhi/hexo-theme-next themes/next 操作后，你将在themes文件夹上得到一个next文件夹，结构如下：1234567├── source│ ├── _posts│ ├── categories│ ├── images│ └── tags└── themes └── next 新建分支在项目master分支的基础上，新建自己的分支。1$ git checkout -b yourBranchName(替换为你分支的名字，比如xiaoming) 启动项目1$ hexo server 项目启动后，我们便可以在浏览器中打开http://localhost:4000/来实时阅览项目了。 新建文章1$ hexo new &quot;new title&quot; 这里标题尽量使用英文。命令成功执行后，将在source/_posts下生成新的文章。 比如：123456---title: new titledate: 2017-05-31 16:57:35tags: category: --- 这里，我们尽量的采用英文的名称先进行命名，因为它会自动我们生成文件名。在文件名中保证不出现中文，是个好个习惯。 然后：我们将这里的title修改为中文。tags是标签，如果是多个，可以这样写:[html,css]。category类别，这里写上自己的名字。 123456---title: 如何在本地使用hexo发表文章date: 2017-05-31 16:57:35tags: hexocategory: teacherPan--- 最后，就是我们使用markdown语言进行BLOG的写作了。 内容完成后，像我们参与其它的团队项目的开发一样，进行pull request。代码审核后，你的文章将自动的出现在http://www.mengyunzhi.cn中. 更多内容请参考 ：https://hexo.io/docs/index.html","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.mengyunzhi.cn/tags/hexo/"}]},{"title":"旅游项目如何实现手机预览","slug":"localhost-pc-phone","date":"2017-09-22T06:28:55.000Z","updated":"2017-12-29T06:58:04.824Z","comments":true,"path":"2017/09/22/localhost-pc-phone/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/22/localhost-pc-phone/","excerpt":"当我们真的想实现手机微信扫一扫实现预览网页的功能的时候我们不必将项目放在服务器上，本地也可以。","text":"当我们真的想实现手机微信扫一扫实现预览网页的功能的时候我们不必将项目放在服务器上，本地也可以。 环境 : ubuntu16.04，android手机 ifconfig首先我们在终端输入ifconfig来查看本机的ip地址。 修改代码然后我们打开index/view/article/preview.html 将配置原来的url配置1&#123;:ROOT_DOMAIN&#125;/index/article/main?articleId=&#123;$articleId&#125; 修改为 1http://192.168.0.101:80/beautifulArtical/thinkphp/public/index/article/main?articleId=&#123;$articleId&#125; 然后此时我们扫描二维码就可以用微信预览了。 解释当我们输入url的时候电脑会发送给DNS服务器解析出此域名对应的ip地址，然后我们的电脑才会向路由器发送数据包，然后路由器根据目的ip找到相应的电脑。但是如果我们直接输入ip地址，现在我们的手机机会向路由器和本局域网下的所有电脑发送数据包，然后我的电脑和路由器会同时接收到这个数据包，但是路由器会丢弃这个数据包，因为路由器根据转发表发现此ip地址位于本局域网的一台电脑，而我的电脑则会向我的手机发送具体的数据包，这样手机上就可以访问localhost的网页内容了. 总结我本已经学过了计算机网络，这是最简单的道理，但自己却没有想到。用课本知识解决实际问题的能力还是太差。","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[]},{"title":"安装protracto记","slug":"how-to-install-protracto","date":"2017-09-19T07:13:34.000Z","updated":"2017-12-29T06:58:04.816Z","comments":true,"path":"2017/09/19/how-to-install-protracto/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/19/how-to-install-protracto/","excerpt":"protracto是angularjs下的一个E2E集成测试工具。所谓集成测试，就是把各个模块开发完，对接好后，一起跑一下系统，然后看各个模块的关联是否有问题。\n我们在项目中，往往通过手工点击的方法来完成集成测试。由于每个人对项目的理解都不一致，加之每次测试的状态及我们所处的环境不同。导致了前后可能测试了100次，但却使用了100次不同的测试步骤。\n有了集成测试工具，我们只需要把相关点击和输入的操作放在代码中，然后看着浏览器自动为我们执行操作就可以了。\n我们还可以像单元测试一样，写一些断言。当测试跑完，系统会自动告诉我们哪些测试没有通过，期待的值是什么，又实际返回了什么值。","text":"protracto是angularjs下的一个E2E集成测试工具。所谓集成测试，就是把各个模块开发完，对接好后，一起跑一下系统，然后看各个模块的关联是否有问题。 我们在项目中，往往通过手工点击的方法来完成集成测试。由于每个人对项目的理解都不一致，加之每次测试的状态及我们所处的环境不同。导致了前后可能测试了100次，但却使用了100次不同的测试步骤。 有了集成测试工具，我们只需要把相关点击和输入的操作放在代码中，然后看着浏览器自动为我们执行操作就可以了。 我们还可以像单元测试一样，写一些断言。当测试跑完，系统会自动告诉我们哪些测试没有通过，期待的值是什么，又实际返回了什么值。 官方文档我进行安装前，首先，我找到了官方文档：http://www.protractortest.org/#/tutorial 然后就是按照官方文档的步骤进行安装。官方文档的介绍，大体分为以下几步。 安装protractor 升级webdriver-manager 启动webdriver-manager 写测试文件 写配置文件 运行第一个测试 完善测试 首先，我们先进入angularjs的项目根目录，比如webApp。 安装protractor安装protractor，我们需要使用命令：npm install -g protractor这代码着，protractor依赖于nodejs. 升级webdriver-manager使用命令：webdriver-manager update 实际的安装中，我遇到了以下问题： nodejs版本较低，导致输入上述命令时，提示语法错误（高版本新的语法，低版本的nodejs不支持） 提示发生了access权限问题 在线更新包时，发生了超时连接的错误 解决方法如下： 进入nodejs官网，下载最新版本的nodejs并安装. 在使用命令时，使用sudo webdriver-manager update（windows权限问题，请google解决） 由于我使用了shadowsocks做为代理，shadowsocks仅支持Socks5代理方式，但我们的shell仅支持http,所以我们需要需要解决将Socks5转化为http的问题。 使用brew install privoxy命令，安装了并配置了privoxy，将socks代理变为http代理。 使用webdriver-manager --help命令，获取到我可以使用--proxy参数来指定代理。 使用sudo webdriver-manager update --proxy=http://127.0.0.1:8118来完成了更新操作. MAC系统安装与配置privoxy请参考:http://www.iosugar.com/2017/02/19/Mac-terminal-environment/大体总结如下：1.安装privoxy 2.配置privoxy 3. 启动privoxy 4.将privoxy设置为开机自启动(在~/user(你的用户名)下，修改.bash_profile, 并增加/usr/local/sbin/privoxy /usr/local/etc/privoxy/config一行) 启动webdriver-manager同样，我使用了官方的webdriver-manager start来尝试启动这个应用。运气不太好，获取了无法执行的错误。google查询后，得到了当前路径的node_modules中不存在webdriver-manager导致出错的原因。观察package.json发现，的确未自动写入关于protracto。再经过查询，得到以下文章，并主要进行了参考： http://thejackalofjavascript.com/end-to-end-testing-with-protractor/ 略过前面安装yoman的部分，分别执行以下语句：npm i protractor --save-devsudo ./node_modules/protractor/bin/webdriver-manager update --proxy=http://127.0.0.1:8118sudo ./node_modules/protractor/bin/webdriver-manager start服务成功启动。 我们将服务窗口最小化(注意：不是关闭)，然后继续操作。再次启动时，需要先启动privoxy，再执行以上的update及start 写测试文件在test文件夹中，新建e2e文件夹，及login文件。 123456describe('Protractor Demo App', function() &#123; it('should have a title', function() &#123; browser.get(''); // 打开根地址（相对于配置文件的baseUrl） expect(browser.getTitle()).toEqual('计量器具管理平台'); // 断言标题 &#125;);&#125;); 写配置文件在根目录中，我们建立protractor-e2e.js，并加入以下配置：123456789101112131415161718192021222324252627282930exports.config = &#123; // 运行所有的脚本的最长时间 allScriptsTimeout: 99999, // The address of a running selenium server.前面，我们使用start命令启动的服务地址 seleniumAddress: 'http://localhost:4444/wd/hub', // Capabilities to be passed to the webdriver instance. 测试兼容性的浏览器设置 capabilities: &#123; 'browserName': 'chrome' &#125;, // 项目地址 baseUrl: 'http://localhost:9000/', framework: 'jasmine', // Spec patterns are relative to the current working directly when // protractor is called. // 测试文件所在位置（使用的是表达式） specs: ['test/e2e/*.js'], // Options to be passed to Jasmine-node. // 其它选项 jasmineNodeOpts: &#123; showColors: true, defaultTimeoutInterval: 30000, isVerbose: true, includeStackTrace: true &#125;&#125;; 运行第一个测试./node_modules/protractor/bin/protractor protractor-e2e.js此时，浏览器当自动当前我们测试文件中设置的地址，然后获取标题信息，并进行断言。 完善测试继续完善login.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546'use strict';/* https://github.com/angular/protractor/blob/master/docs/getting-started.md */describe('my app', function() &#123; browser.ignoreSynchronization = true; browser.waitForAngular(); beforeEach(function() &#123; browser.get(''); // 每次测试前，都先尝试打开根目录 &#125;); it('自动跳转至用户登录界面', function() &#123; expect(browser.getTitle()).toEqual('计量器具管理平台'); // 获取并断言标题 // 获取当前的url信息，并断言必然跳转至/login browser.driver.getCurrentUrl().then(function(url) &#123; var absUrl = url.split('#!'); expect(absUrl[1]).toEqual('/login'); &#125;); &#125;); it('正确的用户名密码进行登录', function() &#123; // 获取username password和登录按钮 var username = element(by.model('user.username')); var password = element(by.model('user.password')); var login = element(by.partialButtonText('登')); // 自动输入用户名和密码 username.sendKeys('admin'); password.sendKeys('admin'); // 前击登录 login.click(); // 延迟3秒等待系统完成登录 browser.driver.sleep(3000); browser.waitForAngular(); // 获取当前地址为首页的仪表台地址 browser.driver.getCurrentUrl().then(function(url) &#123; var absUrl = url.split('#!'); expect(absUrl[1]).toEqual('/main/dashboard'); console.log(url); &#125;); &#125;);&#125;); 重新启动测试，效果如下图： 总结安装环境是一项具有挑战性的工作。它能够考验自己对工具掌握及理解的情况。如果我们在安装环境中碰到了问题，要尝试着去翻译各种提示的英文文字，然后借助google去找到问题的原因及解决方案。 注：安装顺利.","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.mengyunzhi.cn/tags/AngularJS/"},{"name":"protracto","slug":"protracto","permalink":"http://www.mengyunzhi.cn/tags/protracto/"}]},{"title":"php + xdebug + phpstrom断点调试","slug":"php-xdebug-phpstorm","date":"2017-09-18T07:57:43.000Z","updated":"2017-12-29T06:58:04.812Z","comments":true,"path":"2017/09/18/php-xdebug-phpstorm/","link":"","permalink":"http://www.mengyunzhi.cn/2017/09/18/php-xdebug-phpstorm/","excerpt":"我们说sublime和xdebug调试php程序的时候数组变量有的时候不能显示完全，所以就给我们调试程序带来了不方便，如果使用var_dump又太浪费时间（可能是因为本人技术水平不佳）。","text":"我们说sublime和xdebug调试php程序的时候数组变量有的时候不能显示完全，所以就给我们调试程序带来了不方便，如果使用var_dump又太浪费时间（可能是因为本人技术水平不佳）。 环境: Ubuntu16.04, lampp, phpStorm download xdebug我们可以新建一个php文件，然后写上:1phpinfo(); 来查看自己安装php的具体信息，以方便我们找到合适自己的xdebug 然后我们打开网址https://xdebug.org/wizard.php Ctrl + A全选将自己的php信息输入到空白页面。点击Analyse my phpinfo() output 然后xdebug官网就会推荐合适xdebug版本而且给出详尽的安装步骤。 install xdebug下面的步骤因为个人安装路径的不同而不同，不用担心，因为xdebug官网分析的已经非常到位了，只要能简单读懂英语相信都可以安装成功。 解压文件123sudo tar -xvzf xdebug-2.5.4.tgzcd xdebug-2.5.4/phpize 然后我们会发现提示以下错误: 12程序“phpize”尚未安装。 您可以使用以下命令安装：sudo apt install php7.0-dev install php7.0-dev我们安装提示继续进行: 12345sudo apt install php7.0-devsudo phpizesudo ./configuresudo makesudo cp modules/xdebug.so /opt/lampp/lib/php/extensions/no-debug-non-zts-20151012 编辑php.ini1sudo gedit /opt/lampp/etc/php.ini 最后一行添加: 1234567zend_extension = /opt/lampp/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so//调试信息代码使用xdebug.remote_host = 127.0.0.1xdebug.remote_enable = 1xdebug.remote_port = 9000xdebug.remote_handler = dbgpxdebug.remote_mode = req 重启服务1sudo /opt/lampp/lampp restart 然后我们重复第一步查看自己的php信息发现xdebug安装成功 install Xdebug extension helpergoogle chrome插件安装地址https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc?hl=en 因为google被墙了，如果想要安装所以请自行在github or 老D上下载hosts。 IDEKey在Xdebug extension helper的选项 中 IDE key 中选择phpStorm。 开启Xdebug extension helper调试模式 配置PhpStorm然后我们打开phpStorm中Run , Start Listening for PHP Debug Connections.然后我们就可以调试了: 参考文献[PHP+xdebug] 在Ubuntu 14.04下的PhpStorm中配置xdebug调试环境Zero-configuration Web Application Debugging with Xdebug and PhpStorm","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[{"name":"php","slug":"php","permalink":"http://www.mengyunzhi.cn/tags/php/"}]},{"title":"两个sql.Date日期相减的方法","slug":"how-to-sub-two-sql-date","date":"2017-08-23T05:43:54.000Z","updated":"2017-12-29T06:58:04.812Z","comments":true,"path":"2017/08/23/how-to-sub-two-sql-date/","link":"","permalink":"http://www.mengyunzhi.cn/2017/08/23/how-to-sub-two-sql-date/","excerpt":"","text":"","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.mengyunzhi.cn/tags/java/"}]},{"title":"如何给某个java.sql.Date加上固定的天数","slug":"how-to-add-days-to-java-sql-date","date":"2017-08-23T03:34:39.000Z","updated":"2017-12-29T06:58:04.812Z","comments":true,"path":"2017/08/23/how-to-add-days-to-java-sql-date/","link":"","permalink":"http://www.mengyunzhi.cn/2017/08/23/how-to-add-days-to-java-sql-date/","excerpt":"在计量项目中，碰到了如下问题：\n\n计量器具设置了上次的检定日期。\n计量器具设置了检定周期（天）\n\n我们想得到：计量器具下次应该去进行检定的时间。\n算法：上次的检定日期 + 检定周期 = 下次应该检定的日期。","text":"在计量项目中，碰到了如下问题： 计量器具设置了上次的检定日期。 计量器具设置了检定周期（天） 我们想得到：计量器具下次应该去进行检定的时间。 算法：上次的检定日期 + 检定周期 = 下次应该检定的日期。 那么，在JAVA中，是如何做到在一个日期类型上加入固定的天数呢？这里我们需要用到借助Calendar类中的add方法来实现。123456789101112131415class Test &#123; /** * java.sql.Date加上固定的天数 * @param &#123;java.sql.Date&#125; java.sql.Data date 原始日期 * @param &#123;int&#125; int days 加上的天数 * @author 梦云智 http://www.mengyunzhi.com * @DateTime 2017-09-19T14:56:25+0800 */ public java.sql.Date addDate(java.sql.Data date, int days) &#123; java.util.Calendar calendar = java.util.Calendar.getInstance(); // 实例化 calendar.setTime(date); // 设置日期 calendar.add(calendar.DATE, days); // 与 天数 相加 return new java.sql.Date(calendar.getTimeInMillis()); // 使用calendar.getTimeInMillis()实例化java.sql.Date &#125;&#125;","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.mengyunzhi.cn/tags/java/"},{"name":"sql.Date","slug":"sql-Date","permalink":"http://www.mengyunzhi.cn/tags/sql-Date/"}]},{"title":"学入学习JPA的@ManyToMany注解 study jpa @ManyToMany deeply","slug":"study-jpa-ManyToMany-deeply","date":"2017-08-09T09:40:29.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/08/09/study-jpa-ManyToMany-deeply/","link":"","permalink":"http://www.mengyunzhi.cn/2017/08/09/study-jpa-ManyToMany-deeply/","excerpt":"在JPA中，实间的关系属@ManyToMany最难理解，使用起来最为复杂。当存在某个实体的关键字由多个属性组成时，复杂程序就更大了。借此， 我们以以下ER图为例，对@ManyToMany进行一次深入学习。\nER图如下：","text":"在JPA中，实间的关系属@ManyToMany最难理解，使用起来最为复杂。当存在某个实体的关键字由多个属性组成时，复杂程序就更大了。借此， 我们以以下ER图为例，对@ManyToMany进行一次深入学习。 ER图如下： 基础代码标准装置实体普通的实体，代码如下：12345678 */@Entity @ApiModel(value = \"DeviceSet (计量标准装置)\", description = \"计量标准装置实体\")public class DeviceSet implements Serializable&#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; // setter/getter&#125; 授权检定项目实体该实体的主键由两个外键组成(如何使用组合键，并不属于本文的讨论范围)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Entity@Immutable@ApiModel(value = \"DeviceInstrument (装置授权检定项目)\", description = \"装置授权检定项目实体\")public class DeviceInstrument &#123; @Embeddable public static class Id implements Serializable &#123; //封装组合健 @Column(name = \"accuracy_id\", nullable = false, insertable = false, updatable = false) private Long accuracyId; @Column(name = \"measure_scale_id\", nullable = false, insertable = false, updatable = false) private Long measureScaleId; public Id() &#123; &#125; public Id(Long accuracyId, Long measureScaleId) &#123; this.accuracyId = accuracyId; this.measureScaleId = measureScaleId; &#125; public Long getMeasureScaleId() &#123; return measureScaleId; &#125; public void setMeasureScaleId(Long measureScaleId) &#123; this.measureScaleId = measureScaleId; &#125; public Long getAccuracyId() &#123; return accuracyId; &#125; public void setAccuracyId(Long accuracyId) &#123; this.accuracyId = accuracyId; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Id)) return false; Id id = (Id) o; if (!measureScaleId.equals(id.measureScaleId)) return false; return accuracyId.equals(id.accuracyId); &#125; @Override public int hashCode() &#123; int result = measureScaleId.hashCode(); result = 31 * result + accuracyId.hashCode(); return result; &#125; &#125; @EmbeddedId //映射组合建 private Id id = new Id(); @ManyToOne @ApiModelProperty(\"对应的测量范围\") //关联测量范围 @JoinColumn(insertable = false, updatable = false) private MeasureScale measureScale; @ManyToOne @ApiModelProperty(\"对应的精度\") //关联精度 @JoinColumn(insertable = false, updatable = false) private Accuracy accuracy; // 其它set/get代码省略，下同&#125; 默认@ManyToMany标准装置实体我们在该实体中加入多对多的字段，查看其为我们生成的默认字段：12345678@Entity @ApiModel(value = \"DeviceSet (计量标准装置)\", description = \"计量标准装置实体\")public class DeviceSet implements Serializable&#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @ManyToMany @ApiModelProperty(\"对应的装置授权检定项目\") private Set&lt;DeviceInstrument&gt; deviceInstruments = new HashSet&lt;DeviceInstrument&gt;(); 进行单元测试： 最终，我们得出以下结论： 当一个普通实体与另一个组合主键实体进行多对多关联系时: 为了保存多对多关系，JPA为我们自动创建一个中间表。表名为：本表名_关联表名s 此表为我们生成了三个字段，三个字段均为主键。 其中一个主键与 普通实体 主键相关联，命名为：表名_主键名 另两个主键组合在一起，与 组合主键实体 的组合主键相关联。命名为：表名s_主键名 授权检定项目实体同样，我们加入默认的多对多注解，不做任何设置 12345678910111213141516171819202122232425@Entity@Immutable@ApiModel(value = \"DeviceInstrument (装置授权检定项目)\", description = \"装置授权检定项目实体\")public class DeviceInstrument &#123; //参考网址http://codego.net/144328/ @EmbeddedId //映射组合建 private Id id = new Id(); @ManyToOne @ApiModelProperty(\"对应的测量范围\") //关联测量范围 @JoinColumn(insertable = false, updatable = false) private MeasureScale measureScale; @ManyToOne @ApiModelProperty(\"对应的精度\") //关联精度 @JoinColumn(insertable = false, updatable = false) private Accuracy accuracy; @ManyToMany private Set&lt;DeviceSet&gt; deviceSets;&#125; 同样，任意进行单元测试，重新生成数据表： 最终，我们得出以下结论： 当一个组合主键实体与另一个普通实体进行多对多关联系时: 为了保存多对多关系，JPA为我们自动创建一个中间表。表名为：本表名_关联表名s 此表为我们生成了三个字段，三个字段均为主键 其中一个主键与 普通实体 主键相关联，命名为：表名s_主键名 另两个主键组合在一起，与 组合主键实体 的组合主键相关联。命名为：表名_主键名 我们将以上规律进行总结后不难得出： 为了保存多对多关系，JPA为我们自动创建一个中间表。表名为：本表名_关联表名s 此表为我们生成了三个字段，三个字段均为主键 其中一组主键（可能是一个，也可以是多个）与本实体主键相关联，命名为：表名_主键名0, 表名_主键名1 另一组主键(可能是一个，也可以是多个)关联实体相关联，命名为：关联实体表名s_主键名0, 关联实体表名s_主键名1 自定义多对多两个@ManyToMany虽然已经生效，但是却生成了两张数据表，而且这两张表对应的字段也不一样，那么如何使用一个数据表来存储两个实体的@ManyToMany关系呢？ 统一字段两个表合一的前提是字段名统一，由于上述第4点原因，导致关联实体的字段名中有个多余的s，下面，我们使用注解来自定义自段名称. 标准装置实体1234567891011public class DeviceSet implements Serializable&#123; @ManyToMany @ApiModelProperty(\"对应的装置授权检定项目\") @JoinTable( joinColumns = &#123;@JoinColumn(name = \"device_set_id\", referencedColumnName = \"id\")&#125; inverseJoinColumns = &#123; @JoinColumn(name = \"accuracy_id\", referencedColumnName = \"accuracy_id\"), @JoinColumn(name = \"measure_scale_id\", referencedColumnName = \"measure_scale_id\") &#125; ) private Set&lt;DeviceInstrument&gt; deviceInstruments = new HashSet&lt;DeviceInstrument&gt;(); @JoinTable有两个(不止这两个)重要的属性：joinColumns(关联列）和inverseJoinColumns(反关联列), 在这里，它们的主体都是系统为我们生成的中间表。joinColumns = {@JoinColumn(name = &quot;device_set_id&quot;, referencedColumnName = &quot;id&quot;)}译为：关联列属性：本表（系统生成的中间表）中的device_set_id关联当前实体的id字段。 1234inverseJoinColumns = &#123; @JoinColumn(name = \"accuracy_id\", referencedColumnName = \"accuracy_id\"), @JoinColumn(name = \"measure_scale_id\", referencedColumnName = \"measure_scale_id\")&#125; 译为： 反（上面自动关系的当前实体，这个“反”字，代表关联ToMany的另一个实体）关联列属性： 1. 本表（系统生成的中间表）中的accuracy_id字段，关联另一个实体的accuracy_id字段; 2. 本表（系统生成的中间表）中的measure_scale_id字段，关联另一个实体（授权检定项目）的measure_scale_id字段; 我们启动单元测试： 授权检定项目实体有了前面的经验，下面就很简单了：123456789public class DeviceInstrument &#123; @ManyToMany @JoinTable( joinColumns = &#123; @JoinColumn(name = \"accuracy_id\", referencedColumnName = \"accuracy_id\"), @JoinColumn(name = \"measure_scale_id\", referencedColumnName = \"measure_scale_id\"), &#125;, inverseJoinColumns = &#123;@JoinColumn(name = \"device_set_id\", referencedColumnName = \"id\")&#125;) private Set&lt;DeviceSet&gt; deviceSets; 同样，我们翻译一下：joinColumns: 中间表字段关联属性：1. 本中间表的accuracy_id对应当前实体的accuracy_id; 2.本中间表的measure_scale_id对应当前实体的measure_scale_idinverseJoinColumns: 中间表字段关联对方实体属性: 1. 本中间表的device_set_id字段，对应对方实体(标准装置)id字段。 单元测试略 统一表名最后，我们统一使用@JoinTable的name属性，来统一表名，将以前系统合并的两张表，用一张表来表示： 123456789@ManyToMany@JoinTable( name = \"device_set_device_instruments\", joinColumns = &#123; @JoinColumn(name = \"accuracy_id\", referencedColumnName = \"accuracy_id\"), @JoinColumn(name = \"measure_scale_id\", referencedColumnName = \"measure_scale_id\"), &#125;, inverseJoinColumns = &#123;@JoinColumn(name = \"device_set_id\", referencedColumnName = \"id\")&#125;)private Set&lt;DeviceSet&gt; deviceSets; 1234567891011@ManyToMany@ApiModelProperty(\"对应的装置授权检定项目\")@JoinTable( name = \"device_set_device_instruments\", joinColumns = &#123;@JoinColumn(name = \"device_set_id\", referencedColumnName = \"id\")&#125;, inverseJoinColumns = &#123; @JoinColumn(name = \"accuracy_id\", referencedColumnName = \"accuracy_id\"), @JoinColumn(name = \"measure_scale_id\", referencedColumnName = \"measure_scale_id\") &#125;)private Set&lt;DeviceInstrument&gt; deviceInstruments = new HashSet&lt;DeviceInstrument&gt;(); 总结：一直在多对多的问题上一知半解，使用的注解大多也来源于课本和网络。但最终掌握该问题最好最快最牢的方法仍然是“实战”。没错，通过半小时的实战，我们一点点的用代码测试出了@JoinTable的几个核心注解的功能。当以后再出现多对多注解时，我们知道：1.当前注解的对象为：中间表。2.关联的字段与反关联的字段，分别是指当前实体与对方实体。3.关联的表名，字段名都可以自定义。4.关联的字段，本来就是一个数组{}，这个数组中可以有一个参数，也可以有多个参数。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"jpa","slug":"jpa","permalink":"http://www.mengyunzhi.cn/tags/jpa/"},{"name":"@ManyToMany","slug":"ManyToMany","permalink":"http://www.mengyunzhi.cn/tags/ManyToMany/"}]},{"title":"解决使用spring boot mvc的@JsonView注解返回page为空的问题","slug":"spring-boot-mvc-JsonView-page-emtpy-object","date":"2017-07-30T03:43:02.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/30/spring-boot-mvc-JsonView-page-emtpy-object/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/30/spring-boot-mvc-JsonView-page-emtpy-object/","excerpt":"要spring mvc中，我们使用@JsonView注解来定义内容输出。但如果我们返回分页数据Page的话，却意外的行到了{}。这是由于@JsonView注解并没有在Page类型上起作用。所以导致返回类型为Page时，输出空内容。","text":"要spring mvc中，我们使用@JsonView注解来定义内容输出。但如果我们返回分页数据Page的话，却意外的行到了{}。这是由于@JsonView注解并没有在Page类型上起作用。所以导致返回类型为Page时，输出空内容。 解决方案针对此问题，网上的解决方案并不统一。最后，找到如下解决方案: 即对WebMvcConfigurerAdapter进行配置。重写public void configureMessageConverters方法。 1234567891011121314151617181920212223242526272829303132@EnableWebMvcpublic class WebConfig extends WebMvcConfigurerAdapter &#123; static private Logger logger = Logger.getLogger(WebConfig.class.getName()); /** * 解决spring mvc @jsonview page empty(springMvc 使用jsonView时，返回page信息为空对象)的问题 * 这个问题的解决方案适用的比较少，而且还有信息存在误导。 * 最后总结下解决方法： * 1.绝对不能在配置文件中去配置那个 DEFAULT_VIEW_INCLUSION。 * 如果这么做了，就会发现C层配置的JsonView会完全失去作用 * 2. 本问题中，spring 官方社区的回答比stackoverflow 还要靠谱。 * 在 https://jira.spring.io/browse/SPR-13331 的回答中，甚至有了给出了github的地址 * 3. 参考代码时，要使其它的配置完全相同，比如我在参考时，就是在已经设置了DEFAULT_VIEW_INCLUSION为true的前提下； * 而这个配置项，参考代码中并没有。进而没有在第一时间内验证出参考代码的正确性。 * 正确的可被参考的代码：https://github.com/sdeleuze/SpringSampleProject * * 总结：问题解决了大概两天的时间。开始低估了问题了难度，当发现初步找的答案并不能解决实际问题时。 * 并没有沉下心来去看每一篇google到的文章。 * 最后，静心的仔细的学习了每一篇文章，并找到了相关的示例代码，同时删除了按照其它方法配置的不适用配置项后。 * 问题得以解决。 * 所以： * 1. 当发现低估问题的难度的时候，确诊关键字没有问题，就要静心来学习。 * 2. 每找到一个方法，都值得一试。但不要将两种解决方案同时试。试第一种不行，就要将代码进行恢复。 * 然后才能继续试第二种。 * 3. 读懂找到资料的每一行英文，这很重要！ * @param converters */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; ObjectMapper mapper = Jackson2ObjectMapperBuilder.json().defaultViewInclusion(true).build(); converters.add(new MappingJackson2HttpMessageConverter(mapper)); &#125;&#125; 使用方法在使用时，我们可以直接使用@JsonView在控制器上，如果我们未设置实体中的注解信息，则会发现什么变化都没有发生。如果我们想排除某此字段，则需要如下使用： 假设我们有以下实体：1234567// 学生class Student &#123; private String name; private boolean sex; @ManyToOne private Klass klass; // 班级&#125; 123456// 班级Class Klass &#123; private String name; @OneToMany(mappedBy = \"klass\") private Set&lt;Student&gt; students = new HashSet&lt;&gt;(); &#125; 场景一在输出学生时，输出班级信息，同时忽略班级中的students控制器如下：12345678@RestController@RequestMapping(\"/Student\")Class StudentController &#123; @GetMapping(/&#123;id&#125;) public Student get(@PathVar....) &#123; .... &#125;&#125; 建立一个接口，并用这个接口注解@ManyToOne, @OneToMany.1interface NoneJsonView &#123;&#125; 加入注解，只有在控制器中使用NoneJsonView时，才会被序列化.12345678// 学生class Student &#123; private String name; private boolean sex; @ManyToOne @JsonView(NoneJsonView.class) private Klass klass; // 班级&#125; 1234567// 班级Class Klass &#123; private String name; @OneToMany(mappedBy = \"klass\") @JsonView(NoneJsonView.class) private Set&lt;Student&gt; students = new HashSet&lt;&gt;(); &#125; 在建立一个接口，用以输出指定字段1interface StudentGet &#123;&#125; 由于我们想输出学生的班级信息，所以将注解加入到学生的班级字段上。 12345678// 学生class Student &#123; private String name; private boolean sex; @ManyToOne @JsonView(&#123;NoneJsonView.class, StudentGet.class&#125;) private Klass klass; // 班级&#125; 在控制器上加入注解123456789@RestController@RequestMapping(\"/Student\")Class StudentController &#123; @GetMapping(/&#123;id&#125;) @JsonView(StudentGet.class) public Student get(@PathVar....) &#123; .... &#125;&#125; 我们在控制器上使用的注解为@JsonView(StudentGet.class)表示：只有未加注解或是加了注解并且对应@JsonView(StudentGet.class)的字段，才会被序列化。由于Stuent的全部字段都符合上述的规则，所以全部会被序列化。而Klass中的stuents字段，由于加入了@JsonView(NoneJsonView.class)，但该注解并不对应@JsonView(StudentGet.class), 所以将不被序列化。 目标实现 场景二输出某个班级时，对应输出其班级上所有的学生，但自动忽略学生上的班级信息。 12345678@RestController@RequestMapping(\"/Klass\")Class KlassController &#123; @GetMapping(/&#123;id&#125;) public Klass get(@PathVar....) &#123; .... &#125;&#125; 新建注解，并且作用于班级的students中.1interface KlassGet&#123;&#125; 1234567// 班级Class Klass &#123; private String name; @OneToMany(mappedBy = \"klass\") @JsonView(&#123;NoneJsonView.class, KlassGet.calss&#125;) private Set&lt;Student&gt; students = new HashSet&lt;&gt;(); &#125; 在控制器上加入注解123456789@RestController@RequestMapping(\"/Klass\")Class KlassController &#123; @GetMapping(/&#123;id&#125;) @JsonView(KlassGet.calss) public Klass get(@PathVar....) &#123; .... &#125;&#125; 此时，由于Student的klass字段，拥有注解。并且拥有的注解，不包含@JsonView(KlassGet.calss)，所以在序列化时，将被自动省略. 深入理解加入上述配置前，使用@JsonView注解时，如果字段并未设置@JsonView注解。那么则默认 不进行 序列化。加入上述配置后，我个人的理解是：如果字段并未设置@JsonView注解。那么则默认 进行 序列化。加入配置的前后，对于加入@JsonView注解的字段，判断方法相同：符合，则序列化；不符合，不序列化。 这样，使用上述方法便解释了为什么加入配置后，Page类型便得以全部输出了。这时由于Page并没有加入@JsonView，所以会全部自动序列化。 在实际的使用过程中，这种思想（只有加了@JsonView才可能不被序列化 ）结合@JsonView的使用，大幅的缩减注解代码量。 总结：我们将@JsonView注解的默认规则由：只有加入了注解才可能 被 序列化修改为:-&gt; 只有加入了注解才可能 不被 序列化。修改默认规则前：Page并没有加入@JsonView注解，默认忽略。修改默认规则后：Page并没有加入@JsonView注解，默认自动转换。同时，也解决了使用@JsonView注解时，需要大量加入注解代码的尴尬。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.mengyunzhi.cn/tags/spring-mvc/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://www.mengyunzhi.cn/tags/spring-boot/"},{"name":"@JsonView","slug":"JsonView","permalink":"http://www.mengyunzhi.cn/tags/JsonView/"}]},{"title":"在angularJs中进行json数据的格式化","slug":"format-json-data-in-angularjs","date":"2017-07-17T01:38:49.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/17/format-json-data-in-angularjs/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/17/format-json-data-in-angularjs/","excerpt":"我们在angularJs的项目中，常常需要对json进行显式的查看，以便更清晰的了解到json数据内部结构与数值变化。本文将介绍一种非常不错的方法，来协助你查看前台绑定的json数据。","text":"我们在angularJs的项目中，常常需要对json进行显式的查看，以便更清晰的了解到json数据内部结构与数值变化。本文将介绍一种非常不错的方法，来协助你查看前台绑定的json数据。 格式化以前比如：我们在v层中加入以下代码1&#123;&#123;data&#125;&#125; 刷新前台，对应输出格式为:1&#123;\"id\":1,\"name\":\"区县级器具用户\",\"createTime\":null,\"updateTime\":null,\"preWorkflowNode\":null,\"createUser\":null,\"districtType\":&#123;\"id\":3,\"name\":\"区\\\\县\",\"pinyin\":\"quxian\",\"createUser\":null&#125;,\"workflowType\":&#123;\"id\":1,\"name\":\"适用于器具用户新强检器具审批\",\"pinyin\":null,\"createTime\":null,\"updateTime\":null,\"description\":\"1.向上级管理部门提出申请；2.管理部门可以转给同区域或子区域的技术机构。3.技术机构可办结可返回给管理部门\",\"createUser\":null&#125;,\"departmentType\":&#123;\"id\":2,\"name\":\"器具用户\",\"pinyin\":\"qijuyonghu\",\"createTime\":0,\"updateTime\":0,\"createUser\":null&#125;,\"containSonDistrict\":false&#125; 即使是浏览器为我们启用了自动换行，对于想查看json结构的我们，也是一件非常困难的事，这时候，我们需要结合&lt;pre&gt;与json过滤器来共同的定制该显示格式： 格式化以后1&lt;pre&gt;&#123;&#123;data | json&#125;&#125;&lt;/pre&gt; 我们将得到如下格式的json数据1234567891011121314151617181920212223242526272829303132&#123; \"id\": 1, \"name\": \"区县级器具用户\", \"createTime\": null, \"updateTime\": null, \"preWorkflowNode\": null, \"createUser\": null, \"districtType\": &#123; \"id\": 3, \"name\": \"区\\\\县\", \"pinyin\": \"quxian\", \"createUser\": null &#125;, \"workflowType\": &#123; \"id\": 1, \"name\": \"适用于器具用户新强检器具审批\", \"pinyin\": null, \"createTime\": null, \"updateTime\": null, \"description\": \"1.向上级管理部门提出申请；2.管理部门可以转给同区域或子区域的技术机构。3.技术机构可办结可返回给管理部门\", \"createUser\": null &#125;, \"departmentType\": &#123; \"id\": 2, \"name\": \"器具用户\", \"pinyin\": \"qijuyonghu\", \"createTime\": 0, \"updateTime\": 0, \"createUser\": null &#125;, \"containSonDistrict\": false&#125; 如果你习惯了用4个空格来代替缩进，那么你还可以这样：1&lt;pre&gt;&#123;&#123;data | json : 4&#125;&#125;&lt;/pre&gt; 刷新页面：1234567891011121314151617181920212223242526272829303132&#123; \"id\": 1, \"name\": \"区县级器具用户\", \"createTime\": null, \"updateTime\": null, \"preWorkflowNode\": null, \"createUser\": null, \"districtType\": &#123; \"id\": 3, \"name\": \"区\\\\县\", \"pinyin\": \"quxian\", \"createUser\": null &#125;, \"workflowType\": &#123; \"id\": 1, \"name\": \"适用于器具用户新强检器具审批\", \"pinyin\": null, \"createTime\": null, \"updateTime\": null, \"description\": \"1.向上级管理部门提出申请；2.管理部门可以转给同区域或子区域的技术机构。3.技术机构可办结可返回给管理部门\", \"createUser\": null &#125;, \"departmentType\": &#123; \"id\": 2, \"name\": \"器具用户\", \"pinyin\": \"qijuyonghu\", \"createTime\": 0, \"updateTime\": 0, \"createUser\": null &#125;, \"containSonDistrict\": false&#125; 赶快试试吧。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"angularJs","slug":"angularJs","permalink":"http://www.mengyunzhi.cn/tags/angularJs/"},{"name":"josn","slug":"josn","permalink":"http://www.mengyunzhi.cn/tags/josn/"},{"name":"format","slug":"format","permalink":"http://www.mengyunzhi.cn/tags/format/"}]},{"title":"spring中如何用注解实现多个类自动装配同一个接口","slug":"spring-qualifier","date":"2017-07-15T03:32:13.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/15/spring-qualifier/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/15/spring-qualifier/","excerpt":"转载出处 ：Spring的注解@Qualifier小结 ","text":"转载出处 ：Spring的注解@Qualifier小结 Example有如下接口： 123public interface EmployeeService &#123; public EmployeeDto getEmployeeById(Long id);&#125; 同时有下述两个实现类 EmployeeServiceImpl和EmployeeServiceImpl1： 12345678910111213@Service(&quot;service&quot;)public class EmployeeServiceImpl implements EmployeeService &#123; public EmployeeDto getEmployeeById(Long id) &#123; return new EmployeeDto(); &#125;&#125;@Service(&quot;service1&quot;)public class EmployeeServiceImpl1 implements EmployeeService &#123; public EmployeeDto getEmployeeById(Long id) &#123; return new EmployeeDto(); &#125;&#125; 调用代码如下：123456789101112@Controller@RequestMapping(&quot;/emplayee.do&quot;)public class EmployeeInfoControl &#123; @Autowired EmployeeService employeeService; @RequestMapping(params = &quot;method=showEmplayeeInfo&quot;) public void showEmplayeeInfo(HttpServletRequest request, HttpServletResponse response, EmployeeDto dto) &#123; #略 &#125;&#125; Error1org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;employeeInfoControl&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.test.service.EmployeeService com.test.controller.EmployeeInfoControl.employeeService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.test.service.EmployeeService] is defined: expected single matching bean but found 2: [service1, service2] analysis其实报错信息已经说得很明确了,在autoware时，由于有两个类实现了EmployeeService接口，所以Spring不知道应该绑定哪个实现类，所以抛出了如上错误。 Solve用到@Qualifier注解了，qualifier的意思是合格者，通过这个标示，表明了哪个实现类才是我们所需要的，我们修改调用代码，添加@Qualifier注解，需要注意的是@Qualifier的参数名称必须为我们之前定义@Service注解的名称之一 12345678910111213@Controller@RequestMapping(&quot;/emplayee.do&quot;)public class EmployeeInfoControl &#123; @Autowired @Qualifier(&quot;service&quot;) EmployeeService employeeService; @RequestMapping(params = &quot;method=showEmplayeeInfo&quot;) public void showEmplayeeInfo(HttpServletRequest request, HttpServletResponse response, EmployeeDto dto) &#123; #略 &#125;&#125;","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.mengyunzhi.cn/tags/spring/"}]},{"title":"mvn package命令","slug":"mvn-package","date":"2017-07-08T09:25:39.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/08/mvn-package/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/08/mvn-package/","excerpt":"maven是托管java项目的一个很好用的工具。但是对于初学java的我来说，也踩到了许多坑。简单说一下我在打包的时候遇到的问题。","text":"maven是托管java项目的一个很好用的工具。但是对于初学java的我来说，也踩到了许多坑。简单说一下我在打包的时候遇到的问题。 Find question当时我执行mvn package之后就发现测试文件好多都报错了。 然后，我们一点儿一点儿着错误就会发现有报错信息 1A Foreign key refering com.mengyunzhi.measurement.repository.ApplyType from com.mengyunzhi.measurement.repository.WorkflowTypeApplyType has the wrong number of column. should be 3 Analysis question分析这句话就会发现值WorkflowTypeApplyType这张表里的外健约束from ApplyType有问题。 这个可能是因为我们开发的时候往往是在自己的分支上开发，但是一些简单组件的测试是由开发人员自己做的，我们进行unit test的时候已经编译了改动的文件。但是切到development分支的时候进行mvn package,然后过程如下： 虽然我们进行了编译，但是可能会留下曾经编译过的字节码文件(.class)。所以我们可以rebuild project, 将所有的编译文件clean然后全部重新编译。 Solve question删除数据库，新建数据库。在linux, IDEA开发环境下 Build -&gt; Rebuild Project， 然后再执行mvn package New question不会报错了之后，当我们进行打包的时候就会发现一个问题。我的电脑总是卡在这句话上 1HHH000227: Running hbm2ddl schema export 这句话表示hibernate按照持久化类和映射文件自动生成数据库架构, 把DDL脚本输出到标准输出，同时/或者执行DDL语句。 应为在mvn package中我们可能会有多次这条语句，然后我们怎么解决这个慢的问题呢？ 设置 spring.jpa.hibernate.ddl-auto=create 随便执行一个单元测试应该也可以,当执行过 12org.hibernate.tool.hbm2ddl.SchemaExport : HHH000227: Running hbm2ddl schema export 2017-07-07 09:18:35.672 INFO 7652 --- [ main] org.hibernate.tool.hbm2ddl.SchemaExport : HHH000230: Schema export complete 说明数据表已经创建成功, 即可终止单元测试 修改：spring.jpa.hibernate.ddl-auto=none,禁用禁用ddl-auto 执行mvn test或者mvn package 然后就会解决这个建立数据库结构慢的问题了。 总结我们总会遇到各种各样的问题，当我们有了一定的知识积累之后，我们就需要对遇到的问题一点点儿分析。不怕慢，就怕我们自己对未知事务的恐惧会阻挡我们前进。当然了，对于问题，我们最好先猜测一个原因再去百度问题的解决方法，因为过多的依赖百度会让我们停止对问题的思考。 参考文章陈鋆: Maven 各命令执行流程解析和说明[Nhibernate]SchemaExport工具的使用（一）通过映射文件修改数据表","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://www.mengyunzhi.cn/tags/maven/"}]},{"title":"hibernate级联操作","slug":"cascade","date":"2017-07-06T03:13:33.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/06/cascade/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/06/cascade/","excerpt":"当我们处理实体之间关系的时候，很可能会涉及到一个实体发生改变的时候它所关联的实体也会发生改变，这就是我们所说的级联操作。当然，hibernate已经给我们设计好了我们所要用的简单的级联操作。详细的代码见 参考文章 的链接","text":"当我们处理实体之间关系的时候，很可能会涉及到一个实体发生改变的时候它所关联的实体也会发生改变，这就是我们所说的级联操作。当然，hibernate已经给我们设计好了我们所要用的简单的级联操作。详细的代码见 参考文章 的链接 级联保存关联关系中比较常用：@OneToMany, @ManyToMany, @OneToOne对于级联保存而言，是最基本的级联关系，估计也是我们最常用的关系。也就是保存本实体的时候，它所关联的实体也会自动保存。级联保存操作为CascadeType.PERSIST 级联更新关联关系中比较常用：所有实体关系都适用对于更新，当然也是我们最常见的情况。我们说级联更新基本上适用于所有的情况。但是对于@OneToMany的情况下，我们可能需要结合下面所讲到的孤立移除才能够完善。级联更新操作为CascadeType.MERGE 级联删除关联关系中比较常用：@OneToMany， @OneToOne我们可以这样想，当一个商品可以有多个价格，但是当我们从数据库中删除这个商品的时候，我们说这个商品所对应的价格也就没有任何意义了。所以要删除一个商品的正确顺序是先删除这个商品对应的价格然后删除这个商品，如果不这样的话删除商品的时候会被外健约束从而删除商品失败。而hibernate对应的就是级联删除则是CascadeType.REMOVE 孤立移除适用于：@OneToMany， @ManyToMany例如：我们在器具类别实体中关联着多个规格型号，例如有规格型号1,规格型号2.这时我们更新的时候想要删除规格型号1,这时候我们就需要orphanRemoval = true来实现孤立移除,这样就可以孤立的删除规格型号1.具体代码如下：1234567891011121314151617181920212223/** * 器具类别 实体 */@Entity@ApiModel(value = &quot;InstrumentType (器具类别)&quot;, description = &quot;器具类别实体&quot;)public class InstrumentType implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @ApiModelProperty(&quot;名称&quot;) @Column(nullable = false) private String name; @Column(nullable = false) @ApiModelProperty(&quot;拼音&quot;) private String pinyin; @Lazy //参照hibernate实战第七章第三节级联状态 @OneToMany(mappedBy = &quot;instrumentType&quot;, cascade = &#123;CascadeType.PERSIST, CascadeType.REMOVE, CascadeType.MERGE&#125;, orphanRemoval = true) @ApiModelProperty(&quot;oneToMany 规格型号&quot;) private List&lt;Specification&gt; specifications = new ArrayList&lt;&gt;(); // getter and setter ....&#125; 参考文章hibernate第七章第三节级联状态Hibernate@ManyToMany总结","raw":null,"content":null,"categories":[{"name":"gaoliming","slug":"gaoliming","permalink":"http://www.mengyunzhi.cn/categories/gaoliming/"}],"tags":[{"name":"cascade","slug":"cascade","permalink":"http://www.mengyunzhi.cn/tags/cascade/"},{"name":"hibernate","slug":"hibernate","permalink":"http://www.mengyunzhi.cn/tags/hibernate/"}]},{"title":"如何重启服务器(freebsd系统)上的JAVA应用","slug":"how-to-restart-a-new-javaj-application","date":"2017-07-05T07:55:15.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/05/how-to-restart-a-new-javaj-application/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/05/how-to-restart-a-new-javaj-application/","excerpt":"本文将阐述如何在freebsd系统中，重启java应用程序.","text":"本文将阐述如何在freebsd系统中，重启java应用程序. 获取jar程序获取jar程序的方法有很多，比如我们可以在本地进行mvn package，或是可以直接下载gh-pages分支上的jar文件。 假设我们拥有以下jar文件：1api-0.0.5-SNAPSHOT.jar 登录服务器1$ ssh user@www.mengyunzhi.cn -p 1234 windows客户端，ssh命令端口参考可能不同，请使用$ ssh -help来查看自定义端口的参数。 其中user为用户名，www.mengyunzhi.cn为域名（也可以是IP地址）, 1234为端口号。回车后，提示我们输入密码。成功后，将显示以下欢迎信息：1234567Show the version of FreeBSD installed: freebsd-version ; uname -aPlease include that output and any error messages when posting questions.Introduction to manual pages: man manFreeBSD directory layout: man hierEdit /etc/motd to change this login announcement.$ 停止原应用123$ ps | grep java39297 0 R+ 0:00.00 grep java39049 2- R 0:58.06 /usr/local/openjdk8/bin/java -jar api-0.0.5-SNAPSHOT.jar --datasource.port=5678 我们得到pid号如39049，继而使用kill -9 pid结束原进程1$ kill -9 39049 操作后，可以继续使用ps | grep java来查看进程是否成功结束。 上传新应用利用sftp命令进行上传。我们在本机新打开一个命令行或bash窗口，然后输入： 12345$ cd 本地存放api-0.0.5-SNAPSHOT.jar文件的目录$ sftp -P 1234 user@www.mengyunzhi.cn$ 输入密码Connected to www.mengyunzhi.cn.sftp&gt; windows客户端请先执行sftp -help查看如何指定端口及用户名 执行上传命令比如我们服务器上的应用程序存放位置为：/mengyunzhi/api/8080.Measurement 首先进行服务器目标文件夹，然后执行put命令上传 12345sftp&gt; cd /mengyunzhi/api/8080.Measurementsftp&gt; put api-0.0.5-SNAPSHOT.jar Uploading api-0.0.5-SNAPSHOT.jar to /mengyunzhi/api/8080.Measurement/api-0.0.5-SNAPSHOT.jarapi-0.0.5-SNAPSHOT.jar 100% 40MB 2.9MB/s 00:14 sftp&gt; 传输完成，关闭当前窗口。 启动新应用我们切回到 停止原应用 的窗口，先进入程序所在目录，然后启动新程序。12$ cd /mengyunzhi/api/8080.Measurement$ java -jar api-0.0.5-SNAPSHOT.jar --datasource.port=6789 &amp; --datasource.port=6789指定数据库的端口。&amp;指定为后台运行，很重要！ 服务启动后，控制台将打印：122017-07-05 16:15:01.802 INFO 39339 --- [ main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-07-05 16:15:01.818 INFO 39339 --- [ main] c.mengyunzhi.measurement.ApiApplication : Started ApiApplication in 50.57 seconds (JVM running for 51.544)","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"freebsd","slug":"freebsd","permalink":"http://www.mengyunzhi.cn/tags/freebsd/"},{"name":"java application","slug":"java-application","permalink":"http://www.mengyunzhi.cn/tags/java-application/"}]},{"title":"如何实现分页（M层）","slug":"pageable","date":"2017-07-03T12:35:42.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/07/03/pageable/","link":"","permalink":"http://www.mengyunzhi.cn/2017/07/03/pageable/","excerpt":"今天学习了潘老师写的器具类别的分页，讲述一下对代码的理解。有不足之处，欢迎批评指正。\n将获取到的数据进行规定条数的分页继承PagingAndSortingRepository首先我们对获取到的所有的数据进行分页。我们应该知道，分页并不是CrudRepository里面自带的方法，所以我们需要引入。简单的方法是，我们可以在InstrumentTypeRepository中，将其进行对PagingAndSortingRepository的继承，然后在该类定义函数如下：\n1234public interface InstrumentTypeRepository extends PagingAndSortingRepository&lt;InstrumentType, Long&gt;&#123;&#125;","text":"今天学习了潘老师写的器具类别的分页，讲述一下对代码的理解。有不足之处，欢迎批评指正。 将获取到的数据进行规定条数的分页继承PagingAndSortingRepository首先我们对获取到的所有的数据进行分页。我们应该知道，分页并不是CrudRepository里面自带的方法，所以我们需要引入。简单的方法是，我们可以在InstrumentTypeRepository中，将其进行对PagingAndSortingRepository的继承，然后在该类定义函数如下： 1234public interface InstrumentTypeRepository extends PagingAndSortingRepository&lt;InstrumentType, Long&gt;&#123;&#125; M层直接调用方法这样，在InstrumentTypeServiceImpl类中就可以调用PagingAndSortingRepository中的分页方法了。下面是对分页数为20的代码的编写： 我们在InstrumentTypeServiceImpl中关于getAll的方法如下所示：123456public List&lt;InstrumentType&gt; getAll()&#123; List&lt;InstrumentType&gt; list = new ArrayList&lt;InstrumentType&gt;(); list = (List&lt;InstrumentType&gt;) instrumentTypeRepository.findAll(new PageRequest(page:1, size:20)); return list;&#125; 可是我们很轻易的就发现，这样写虽然很简单，但是不能动态的生成我们需要的分页数。假如我们想生成分页数为10的话，那么还得需要我们去手动的修改源代码。所以接下来我们看一看如何动态的生成分页的代码。 动态生成分页Repository中进行方法的定义同样的，我们还是以InstrumentType为例。示例方法为通过学科id获取对应的全部的器具类别信息并进行分页。但是这次我们像往常一样只需要继承CrudRepository。123public interface InstrumentTypeRepository extends CrudRepository&lt;InstrumentType, Long&gt;&#123; Page&lt;InstrumentType&gt; findAllByDisciplineId(Long id, Pageable pageable);&#125; 我们看到在该类下定义了函数findAllByDisciplineId，其中传入的参数为学科id，和pageable对象。pageable需要进行Pageable类的引入，同样的Page类也需要进行引入，代码如下：12import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable; 当然，如果我们用的IDEA编译器的话，它会自动提示我们去引入该包。 Pageable是Spring Data库中定义的一个接口，该接口是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关的所有信息，例如pageNumber、pageSize等。Pageable定义了很多方法，但是我们需要用到的信息只有两个，一个是分页的信息（page、size），一个是排序的信息。在springmc的请求中只需要在方法的参数中直接定义一个pageable类型的对象，当Spring发现这个参数时，Spring会自动根据request的参数来组装该pageable对象，Spring支持的request参数如下：123page，第几页，从0开始，默认为第0页 size，每一页的大小，默认为20 sort，排序相关的信息，以property,property(,ASC|DESC)的方式组织，例如sort=firstname&amp;sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列。 不太明白的一点是，findAllByDisciplineId这个方法名是自己起的，但是起名的格式该类下在有没有什么规定，才能实现通过学科id获取器具类别的信息。 Service层以及Service层的实现类然后再Service层我们定义分页的方法：1Page&lt;InstrumentType&gt; getAllByDisciplineId(Long id, Pageable pageable); 其中返回值为page类型的数组对象，传入值为学科id以及pageable对象。 ServiceImpl中,我们进行方法的实现：123456@Override public Page&lt;InstrumentType&gt; getAllByDisciplineId(Long id, Pageable pageable) &#123; Page&lt;InstrumentType&gt; page = instrumentTypeRepository.findAllByDisciplineId(id, pageable); return page; &#125; 在实现类中，我们将传入的pageable对象利用Repository类中定义的方法，返回值为类型为Page的数组对象。 Test类中的测试有了定义好的方法，下面我们对其进行测试。12345678910111213141516171819202122232425262728293031323334@Test public void page() &#123; // 新建学科实体，设置name、pinyin属性并保存 Discipline discipline = new Discipline(); discipline.setName(&quot;namesdfsdfdf&quot;); discipline.setPinyin(&quot;pinyin&quot;); disciplineRepository.save(discipline); // 新建器具类别实体，设置name、pinyin、学科类别属性并保存 InstrumentType instrumentType = new InstrumentType(); instrumentType.setName(&quot;name&quot;); instrumentType.setPinyin(&quot;pinyin&quot;); instrumentType.setDiscipline(discipline); instrumentTypeRepository.save(instrumentType); // 新建器具类别实体1，设置name、pinyin、学科类别属性并保存 InstrumentType instrumentType1 = new InstrumentType(); instrumentType1.setName(&quot;namesdfd&quot;); instrumentType1.setPinyin(&quot;pinyinsdfsdf&quot;); instrumentType1.setDiscipline(discipline); instrumentTypeRepository.save(instrumentType1); // 定义pageRequest对象，设置分页信息。从第一页开始显示，分页大小为1。 final PageRequest pageRequest = new PageRequest( page:1, size:1 ); Page&lt;InstrumentType&gt; page = instrumentTypeRepository.findAllByDisciplineId(discipline.getId(), pageRequest); // 断言一共是两页，因为分页大小为1，有两条信息 assertThat(page.getTotalPages()).isEqualTo(2); // 断言分页大小为1 assertThat(page.getContent().size()).isEqualTo(1); // 删除器具类别实体，删除学科类别试题 instrumentTypeRepository.delete(instrumentType1); instrumentTypeRepository.delete(instrumentType); disciplineRepository.delete(discipline); return; &#125; 这样我们就可以在C层去调用刚刚写好的关于分页的函数啦！","raw":null,"content":null,"categories":[{"name":"zhangjiahao","slug":"zhangjiahao","permalink":"http://www.mengyunzhi.cn/categories/zhangjiahao/"}],"tags":[{"name":"pageable","slug":"pageable","permalink":"http://www.mengyunzhi.cn/tags/pageable/"},{"name":"PagingAndSortingRepository","slug":"PagingAndSortingRepository","permalink":"http://www.mengyunzhi.cn/tags/PagingAndSortingRepository/"}]},{"title":"JPA参考文献的翻译（部分）","slug":"translationOfJPADocument","date":"2017-06-29T12:06:12.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/06/29/translationOfJPADocument/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/29/translationOfJPADocument/","excerpt":"Spring Data JPA官方文档 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/\n4.使用Spring数据仓库抽象的说，Spring数据仓库()目标是显著的（significantly）减少为各种持久化存储实现数据访问所需要的示例代码的数量。\n\nspring数据存储仓库文档和模块这一章节解释Spring数据仓库的核心概念和接口，本章节的信息是从（pull from）Spring Data Common模块中提取的。它使用了JPA模块的配置（configuration）和代码实例。适应了XML声明的命名空间和类型，并且扩展了你正在使用的特定模块的类型的等价物。命名空间的引用（reference）涵盖了支持存储库API的所有Spring数据模块支持的XML配置，存储库查询关键字涵盖了通常由存储库抽象支持的查询方法关键字。有关模块的具体特性的详细信息，请参阅本文档模块的章节。\n","text":"Spring Data JPA官方文档 https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ 4.使用Spring数据仓库抽象的说，Spring数据仓库()目标是显著的（significantly）减少为各种持久化存储实现数据访问所需要的示例代码的数量。 spring数据存储仓库文档和模块这一章节解释Spring数据仓库的核心概念和接口，本章节的信息是从（pull from）Spring Data Common模块中提取的。它使用了JPA模块的配置（configuration）和代码实例。适应了XML声明的命名空间和类型，并且扩展了你正在使用的特定模块的类型的等价物。命名空间的引用（reference）涵盖了支持存储库API的所有Spring数据模块支持的XML配置，存储库查询关键字涵盖了通常由存储库抽象支持的查询方法关键字。有关模块的具体特性的详细信息，请参阅本文档模块的章节。 4.1核心概念Spring数据仓库（Spring Data Repository）的中心接口是仓库（Repository）。它需要域类来管理，并且需要域类的id类型作为参数（argument）类型。接口起的主要作用就是作为一个标记接口去捕获要处理的类型并且帮助你去发现该接口的拓展接口。CrudRepository为正在被管理的实体类提供了复杂的（sophisticated）增删改查方法。 示例3. CrudRepository接口 1234567891011public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S entity); //保存给出的实体 T findOne(ID primaryKey); //通过给出的id返回对应的实体 Iterable&lt;T&gt; findAll(); //返回所有的实体 Long count(); //返回实体的数量 void delete(T entity); //删除给出的实体 boolean exists(ID primaryKey); //表示给出id的实体是否存在 // … more functionality omitted.//更多的方法省略了(omit)&#125; 我们也提供了持久特定于技术（technology-specific）的抽象例如：JpaRepository和MongoRepository。这些接口继承了CrudRepository并且暴露了底层的持久化技术的功能（capabilities）除了一些一般（generic）的持久性技术无关的接口，如:CrudRepository。 在CrudRepository之上这里还有一个抽象的PagingAndSortingRepository，它添加了额外的方法来简化对实体的分页访问（paginated access）。 示例4. PageAndSortingRepository 12345public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; &#123; Iterable&lt;T&gt; findAll(Sort sort); Page&lt;T&gt; findAll(Pageable pageable);&#125; 如果你想访问第二页的User并且分页大小是20，你可以简单的这样做： 12PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a beanPage&lt;User&gt; users = repository.findAll(new PageRequest(1, 20)); 除了查询方法以外，还可以查询计数和删除查询的查询派生也是可以用到的。 示例5. 推导出查询的总数 123public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123; Long countByLastname(String lastname);&#125; 示例6. 推导出删除的总数 1234567891011public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123; Long deleteByLastname(String lastname); List&lt;User&gt; removeByLastname(String lastname);&#125;## 4.2 查询方式标准的增删改查功能（functionally）仓库对底层（underlying）的数据存储库（datastore）有查询操作。通过Spring Data,声明这些查询分以下四步：1. 声明一个借口继承Repository或者Repository的某一个子接口（subinterface）并且将它输入到它要处理的域类（domain class）和ID类型。 interface PersonRepository extends Repository { … }122. 在这个接口声明查询方式 interface PersonRepository extends Repository { List findByLastname(String lastname);}123. 设置（set up）Spring为这些接口创建代理实例（proxy instance），通过JavaConfig: import org.springframework.data.jpa.repository.config.EnableJpaRepositories;@EnableJpaRepositoriesclass Config {}12或者通过XML configuration: &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 12345在本例中使用了JPA的命名空间，如果你正在为其他存储库使用存储仓库抽象，你需要为你的存储模块改变到一个合适的声明的命名空间。您需要将其更改为您的存储模块的适当名称空间声明，该声明应该有利于（in favor of）交换jpa，例如mongodb。另外，请注意，JavaConfig变量（variant）不会在默认情况下使用带注释的类的包。要定制（customize）这个包，可以扫描使用一个basePackage.数据存储特定存储库的属性@enable注解。4. 获取注入（inject）的repository实例（instance）且使用它。 public class SomeClient { @Autowired private PersonRepository repository; public void doSomething() { List persons = repository.findByLastname(“Matthews”); }}12345678910111213接下来的章节将详细的解释上面的每一步。## 4.3定义repository接口第一步你应该定义一个域类特定（specific）的repository的接口。这个接口必须继承Repository并且输入到域类和ID类型中。如果你想为这个域类型公开（expose）CRUD方法，继承CrudRepository而不是继承Repository。### 4.3.1 微调库（Fine-tuning）定义通常，你的Repository接口将会继承Repository,CrudRepository或者PagingAndSortingRepository。或者（Alternatively），如果你想继承Spring Data的接口，你也可以用@RepositoryDefinition注解你的repository。继承CrudRepository公开了一系列完整的方法来操作（manipulate）你的实体。如果你想选择这些公开的方法，只需要将这些公开的方法复制的进你的域存储库（domain repository）中。&gt; 这将会允许你在提供的Spring数据存储库功能之上定义你自己的抽象。示例7 选择公开的CRUD方法 @NoRepositoryBeaninterface MyBaseRepository extends Repository { T findOne(ID id); T save(T entity);}interface UserRepository extends MyBaseRepository { User findByEmailAddress(EmailAddress emailAddress);}12345678910111213在第一步中你可以为你的所有的域存储库（domain repository）定义一个公有的基础接口（base interface）并且公开findOne()和save()等方法。这些方法将会被路由到（routed into）Spring Data提供的你选择的基本的存储repository实现。例如：SimpleJpaRepository，因为他们符合CrudRepository的方法声定义（signature）。所以UserRepository将会可以保存users，通过id寻找某一用户，并且通过email address触发（trigger）查询去寻找Users。&gt; 请注意，中间库接口（intermediate repository interface）使用@NoRepositoryBean注解。请确保你在所有的repository接口上添加了这个注解，Spring Data不应该在运行的时候创建实例。## 4.3.2 使用具有多个Spring数据模块的存储仓库（Repositories）在你的项目中使用独一无二的Spring Data模块将会使事情变得简单。在定义的范围内所有的repository接口都绑定到Spring Data模块中。有时候应用们需要使用不止一个Spring Data模块。在这样的情况下，在定义一个repository应该要求区分（distinguish）持久性技术。Spring Data进入严格的repository配置模式（mode）因为它能在类的路径下检测（detect）出复杂的repository工厂。严格的配置要求存储库或域类的详细信息，以决定关于存储库定义的Spring数据模块绑定:&gt; 1.如果repository的定义继承了特定于模块的repository，那么这就是特定的Spring data模块它的有效候选（valid candidate）。&gt; 2.如果域类带有特定于模块的类型注释，那么它就是Spring Data模块的有效候选。Spring Data模块接受第三方（third party）的注释（例如就像JPA的 @Entity），也提供了自己供Spring Data MongoDB/Spring Data Elasticsearch使用的注释例如@Document。示例8 使用Module-specific接口定义的Repository interface MyRepository extends JpaRepository { }@NoRepositoryBeaninterface MyBaseRepository extends JpaRepository { …}interface UserRepository extends MyBaseRepository { …}1234上例中，MyRepository和UserRepository在他们的类型分级结构（hierarchy）继承了JpaRepository。他们是Spring Data JPA模块的有效候选。示例9 使用一般的接口定义的Repository interface AmbiguousRepository extends Repository { …}@NoRepositoryBeaninterface MyBaseRepository extends CrudRepository { …}interface AmbiguousUserRepository extends MyBaseRepository { …}1234AmbiguousRepository和AmbiguousUserRepository在他们的类型层次结构中仅仅继承了Repository和CrudRepository。使用一个独一无二的Spring数据模块是完全没问题的，复杂的模块不能区分这些repository应该绑定（bound）哪一个特定的Spring Data。` 示例10 使用域类和注解绑定Repository 123456789101112131415interface PersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;@Entitypublic class Person &#123; …&#125;interface UserRepository extends Repository&lt;User, Long&gt; &#123; …&#125;@Documentpublic class User &#123; …&#125;` PersonRepository引用了Person，Person类使用了JPA注解@Entity，所以很明显这个repository属于Spring Data JPA。 UserRepository使用了带有Spring Data MongoDB的@Document注解的 User。 示例11 使用带有混合注释的域类的Repository定义 1234567891011interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123; …&#125;@Entity@Documentpublic class Person &#123; …&#125; 这个例子展示（show）了一个使用JPA和Spring Data MongoDB一起注解的域类。它定义了两个repository，JpaPersonRepository和MongoDBPersonRepository。一个是用于JPA的，另外一个是用于MongoDB的。Spring Data不再能够区分存储库（repository）从而导致未定义的行为。 Repository类型细节和定义的域类注解是用于严格的repository配置，这写配置为专门的Spring Data模块识别出repository的候选。在同一域类型上使用多个持久性技术特定的注释可以跨多个持久性技术重用域类型，但是Spring Data不可以决定绑定repository的唯一模块。 最后一个方式去区分repository是确定repository的基础包。基础包定义浏览一个repository接口定义的开始点,这意味着（imply）让repository的定义在合适的包中。默认地，注解的驱动（annotation-driven）配置使用配置类（configuration class）中的包。在基于XML（XML-based）配置中的基本包是必需的。 示例12 基础包的注解驱动配置 123@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)interface Configuration &#123; &#125; 4.4 定义查询方法repository代理有两种方式从方法名去派生（derive）出特定于存储（store-specific）的查询，或者通过使用手动（manually）定义查询。可用的选项（available options）取决于真实的存储。然而，必须有一个策略，决定了创建什么实际查询。让我们看一下可用的选项吧。 4.4.1 查询查找策略截下来的策略是可用于repository基础结构（infrastructure）以解决查询的。你可以在命名空间中通过query-lookup-strategy属性配置这个策略","raw":null,"content":null,"categories":[{"name":"zhangjiahao","slug":"zhangjiahao","permalink":"http://www.mengyunzhi.cn/categories/zhangjiahao/"}],"tags":[{"name":"JPA","slug":"JPA","permalink":"http://www.mengyunzhi.cn/tags/JPA/"},{"name":"documents","slug":"documents","permalink":"http://www.mengyunzhi.cn/tags/documents/"},{"name":"translation","slug":"translation","permalink":"http://www.mengyunzhi.cn/tags/translation/"}]},{"title":"净水器API","slug":"WaterPurifier-API","date":"2017-06-29T02:30:09.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/06/29/WaterPurifier-API/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/29/WaterPurifier-API/","excerpt":"净水器方提供API接口，负责处理单个净水器的请求信息。如获取充值信息，用户使用净水器信息等。","text":"净水器方提供API接口，负责处理单个净水器的请求信息。如获取充值信息，用户使用净水器信息等。 API列表 getCurrentTime ，获取服务器当前时间 getRechargeInfo ， 获取充值信息 isRechargeOk ，反馈充值结果 useInfo ，净水器使用信息 getCurrentTime获取服务器当前时间 URLhttps://api.water.mengyunzhi.com/getCurrentTime 支持格式JSON HTTP请求方式GET 请求参数无 请求示例123GET /api/getCurrentTime HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=UTF-8Host: https://api.water.mengyunzhi.com 响应结果示例12345HTTP/1.1 200 OKContent-Type: text/plain;charset=ISO-8859-1Content-Length: 10 1497457292548 getRechargeInfo获取充值水量 URLhttps://api.water.mengyunzhi.com/getRechargeInfo 支持格式JSON HTTP请求方式GET 请求参数无 请求头信息 id。类型：Long。说明：净水器编号。 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例1234567GET /api/getRechargeInfoContent-Type: application/x-www-form-urlencoded;charset=UTF-8Id:1Timestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bdHost: https://api.water.mengyunzhi.com 响应结果示例1234567891011HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Content-Length: 2 [&#123; &quot;id&quot;: 1(充值编号), &quot;shouldRecharge&quot;: 200(应充水量)&#125;,&#123; &quot;id&quot;: 1(充值编号), &quot;shouldRecharge&quot;: 300(应充水量)&#125;] isRechargeOk反馈充值结果 URLhttps://api.water.mengyunzhi.com/isRechargeOk 支持格式JSON HTTP请求方式POST 请求body信息 id。类型：Long。说明：充值编号。 status。类型：String。说明：充值状态，充值成功（success）或者充值失败（error）。 json数组格式 请求头信息 id。类型：Long。说明：净水器编号。 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例123456789101112131415POST /api/isRechargeOk HTTP/1.1Content-Type: application/json;charset=UTF-8Host: https://api.water.mengyunzhi.comId: 1Timestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd [&#123; &quot;id&quot;: 1(充值编号), &quot;status&quot;: &quot;success&quot;(充值状态)&#125;,&#123; &quot;id&quot;: 1(充值编号), &quot;shouldRecharge&quot;: &quot;error&quot;(充值状态)&#125;] 响应结果示例1HTTP/1.1 200 OK useInfo净水器使用信息 URLhttps://api.water.mengyunzhi.com/useInfo 支持格式JSON HTTP请求方式POST 请求参数 usedBeforeWaterQuality。类型：int。说明：净水前水质。 usedAfterWaterQuality。类型：int。说明：净水后水质。 usedWaterQuantity。类型：int。说明：用水量。 请求头信息 id。类型：Long。说明：净水器编号。 timestamp。类型：String。说明：时间戳。 randomString。类型：String。说明：随机生成的字符串。 encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。 请求示例12345678910111213POST /api/useInfo HTTP/1.1Content-Type: application/json;charset=UTF-8Host: https://api.water.mengyunzhi.comId: 1Timestamp: 1497457292548RandomString: unzdtggyopn1fl7sx68b8olxrEncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd &#123; &quot;usedBeforeWaterQuality&quot;: 80（净水前水质）, &quot;usedAfterWaterQuality&quot;: 90（净水后水质）, &quot;usedWaterQuantity&quot;: 200（用水量）&#125; 响应结果示例1HTTP/1.1 200 OK 时序图","raw":null,"content":null,"categories":[{"name":"chuhang","slug":"chuhang","permalink":"http://www.mengyunzhi.cn/categories/chuhang/"}],"tags":[{"name":"API","slug":"API","permalink":"http://www.mengyunzhi.cn/tags/API/"}]},{"title":"监听指令的外部数据源变化","slug":"watch-element-in-directives","date":"2017-06-27T05:57:11.000Z","updated":"2017-12-29T06:58:04.808Z","comments":true,"path":"2017/06/27/watch-element-in-directives/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/27/watch-element-in-directives/","excerpt":"","text":"先给一个效果图。其中区域是一个指令，而用户是另一个指令。我们希望当区域为区县级别时，显示用户选择列表。非区域级别时，隐藏用户选择框。 分析问题我们希望在用户指令中，监听区域指令发生的变量。大体思想是这样的。 我们将区域做为用户指令的一个属性进行绑定。 在指令选择区域后，当前选择区域由指令回传给V层。 用户指令监听到这个变化，并做出响应 解决问题方法一控制器：12345678angular.module('webappApp') .controller('MandatoryPassrateIndexCtrl', ['$scope', function($scope) &#123; $scope.currentDistrict = &#123;&#125;; // 当前区域 $scope.user = &#123;&#125;; // 当前用户 $scope.appliance = &#123;&#125;; //当前器具 &#125;]); V层12345678910111213141516&lt;div class=\"col-md-4\"&gt; &lt;div class=\"row form-group\"&gt; &lt;label class=\"col-md-4 control-label\"&gt;区域:&lt;/label&gt; &lt;div class=\"col-md-8\"&gt; &lt;yunzhi-district ng-model=\"currentDistrict\"&gt;&lt;/yunzhi-district&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"col-md-4\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-md-4 control-label\"&gt;用户:&lt;/label&gt; &lt;div class=\"col-md-8\"&gt; &lt;yunzhi-measurement-user ng-model=\"user\" data-district=\"currentDistrict\"&gt;&lt;/yunzhi-measurement-user&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 用户指令：12345678910111213angular.module('webappApp') .directive('yunzhiMeasurementUser', ['measurementUser', function(measurementUser) &#123; return &#123; templateUrl: 'views/directive/yunzhiMeasurementUser.html', controller: function($scope) &#123; console.log($scope); &#125;, link: function postLink(scope, element, attrs) &#123; console.log(attrs); // 监听传入的data-district是否发生了变化，如果发生了变化，则重新获取器具用户列表 scope.$watch(attrs.district, function(newValue) &#123; //something &#125; 控制台信息： 观察控制台，我们发现：我们想监控是ChildScope中的currentDistrict，该项信息存在于Attributes的disctrict。所以，我们使用scope.$watch(attrs.district, 进行监听。 方法二我们引用局部scope变量，并进行双向数据绑定。1234567891011121314151617angular.module('webappApp') .directive('yunzhiMeasurementUser', ['measurementUser', function(measurementUser) &#123; return &#123; templateUrl: 'views/directive/yunzhiMeasurementUser.html', scope: &#123; ngModel: '=', // 双向绑定ngModel district: '=' // 双向绑定data-district &#125;, controller: function($scope) &#123; console.log($scope); &#125;, link: function postLink(scope, element, attrs) &#123; console.log(attrs); // 监听传入的data-district是否发生了变化，如果发生了变化，则重新获取器具用户列表 scope.$watch('district', function(newValue) &#123; //something &#125; 控制台： 此时，scope中的字段信息，为重命名后的字段，所以直接使用字符串district, 进行监听。 总结：无论哪种方式，最终我们要监听的数据位于$scope上。要监听前，我们需要对$scope进行打印，进而找到要监听的对象名称。最终将该名称以字符串的方式传入到scope.$watch()中以完成监听过程。 调试，无论在哪种语言中，都具有最高的地位！","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.mengyunzhi.cn/tags/AngularJS/"}]},{"title":"Spring MVC 使用@JsonView自定义输出字段","slug":"spring-mvc-use-json-view-specifying-filed","date":"2017-06-27T01:01:31.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/27/spring-mvc-use-json-view-specifying-filed/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/27/spring-mvc-use-json-view-specifying-filed/","excerpt":"在前后台的分离开发中，我们常常直接输出实体的全部属性。这在大多数情况下都是没有问题的，但有些时候，直接输出全部属性的方法，可能会千万系统死循环的异常，进行影响到数据的输出。本文将阐述使用@JsonView注解来避免该问题。","text":"在前后台的分离开发中，我们常常直接输出实体的全部属性。这在大多数情况下都是没有问题的，但有些时候，直接输出全部属性的方法，可能会千万系统死循环的异常，进行影响到数据的输出。本文将阐述使用@JsonView注解来避免该问题。 问题描述比如，我们现在有个树状实体 区域，每个区域都有个父级区域，每个区域又有个子区域集合.12345678910111213141516@Entity@ApiModel(value = \"District (区域)\", description = \"区域\")public class District implements Serializable&#123; // 实现了Serializable接口，用于序列化 private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; @ApiModelProperty(\"上级区域\") @ManyToOne private District parentDistrict; @ApiModelProperty(\"下级区域列表\") @OneToMany(mappedBy = \"parentDistrict\") @Lazy private List&lt;District&gt; sonDistricts = new ArrayList&lt;&gt;(); 此时, 当我们查找到某个区域，并将其进行json序列化时，将得到一个如下的错误：1Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON document: Infinite recursion (StackOverflowError) (through reference chain: com.mengyunzhi.measurement.repository.District[\"sonDistricts\"]-&gt;org.hibernate.collection.internal.PersistentBag[0]-&gt;com.mengyunzhi.measurement.repository.District[\"parentDistrict\"]-&gt;... 分析问题这是由于在进行Json转化时，Spring MVC会自动获取实体上所有属性的值。也就是说@Lazy不起作用了。这直接导致了： 获取某个区域 获取某个区域的父区域 获取父区域的所有子区域 区域子区域的父区域… 死循环就这么产生了。 解决问题使用@JsonIgnore千万死循环的原因是由于互相调用，所以，我们可以使用@JsonIgnore来忽略到任意一方，便可以达到解决问题的目的。但这个方法并不完美。一旦设置了该注解，在前台后分离的架构中，将永远不能够输出该字段的值。这并不是我们想看到的。 使用@JsonView使用@JsonView可以对字段输出进行自由的组合参考官方文档：https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-jsonview 123456789101112131415161718192021222324@Entity@ApiModel(value = \"District (区域)\", description = \"区域\")public class District implements Serializable&#123; public interface WithAll &#123;&#125;; public interface WithOutParentDistrict extends WithAll &#123;&#125;; public interface WithOutSonDistricts extends WithAll &#123;&#125;; // 实现了Serializable接口，用于序列化 private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) @JsonView(WithAll.class) private Long id; @ApiModelProperty(\"区域名称\") @JsonView(WithAll.class) private String name; @ApiModelProperty(\"上级区域\") @ManyToOne @JsonView(WithOutSonDistricts.class) private District parentDistrict; @JsonView(WithOutParentDistrict.class) @OneToMany(mappedBy = \"parentDistrict\") @Lazy private List&lt;District&gt; sonDistricts = new ArrayList&lt;&gt;();&#125; 然后在C层中，将入@JsonView以指定该C层，对应输出实体的哪些字段。12345678@ApiOperation(value = \"get (获取一条数据)\", notes = \"获取一条数据\", nickname = \"District_get\")@GetMapping(\"/get/&#123;id&#125;\")@JsonView(District.WithOutSonDistricts.class)public District get(@ApiParam(value = \"区域实体id\") @PathVariable Long id) &#123; //获取一条数据 District district = districtService.get(id); return district;&#125; 此时，在进行json转化时，将不进行子区域的获取。但新的问题又产生了，那就是我们以后在进行json输出时，要必须指定JsonView，否则就需要进行所有的转换。这会使得当我们获取一些关联数据时，发生错误。比如我们获取一个部门的时候，将自动获取这个部门对应的区域，那么此时，进行json转换时，还将循环的错误。 使用@JsonView并去除@OneToMany1234567891011121314151617@Entity@ApiModel(value = \"District (区域)\", description = \"区域\")public class District implements Serializable&#123; public interface WithAll &#123;&#125;; public interface WithOutParentDistrict extends WithAll &#123;&#125;; // 实现了Serializable接口，用于序列化 private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.AUTO) @JsonView(WithAll.class) private Long id; @ApiModelProperty(\"上级区域\") @ManyToOne private District parentDistrict; @JsonView(WithOutParentDistrict.class) @Transient // 该字段并不存在于数据表中 private List&lt;District&gt; sonDistricts = new ArrayList&lt;&gt;(); 此时，我们便实现了： 在不加@JsonView注解的情况下，由于@Transient的存在，使得sonDistricts保持为空集合。 在加入@JsonView(District.WithOutParentDistrict.class)的情况下，将输出sonDistricts同时，忽略输出parentDistrict. 使用的接口继承，便于代码在后期的扩展。 为了上述实体的工作，我们还需要手动的去获取子区域。1234public interface DistrictRepository extends CrudRepository&lt;District, Long&gt; &#123; District getByName(String name); List&lt;District&gt; getAllByParentDistrictId(Long id);&#125; 123456789@Overridepublic District getTreeByDistrict(District district) &#123; List&lt;District&gt; districts = districtRepository.getAllByParentDistrictId(district.getId()); for(District district1 : districts) &#123; this.getTreeByDistrict(district1); &#125; district.setSonDistricts(districts); return district;&#125; C层使用方法：12345678@ApiOperation(value = \"getTreeById\", notes = \"获取当前用户所有的部门树\", nickname = \"District_getTreeById\")@GetMapping(\"/getTreeById/&#123;id&#125;\")@JsonView(District.WithOutParentDistrict.class)public District getTreeById(@ApiParam(value = \"区域ID\") @PathVariable Long id) &#123; District district = districtService.get(id); districtService.getTreeByDistrict(district); return district;&#125; 总结由于jackjson在进行json序列化时，将默认序列化所有的字段。所以，我们需要使用@JsonIgnore或@JsonProperty来排除某些字段。但一味的全部排除有时又不能满足我们的需求。这时候，就需要使用定制性更强的@JsonView。使用@JsonView虽然能够解决特殊的需求，但是如果由于实体间的关联关系。每进行一次输出，都定制一次@JsonView又过于麻烦。最终在实际的问题上，我们删除了OneToMany的关系，手动的维护了OneToMany的关系。这使我们只在进行特定输出时使用@JsonView来解决问题。 除了在实体中，直接建立接口以外，我们也可以单独的新建一个类，然后在这个类中，建立接口，或是抽象类。并将接口或是抽象类应用到实体的字段中。 在特殊的时候，以上的方法可以还解决不了我们的问题。如果是这样，我们就需要单独的建立用于进行json序列化输出的类了。然后在这个类中，去定义get函数，spring mvc，则会自动触发get中的方法，进而进行json的自动转换. 参考文档：https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-jsonview 代码示例：","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://www.mengyunzhi.cn/tags/Spring-MVC/"},{"name":"JsonView","slug":"JsonView","permalink":"http://www.mengyunzhi.cn/tags/JsonView/"}]},{"title":"let's learn what is 'cascade = CascadeType.MERGE'","slug":"let-s-learn-what-is-cascade-CascadeType-MERGE","date":"2017-06-24T15:11:21.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/24/let-s-learn-what-is-cascade-CascadeType-MERGE/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/24/let-s-learn-what-is-cascade-CascadeType-MERGE/","excerpt":"","text":"通过用户 – 角色，来演示cascade = CascadeType.MERGE的作用. 演示添加该属性时，进行用户编辑时，竟然一同编辑了角色的name. 去除cascade = CascadeType.MERGE后再次编辑。正常显示。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"在angularJs中，如何将list列表数据绑定到一系列的checkbox中。","slug":"how-to-bind-to-list-of-checkbox-value-and-set-checked-with-angularjs","date":"2017-06-24T14:59:50.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/24/how-to-bind-to-list-of-checkbox-value-and-set-checked-with-angularjs/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/24/how-to-bind-to-list-of-checkbox-value-and-set-checked-with-angularjs/","excerpt":"在项目开发中，我们经常会遇到多到多的数据更新操作。比如，在一个用户可以拥有多个角色的系统中，我们需要更新某个用户的角色的操作。","text":"在项目开发中，我们经常会遇到多到多的数据更新操作。比如，在一个用户可以拥有多个角色的系统中，我们需要更新某个用户的角色的操作。 目标在进行数据更新前，我们需要知道，哪些角色是该用户已经拥有的，哪些角色又是该用户还没有拥有的。那些已经拥有的角色，我们需要设置为默认选中；而那些还没有的角色，我们需要给出列表，但不能选中。比如，我们现在编辑的用户，只拥有“器具用户”角色，那么我们期望的初始状态如下： 数据前提想有上图中的效果，我们必须有两项基本的数据支持： 系统共有多个种角色roles 当前用户拥有的角色user.roles对于上图而言：roles = [技术机构,器具用户,系统管理员，管理部门，管理员];user.roles = [器具用户]; 解题思路 将user.roles进行转换，做为该用户拥有的角色。 循环输出roles。 在每个循环子项中，判断当前role是否存在于user.roles中。 存在，说明用户拥有此权限，选中。 不存在，说明用户并不拥有此权限，不选中。 点击checkbox时，重新设置用户拥有的角色。 提交数据时，将用户拥有的角色数组进行逆转换。 代码将user.roles进行转换，做为该用户拥有的角色。123456self.roleIds = []; // 角色ID数组 // 将角色的ID单独取出，新建数组angular.forEach(self.data.roles, function(value) &#123; self.roleIds.push(value.id);&#125;); 循环输出roles123&lt;div ng-repeat=\"role in roles\"&gt; &lt;label&gt;&lt;input type=\"checkbox\"&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;role.name&#125;&#125;&lt;/label&gt;&lt;/div&gt; 在每个循环子项中，判断当前role是否存在于user.roles中。 存在，说明用户拥有此权限，选中。 不存在，说明用户并不拥有此权限，不选中。 123&lt;div ng-repeat=\"role in roles\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" ng-checked=\"checked(role)\"&gt;&amp;nbsp;&amp;nbsp;&#123;&#123;role.name&#125;&#125;&lt;/label&gt;&lt;/div&gt; 123456789// 检测是否选中角色self.checked = function(role) &#123; // self.roleIds if (self.roleIds.indexOf(role.id) === -1) &#123; return false; &#125; else &#123; return true; &#125;&#125;; 点击checkbox时，重新设置用户拥有的角色。123&lt;div ng-repeat=\"role in roles\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" ng-checked=\"checked(role)\" ng-click=\"toggleSelection(role)\" &gt;&amp;nbsp;&amp;nbsp;&#123;&#123;role.name&#125;&#125;&lt;/label&gt;&lt;/div&gt; 123456789// 用户切换角色时，实时的用户选中的角色信息进行更新self.toggleSelection = function(role) &#123; var idx = self.roleIds.indexOf(role.id); if (idx === -1) &#123; self.roleIds.push(role.id); &#125; else &#123; self.roleIds.splice(idx, 1); &#125;&#125;; 提交数据时，将用户拥有的角色数组进行逆转换。123456789101112131415self.submit = function() &#123; var roles = []; // 进行逆转换 angular.forEach(self.roleIds, function(value)&#123; roles.push(&#123;id:value&#125;); &#125;); $scope.data.roles = roles; UserServer.update($scope.data.id, $scope.data, function(status)&#123; if (204 === status) &#123; $location.path('/system/Userfile'); &#125; else &#123; console.log(\"todo:提示错误信息\"); &#125; &#125;); &#125;; 总结： 想实现基本的功能，需要有两个数据支持。 所有的角色 用户拥有的角色 要显示所有的角色列表，所以要对角色进行循环输出 每输出一个角色，都需要用方法来决定是否进行选中 用户每选中一个角色，都需要更新数据 在进行数据提交前，要转换为后台可以接收的数据规范","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.mengyunzhi.cn/tags/AngularJS/"},{"name":"checkbox","slug":"checkbox","permalink":"http://www.mengyunzhi.cn/tags/checkbox/"}]},{"title":"如何安装maven","slug":"how-to-install-maven","date":"2017-06-24T03:52:39.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/24/how-to-install-maven/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/24/how-to-install-maven/","excerpt":"问题描述在做单元测试以及对项目文件进行打包的时候，我们需要用到mvntest、mvnpackage等命令，这样做的前提是我们的电脑中必须安装好了maven，那么maven应该如何安装呢？","text":"问题描述在做单元测试以及对项目文件进行打包的时候，我们需要用到mvntest、mvnpackage等命令，这样做的前提是我们的电脑中必须安装好了maven，那么maven应该如何安装呢？ 安装过程下载maven首先我们应该去maven的下载官网：http://maven.apache.org/download.cgi，找到如下图所示的文件进行下载。 解压下载完毕后进行解压，将maven放到我们想放到的磁盘下面，打开文件发现里面有一个bin文件。例如笔者的bin文件放在了G:\\maven\\apache-maven-3.5.0下面，如下图所示： 配置系统变量接下来我们需要配置环境变量：控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;系统变量： 在系统变量下点击新建，输入系统变量的值(由maven安装位置决定) 修改path值 测试是否安装成功打开cmd，输入mvn –version 如果出现这样的界面，恭喜你，maven已经成功安装到计算机中啦！","raw":null,"content":null,"categories":[{"name":"zhangjiahao","slug":"zhangjiahao","permalink":"http://www.mengyunzhi.cn/categories/zhangjiahao/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://www.mengyunzhi.cn/tags/maven/"},{"name":"install","slug":"install","permalink":"http://www.mengyunzhi.cn/tags/install/"}]},{"title":"建立指令的步骤","slug":"how-to-establish-directive","date":"2017-06-24T03:40:57.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/24/how-to-establish-directive/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/24/how-to-establish-directive/","excerpt":"以本项目为例，写一下建立指令的步骤。\n新建指令在项目的Webapp目录下打开git shell，用yoeman建立新的指令以及指令对应的test文件。以新建岗位指令（post）为例。1yo angular:directive yunzhipost","text":"以本项目为例，写一下建立指令的步骤。 新建指令在项目的Webapp目录下打开git shell，用yoeman建立新的指令以及指令对应的test文件。以新建岗位指令（post）为例。1yo angular:directive yunzhipost 完成指令的内容以及样式完成yunzhipost.js 首先，在yunzhipost.js中先加入独立scope，将指令中的post属性双向绑定到scope.post上 1234scope: &#123; // 将指令中的post属性，双向绑定到scope.post ngModel: '=' &#125;, 然后指出指令的类型， 1restrict: 'EA', 其中，A（默认）为属性，在html文件中以&lt;div hello&gt;&lt;/div&gt;形式使用；E为元素，在html文件中以&lt;hello&gt;&lt;/hello&gt;形式使用；M为注释，在html文件中以&lt;!-- directive:hello --&gt;形式使用；C为css样式类，在html文件中以&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;形式使用。 然后指明该指令样式所在的模板文件地址， 1templateUrl: 'views/directive/yunzhiPost.html', 在controller里面，写出该指令实现的方法，包括：初始化、获取后台数据等。 1234567891011121314controller: function($scope) &#123; $scope.posts = []; // 初始化所有岗位 $scope.post = &#123;&#125;; // 初始化岗位 $scope.post.selected = $scope.ngModel; // 传值。 // 获取用户可见的岗位列表 postService.getCurrentUserPostArray(function(data) &#123; $scope.posts = data; // 如果大小不为0，而且用户并没有传入ngModel实体，则将第一个岗位给当前岗位 if (data.length &gt; 0 &amp;&amp; angular.equals($scope.ngModel, &#123;&#125;)) &#123; $scope.post.selected = data[0]; &#125; &#125;);&#125;, *在link里面，监视内容是否变化，如果发生变化则利用数据的双向绑定，将值传回V层。123456link: function postLink(scope) &#123; // 监视岗位是否发生变化。如果发生变化，则重置ngModel的值。此时，利用双向数据绑定。将值传回V层 scope.$watch('post', function(newValue) &#123; scope.ngModel = newValue.selected; &#125;, true);&#125;, 完成yunzhipost.js对应的V层样式根据2.1中提到的模板文件地址，在V层的directive文件夹下，新建yunzhiPost.html文件，用于编写该指令对应的V层样式。1234567&lt;!--岗位--&gt;&lt;ui-select ng-model=\"post.selected\" theme=\"bootstrap\" ng-disabled=\"disabled\"&gt; &lt;ui-select-match placeholder=\"请选择\"&gt;&#123;&#123;$select.selected.name&#125;&#125;&lt;/ui-select-match&gt; &lt;ui-select-choices repeat=\"post in posts | propsFilter: &#123;name: $select.search, pingyin: $select.search&#125;\"&gt; &lt;div ng-bind-html=\"post.name | highlight: $select.search\"&gt;&lt;/div&gt; &lt;/ui-select-choices&gt;&lt;/ui-select&gt; 完成指令的数据读取在完成以上步骤后，只需要再对后台数据进行读取，这个指令就写完了！同样的，我们首先用yoeman新建service文件，在service文件中实现对后台数据的获取。1yo angular:service PostService 执行完这条命令以后会自动生成相应的js文件。以PostService文件为例，我们在service里面定义一个方法，用来获取在data文件夹中写入的模拟json数据。123456789var getCurrentUserPostArray;getCurrentUserPostArray = function(callback) &#123; $http.get('data/post/getCurrentUserPostArray.json').then(function(response) &#123; callback(response.data); &#125;);&#125;;return &#123; getCurrentUserPostArray: getCurrentUserPostArray&#125;; 与后台数据对接的时候只需要把json数据删掉，将数据获取方式改为后台数据获取即可。 将指令写在V层接下来，我们只要在V层需要的位置写入该指令就可以直接使用了。1&lt;yunzhi-post ng-model=\"post\"&gt;&lt;/yunzhi-post&gt; 感谢您花费时间阅读这份总结，有不对之处欢迎指正。","raw":null,"content":null,"categories":[{"name":"chenyuanyuan","slug":"chenyuanyuan","permalink":"http://www.mengyunzhi.cn/categories/chenyuanyuan/"}],"tags":[{"name":"yeoman","slug":"yeoman","permalink":"http://www.mengyunzhi.cn/tags/yeoman/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.mengyunzhi.cn/tags/AngularJS/"}]},{"title":"C层自动化文档生成过程","slug":"how-to-generate-auotomation-documents","date":"2017-06-23T13:45:17.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/23/how-to-generate-auotomation-documents/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/23/how-to-generate-auotomation-documents/","excerpt":"问题描述在前后台完全分离的项目中，前后台完成对接主要依据是开发文档，为了保证开发效率，我们引入了自动生成文档的注解，那么它是怎么工作的呢？另外在C层的测试类下，我们需要在文档中生成包含响应信息以及请求信息的文档，那么它们又是如何生成的呢？下面我们以部门类型（DepartmentType）的C层为例，说一下自动化文档生成的过程。","text":"问题描述在前后台完全分离的项目中，前后台完成对接主要依据是开发文档，为了保证开发效率，我们引入了自动生成文档的注解，那么它是怎么工作的呢？另外在C层的测试类下，我们需要在文档中生成包含响应信息以及请求信息的文档，那么它们又是如何生成的呢？下面我们以部门类型（DepartmentType）的C层为例，说一下自动化文档生成的过程。 添加注解1234567891011121314@Api(tags = \"DepartmentType (部门类型)\", description = \"部门 部门类型C层\")@RestController@RequestMapping(\"/DepartmentType\")public class DepartmentTypeController &#123; @Autowired protected DepartmentTypeService departmentTypeService; // 部门类型 @GetMapping(\"/\") @ApiOperation(value = \"获取所有数据\", notes = \"获取所有数据（未排序 ）@author:panjie\", nickname = \"DepartmentType_getAll\") public List&lt;DepartmentType&gt; getAll() &#123; return departmentTypeService.findAll(); &#125;&#125; 在java代码中，如果我们想添加注解，那么首先我们应该引用@Api目录下的各种注解，其中对应于不同的注解有着不同的功能。例如上例中，@Api(tags = “DepartmentType (部门类型)”, description = “部门 部门类型C层”) 这一行代码，我们将代码成功提交之后，会发现已经体现在了文档中。你也许会疑惑为什么没有看到nickname的作用呢？在后面我会说一下nickname的作用。 效果展示首先我么会发现在1.5的目录中tags标签里面新增了刚才添加的内容了。如下图所示： 另外在第三章中关于各个模块的描述中，我们也同样可以看到新增内容，其中与代码对应情况如下： 生成请求信息和响应信息我们会发现，除了上面提到的几个API标签对应的内容以外，还有Response等响应信息，那么这些又是怎么生成的呢？这就涉及到我们的ControllerTest类了。123456789101112131415161718192021222324@Testpublic void getAll() throws Exception &#123; logger.info(\"---- getAll方法测试 ----\"); logger.info(\"---- 创建一个部门类型实体 ----\"); DepartmentType departmentType = new DepartmentType(); System.out.println(departmentType); logger.info(\"保存该实体\"); departmentTypeRepository.save(departmentType); logger.info(\"获取响应信息\"); MvcResult mvcResult = this.mockMvc.perform(get(\"/DepartmentType/\") .contentType(\"application/json\") .header(\"x-auth-token\", xAuthToken)) .andExpect(status().isOk()) .andDo(document(\"DepartmentType_getAll\", preprocessResponse(prettyPrint()))) .andReturn(); List&lt;DepartmentType&gt; departmentTypeList = (List&lt;DepartmentType&gt;) departmentTypeRepository.findAll(); logger.info(\"断言获取到的数据条数与直接使用repository的实体数相同\"); String content = mvcResult.getResponse().getContentAsString(); JSONArray JSONArray = net.sf.json.JSONArray.fromObject(content); assertThat(JSONArray.size()).isEqualTo(departmentTypeList.size());&#125; 上面代码是C层中getAll方法的单元测试内容，代码this.mockMvc.perform(get(“/DepartmentType/“)中，get方法内对应的参数，即为Controller中对于get方法定义出来的url，这样子才能用mockMvc向应用程序发出请求，才能够继续执行下面的header、andExpect等函数。其中andDo(document(“DepartmentType_getAll”, preprocessResponse(prettyPrint())))的作用是获取相应信息并且打印出来，其中document函数中第一个参数，与C层中的nickname相同，这样我们才能正确的获取到打印信息。 单元测试通过以后，我们提交代码并合并到development分支，我们便可以查看到完整的开发文档信息了。☺","raw":null,"content":null,"categories":[{"name":"zhangjiahao","slug":"zhangjiahao","permalink":"http://www.mengyunzhi.cn/categories/zhangjiahao/"}],"tags":[{"name":"automation documents","slug":"automation-documents","permalink":"http://www.mengyunzhi.cn/tags/automation-documents/"}]},{"title":"计量项目建立路由的流程","slug":"how-to-establish-route","date":"2017-06-23T13:32:08.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/23/how-to-establish-route/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/23/how-to-establish-route/","excerpt":"通过这一段时间建立路由，明白了项目的整体文件之间的关系。下面以本次项目为例说一下在angularjs中建立路由的流程。\n确定菜单名称将需求分析给出的原型中，每一个菜单名称翻译出来。可以以本次的计量项目需求为例确定好每个菜单名对应的英文名称后，开始进行路由的建立","text":"通过这一段时间建立路由，明白了项目的整体文件之间的关系。下面以本次项目为例说一下在angularjs中建立路由的流程。 确定菜单名称将需求分析给出的原型中，每一个菜单名称翻译出来。可以以本次的计量项目需求为例确定好每个菜单名对应的英文名称后，开始进行路由的建立 采用yoeman建立路由打开git shell进入到本项目的Webapp文件下，输入下面命令1yo angular:route supervise/organization/index --uri=supervise/organization 这句命令的意思是，建立“监督抽查-授权检定机构监督抽查”这个菜单相对应的controller、view以及test中的文件。 上面建立路由的方式是用yoeman对angular js建立路由的方式，但是由于本项目中套用了模板的js，所以按照上面的语句建立路由以后，需要手动对项目文件中的scripts/app.js、scripts/config.js等文件进行修改。 修改scripts/app.js文件将本文件中因yoeman建立路由而生成的路由删掉。即删掉下述部分 修改scripts/config.js文件在本文件中，添加相应的路由 修改控制器文件名此时，为了保证文件名和控制器名称保持一致，还需要修改一下控制器的文件名，即将中的index.js改成indexController.js，然后在scripts/index.html中将也对应的改为indexController.js。 这样，我们就完成了整个路由建立的过程。 感谢您花费时间阅读这份总结，有不对之处欢迎指正。","raw":null,"content":null,"categories":[{"name":"chenyuanyuan","slug":"chenyuanyuan","permalink":"http://www.mengyunzhi.cn/categories/chenyuanyuan/"}],"tags":[{"name":"yeoman","slug":"yeoman","permalink":"http://www.mengyunzhi.cn/tags/yeoman/"},{"name":"route","slug":"route","permalink":"http://www.mengyunzhi.cn/tags/route/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://www.mengyunzhi.cn/tags/AngularJS/"}]},{"title":"Spring MVC 绑定json数据到多个实体上","slug":"binding-json-data-to-two-entity","date":"2017-06-22T13:17:16.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/22/binding-json-data-to-two-entity/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/22/binding-json-data-to-two-entity/","excerpt":"在spring mvc的数据绑定定，我们可以轻松的将json对象绑定到一个实体上。但如何一次性的绑定到多个实体上的呢？","text":"在spring mvc的数据绑定定，我们可以轻松的将json对象绑定到一个实体上。但如何一次性的绑定到多个实体上的呢？ 绑定单个实体绑定一个实体的时候，我们往往是这么做的：比如，我们在新增用户时，需要绑定传入的用户信息:123456@PostMapping(\"/save\") @ApiOperation(value = \"save 保存用户\",nickname = \"User_save\",notes = \"保存用户\") public User save(@ApiParam(value = \"用户\") @RequestBody User user)&#123; userService.save(user); return user; &#125; 对应的，我们可以这样发送数据，进而完成数据绑定：1&#123;\"username\":\"yunzhiclub\", \"password\":\"123456\"&#125; 问题描述我们刚刚描述了绑定单个实体的方法，但如果我们需要一次发送多个实体到后台，又该怎么办呢？比如，我们需要把部门和用户信息同时传给控制器做外理。例如，前台我们将发送这样的数据：1234&#123; \"user\":&#123;\"username\":\"zhangsan\"&#125;, \"deparment\":&#123;\"name\":\"部门1\"&#125;&#125; 其中user是一个实体的信息，而department是另一个实体的信息。 解决方法新建内部静态类比如我们现在的控制器为UserController,则在UserController中建立如下静态内部类： 注意：必须声明为静态内部类，否则将得到一个未能成功绑定的400异常 123456789101112131415161718192021@ApiModel(value = \"部门+用户\") public static class DepartmentUser &#123; @ApiModelProperty(\"部门\") private Department department; @ApiModelProperty(\"用户\") private User user; public DepartmentUser() &#123; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 有了这个内部静态类，我们就可以将数据成功的绑定到上面两个内部实体上了。 123456@PostMapping(\"/register\")@ApiOperation(value = \"register 注册后户\", notes = \"用户注册时，同时注册部门及用户信息\", nickname = \"User_register\")@ResponseStatus(HttpStatus.NO_CONTENT)public void register(@ApiParam(value = \"用户注册信息：部门信息+用户信息\") @RequestBody DepartmentUser departmentUser) &#123; return;&#125; 此时，departmentUser就是我们绑定的信息。我们可以使用其中的getUser()和getDepartment()来获取绑定的值。我们还可以在return上打一个断点，启动调试模式来查看绑定的departmentUser的值. 总结 json数据可以绑定到某一个实体类上。 实体类的本质是类 json数据可以绑定到任意类上。 json数据绑定到类的前提是：有相应字段的set方法。 要想绑定多个实体，需要将多个实体组合为一个实体。 发送数据时，将不同的实体数据做为json对象的不同属性发送。 代码片断 问题相关项目代码, 单元测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package com.mengyunzhi.measurement.controller;import com.mengyunzhi.measurement.Service.UserService;import com.mengyunzhi.measurement.repository.Department;import com.mengyunzhi.measurement.repository.User;import com.mengyunzhi.measurement.repository.WebAppMenu;import io.swagger.annotations.*;import org.apache.log4j.Logger;import org.hibernate.ObjectNotFoundException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.security.Principal;import java.util.List;/** * Created by panjie on 17/5/17. * */@Api(tags = \"User 用户\", description = \"用户管理\")@RequestMapping(\"/User\")@RestControllerpublic class UserController &#123; static Logger log = Logger.getLogger(UserController.class.getName()); @Autowired private UserService userService; @GetMapping(\"/login\") @ApiOperation(value = \"login 登录\", nickname = \"User_login\", notes=\"用户登录成功后，将会得到一个header 信息。客户端存储该值后，下次发送时做为header中的XXX进行发送\") public void login(Principal user) &#123; log.info(\"-----------------登录成功----------------\"); log.info(\"登录用户:\" + user.getName()); // 此函数触发，则说明登录成功 return; &#125; @GetMapping(\"/logout\") @ApiOperation(value = \"logout 注销\", nickname = \"User_logout\", notes = \"参考资料：http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html\") public void logout(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; log.info(\"-----------------注销----------------\"); // 获取当前认证信息 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); // 如果存在认证信息则调用注销操作 if (null != authentication) &#123; new SecurityContextLogoutHandler().logout(httpServletRequest, httpServletResponse, authentication); &#125; return ; &#125; @GetMapping(\"/getAll\") @ApiOperation(value = \"getAll 获取所有用户\",nickname = \"User_getAll\",notes = \"获取所有用户\") public List&lt;User&gt; getAll()&#123; return userService.getAll(); &#125; @PostMapping(\"/save\") @ApiOperation(value = \"save 保存用户\",nickname = \"User_save\",notes = \"保存用户\") public User save(@ApiParam(value = \"用户\") @RequestBody User user)&#123; userService.save(user); return user; &#125; @GetMapping(\"/get/&#123;id&#125;\") @ApiOperation(value = \"get 获取一个用户\",nickname = \"User_get\",notes = \"获取一个用户\") public User get(@ApiParam(value = \"实体id\") @PathVariable Long id)&#123; return userService.get(id); &#125; @ApiOperation(value = \"update (修改)\", notes = \"修改某条数据\", nickname = \"User_update\") @ApiResponse(code = 204, message = \"更新成功\") @PutMapping(value = \"/update/&#123;id&#125;\") public void update(@ApiParam(value = \"实体ID\") @PathVariable Long id, @ApiParam(value = \"用户实体\") @RequestBody User user, HttpServletResponse response) &#123; log.info(\"---- 更新实体 -----\"); log.info(\"在数据更新中，可以直接调用M层的save方法.\"); try &#123; userService.update(id, user); response.setStatus(204); &#125; catch (ObjectNotFoundException e) &#123; response.setStatus(404); &#125; return; &#125; @DeleteMapping(\"/delete/&#123;id&#125;\") @ApiOperation(value = \"delete 保存用户\",nickname = \"User_delete\",notes = \"删除用户\") @ResponseStatus(HttpStatus.NO_CONTENT) //删除成功返回状态码204 public void delete(@ApiParam(value = \"用户\") @PathVariable Long id,HttpServletResponse response)&#123; log.info(\"---- 删除实体 -----\"); log.info(\"在数据删除中，可以直接调用M层的delete方法.\"); userService.delete(id); return; &#125; @GetMapping(\"/getCurrentUserWebAppMenus/\") @ApiOperation(value = \"getCurrentUserWebAppMenus 获取当前用户的菜单权限列表\", nickname = \"User_getCurrentUserWebAppMenus\", notes = \"查询前台菜单权限\") public List&lt;WebAppMenu&gt; getCutUserWebAppMenus() &#123; return userService.getCurrentUserWebAppMenus(); &#125; @GetMapping(\"/checkUsernameIsExist/&#123;username&#125;\") @ApiOperation(value = \"checkUsernameIsExist 检测用户名是否已经存在\", nickname = \"User_checkUsernameIsExist\", notes = \"存在：true,不存在:false @author:panjie\") public boolean checkUsernameIsExist(@ApiParam(value = \"用户名（邮箱），必须使用邮箱作为用户名\") @PathVariable String username) &#123; return userService.checkUsernameIsExist(username); &#125; @GetMapping(\"/setUserStatusToNormalById/&#123;id&#125;\") @ApiOperation(value = \"setUserStatusToNormalById 设置某个用户的状态为正常\", notes = \"author:panjie\", nickname = \"User_setUserStatusToNormalById\") public void setUserStatusToNormalById(@ApiParam(value = \"用户id\") @PathVariable Long id) &#123; userService.setUserStatusToNormalById(id); return; &#125; @PostMapping(\"/register\") @ApiOperation(value = \"register 注册后户\", notes = \"用户注册时，同时注册部门及用户信息\", nickname = \"User_register\") @ResponseStatus(HttpStatus.NO_CONTENT) public void register(@ApiParam(value = \"用户注册信息：部门信息+用户信息\") @RequestBody DepartmentUser departmentUser) &#123; return; &#125; @ApiModel(value = \"部门+用户\") public static class DepartmentUser &#123; @ApiModelProperty(\"部门\") private Department department; @ApiModelProperty(\"用户\") private User user; public DepartmentUser() &#123; &#125; public Department getDepartment() &#123; return department; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125;&#125;","raw":null,"content":null,"categories":[],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.mengyunzhi.cn/tags/spring-mvc/"},{"name":"data binding","slug":"data-binding","permalink":"http://www.mengyunzhi.cn/tags/data-binding/"}]},{"title":"复写Bower.json文件比较好的方法","slug":"Best-practice-when-overriding-main-files-of-bower-sub-dependencies","date":"2017-06-20T12:26:29.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/20/Best-practice-when-overriding-main-files-of-bower-sub-dependencies/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/20/Best-practice-when-overriding-main-files-of-bower-sub-dependencies/","excerpt":"","text":"Override Bower Packages当我用 bower install 下载一个github上的 bower package时，下载完成之后，它自己带的bower.json文件里面并没有 “main”: “angular-locale_zh-cn.js”这种使得我们启动 grunt项目 来帮我们直接执行添加依赖的代码。 当然，我们自己可以在自己本地的bower.json文件中添加 这行语句，这样我们在本地可以 在执行grunt server 的时候，可以在我们设置的index.html文件中自动引入 angular-locale_zh-cn.js这个文件。 但是问题来了，我们下载的bower_components 文件是被在我们项目里面 ignore的，因此并不能同步到我们 所在的github项目中，对此我们得找出解决方案。 我们在启动项目的时候会自动 执行项目目录下的bower.json 文件，我们可以在项目的bower.json文件中直接复写 我们下载的本地的 bower.json文件。示例： 这样，我们就可以 在启动项目 的时候 自动引入我们下载好的angular-locale_zh-cn.js文件。 当然，这个同样适用于 我们bower所下载的包里面的 bower.json文件中含有”main”的代码的情况，例如我们上图中给出的bootstrap，我们直接在项目的 bower.json文件中 复写就可以了。","raw":null,"content":null,"categories":[{"name":"liuxi","slug":"liuxi","permalink":"http://www.mengyunzhi.cn/categories/liuxi/"}],"tags":[{"name":"Bower","slug":"Bower","permalink":"http://www.mengyunzhi.cn/tags/Bower/"}]},{"title":"how to build SpringMVC application","slug":"how-to-build-springmvc-application","date":"2017-06-20T09:55:28.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/20/how-to-build-springmvc-application/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/20/how-to-build-springmvc-application/","excerpt":"我们使用SpringMVC进行项目的开发后，如何生成可以运行的应用程序，又是该用什么方法启动应用程序为我们服务呢？本篇中，我们将简单进行讲解。\n官方文档还是我们一直说的：我们想到的，大牛们早就做到了！Spring的官方guide中的Building Java Projects with Maven，非常清晰的为我们讲述了如果使用maven构建Java Projects。\n鉴于本文在基本于mvn已经成功安装，并且项目已经成功在idea下进行开发的前提下，我们在此，只给出要点。","text":"我们使用SpringMVC进行项目的开发后，如何生成可以运行的应用程序，又是该用什么方法启动应用程序为我们服务呢？本篇中，我们将简单进行讲解。 官方文档还是我们一直说的：我们想到的，大牛们早就做到了！Spring的官方guide中的Building Java Projects with Maven，非常清晰的为我们讲述了如果使用maven构建Java Projects。 鉴于本文在基本于mvn已经成功安装，并且项目已经成功在idea下进行开发的前提下，我们在此，只给出要点。 清空数据表为了给项目一个干净的初始化环境，也为了加快项目重构时的创建速度，我们首使用navicat删除当前数据库的所有数据表；或是，我们直接删除数据库，然后新建一个同名数据库。 修改配置文件12# 在项目初始化时，重新创建数据表spring.jpa.hibernate.ddl-auto=$&#123;jpa.ddl-auto:create&#125; 将数据表设置为create方式，即在项目启动时，重新创建数据表，并且初始化系统数据. build project使用git bash进行项目文件夹（即存在pom.xml的文件夹）。执行命令：1# mvn package 系统将首先进行mvn test，测试无误后，将自动在./target文件夹中，生成了一个jar文件。该jar文件即为java应用。 如果你想跳过mvn test直接生成.jar文件，可以使用mvn package -DskipTests命令来替换mvn package 启动应用我们进入jar文件所在路径，并使用java命令启动jar文件1# java -jar xxxxx.xxx.jar 此时，应用程序就被我们启动了。 布署到服务器有了jar文件，布署到服务器就简单了。我们可以使用任何方式来将jar文件复制到服务器中。U盘，文件共享，邮件什么都可以。 准备数据库在服务器上启动mysql（可以是xampp这种集成环境，也可以是单独安装的），然后使用navicat创建一个项目使用的数据库（名字要相同）。如果已经有数据库了，可以先删除，然后再创建。 执行jar文件我们在服务器上存放jar文件的路径上启动git bash。然后和我们在本机执行过程一样。1# java -jar xxxxx.xxx.jar 程序就这样被启动了！ 那么如何重新布署呢？在执行上述操作前，我们只需要先关掉上次正在执行的jar程序就可以了。 更改运行参数有时候，我们服务器的运行环境和本地可能会有些出入。比如服务器的数据库的端口不是3306。而是3633。这时候该怎么办呢？我们通过观察程序的配置文件不能发现，有很多${xxx:yyy}的配置信息，这就是为我们自定义配置准备的。其中xxx是配置项，yyy是默认值。 123456789# 在项目初始化时，重新创建数据表spring.jpa.hibernate.ddl-auto=$&#123;jpa.ddl-auto:create&#125;# 指定连接的类型为mysql 连接的地址为：localhost 端口为3306 ，数据为springmvcspring.datasource.url=jdbc:mysql://127.0.0.1:$&#123;datasource.port:3306&#125;/measurement?useUnicode=true&amp;characterEncoding=utf-8# 用户名为rootspring.datasource.username=$&#123;datasource.username:root&#125;# 密码为空spring.datasource.password=$&#123;datasource.password:&#125;server.port=$&#123;port:8080&#125; 比如，我们想将数据库的端口号改为3633，则应该使用:1# java -jar xxx.xxx.jar --datasource.port=3633 再比如，我们想将数据库的端口号改为3633的同时，还想将程序的端口修改为8081则使用：1# java -jar xxx.xxx.jar --datasource.port=3633 --port=8081 总结： 使用mvn package将生成一个jar程序。 使用java -jar xxx.jar来运行一个程序。 为了避免数据表不一致带来的问题，提前清空数据表。 程序运行以前，需要确保mysql服务已启动。 程序运行 = mysql服务运行 + jar应用程序运行。 可以在配置文件中加入${}来在程序启动时自定义配置信息。","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://www.mengyunzhi.cn/tags/SpringMVC/"}]},{"title":"FreeBSD中，重新启动并在后台运行jar文件","slug":"rebuild-jar-file-in-freebsd","date":"2017-06-19T08:06:11.000Z","updated":"2017-12-29T06:58:04.804Z","comments":true,"path":"2017/06/19/rebuild-jar-file-in-freebsd/","link":"","permalink":"http://www.mengyunzhi.cn/2017/06/19/rebuild-jar-file-in-freebsd/","excerpt":"在freebsd中，如果我们以ssh进行登录，直接启动jar文件的话，会发现，当窗口关闭后，运行的程序也被自动终止了。怎么样才能实现当对话关闭后，程序仍将继续运行呢？\n运行程序我们使用mvn package对应用程序进行打包后，后得到一个可以执行的.jar文件，可以在命令行中，使用java -jar来运行该jar文件。在进行后台运行时，需要在最后面加入&amp;，比如:1# java -jar api-0.0.3-SNAPSHOT.jar --datasource.port=3633 &amp;","text":"在freebsd中，如果我们以ssh进行登录，直接启动jar文件的话，会发现，当窗口关闭后，运行的程序也被自动终止了。怎么样才能实现当对话关闭后，程序仍将继续运行呢？ 运行程序我们使用mvn package对应用程序进行打包后，后得到一个可以执行的.jar文件，可以在命令行中，使用java -jar来运行该jar文件。在进行后台运行时，需要在最后面加入&amp;，比如:1# java -jar api-0.0.3-SNAPSHOT.jar --datasource.port=3633 &amp; 终止程序我们知道当运行程序时，可以按ctrl+c来终止程序。那么，如何终止正在后台运行的程序呢？ 找到程序的pid1234567# ps -auxUSER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND...root 90092 0.0 0.1 23572 1200 2- I Tue10AM 0:00.05 _su (csh)root 90366 0.0 0.1 23572 2492 3- I Tue10AM 0:00.02 _su (csh)root 90367 0.0 1.7 653332 35184 3- I Tue10AM 0:02.49 node /usr/local/bin/http-server /mengyunzhi/webapp/8005/dist/ -p 8005root 94194 0.0 15.1 2151736 313104 4- S Wed05PM 9:21.50 /usr/local/openjdk8/bin/java -jar api-0.0.3-SNAPSHOT.jar --datasource.port=3633 我们发现，前面我们在后面执行过的命令的pid为94194 终止pid1# kill -9 94194 总结 将程序设置为后台运行，在窗口关闭时，程序仍然将自动运行。 后台运行的程序，需要使用kill -9来终止进程。 在使用kill -9来终止进行前，需要使用ps -aux来查看所想终止程序的进程号。 如果是nodejs的应用程序呢？比如http-server. 如果是启动nodejs中的程序，比如http-server，则需要使用node中的forever来比如：12# npm install -g forever# forever start `http-server /mengyunzhi/api/8080.Measurement/dist/ -p 8005` &amp;","raw":null,"content":null,"categories":[{"name":"teacherPan","slug":"teacherPan","permalink":"http://www.mengyunzhi.cn/categories/teacherPan/"}],"tags":[{"name":"freebsd","slug":"freebsd","permalink":"http://www.mengyunzhi.cn/tags/freebsd/"},{"name":"backgroud","slug":"backgroud","permalink":"http://www.mengyunzhi.cn/tags/backgroud/"},{"name":"forever","slug":"forever","permalink":"http://www.mengyunzhi.cn/tags/forever/"}]}]}