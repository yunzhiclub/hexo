<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦云智</title>
  
  <subtitle>一起做着靠谱的事情，这就是我们。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mengyunzhi.cn/"/>
  <updated>2017-12-29T06:58:04.832Z</updated>
  <id>http://www.mengyunzhi.cn/</id>
  
  <author>
    <name>梦云智</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.mengyunzhi.cn/2017/12/29/hello-world/"/>
    <id>http://www.mengyunzhi.cn/2017/12/29/hello-world/</id>
    <published>2017-12-29T06:58:04.832Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何启动测量项目</title>
    <link href="http://www.mengyunzhi.cn/2017/12/29/how-to-start-measurement-project/"/>
    <id>http://www.mengyunzhi.cn/2017/12/29/how-to-start-measurement-project/</id>
    <published>2017-12-29T06:08:37.000Z</published>
    <updated>2017-12-29T06:58:05.336Z</updated>
    
    <content type="html"><![CDATA[<p>作为程序开发人员，启动项目是开发的第一步。那么，我们如何才能启动测量项目呢，为什么要这样设计。本篇文章为您简单介绍一下。<br><a id="more"></a> </p><h2 id="如何启动测量项目"><a href="#如何启动测量项目" class="headerlink" title="如何启动测量项目"></a>如何启动测量项目</h2><p>1.拉取最新的开发分支，分别启动<code>GatewayApplication</code>、<code>ResourceApplication</code><br><img src="/2017/12/29/how-to-start-measurement-project/1.png" alt=""><br>2.切换到Webapp目录下，<code>grunt serve</code>启动前台。<br>3.访问： <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><blockquote><p>如果不能正常启动项目，建议idea重新导入项目</p></blockquote><h2 id="原因说明"><a href="#原因说明" class="headerlink" title="原因说明"></a>原因说明</h2><p>我们可以观察到，当我们<code>grunt serve</code>启动前台时，实际上启动的是8083端口，为什么通过8080端口才能访问前台呢？我们访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，实际上是访问<code>GatewayApplication</code>应用程序，<code>Gateway</code>想当于代理的作用，我们观察<code>Gateway</code>的配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ribbon.eureka.enabled=false</span><br><span class="line"># 资源地址</span><br><span class="line">zuul.routes.resource.path=/resource/**</span><br><span class="line"># 不排除任何header信息</span><br><span class="line">zuul.routes.resource.sensitiveHeaders=</span><br><span class="line">zuul.routes.resource.url=$&#123;resource.url:http://localhost:8081&#125;</span><br><span class="line"></span><br><span class="line"># 认证地址(获取accessToken)</span><br><span class="line">zuul.routes.oauthToken.path=/oauth/token</span><br><span class="line"># 携带前缀转发数据</span><br><span class="line">zuul.routes.oauthToken.stripPrefix=false</span><br><span class="line">zuul.routes.oauthToken.sensitiveHeaders=</span><br><span class="line">zuul.routes.oauthToken.url=$&#123;oauth.url:http://localhost:8082&#125;</span><br><span class="line"></span><br><span class="line"># 认证地址(其它)</span><br><span class="line">zuul.routes.oauth.path=/oauth/**</span><br><span class="line"># 携带前缀转发数据</span><br><span class="line">zuul.routes.oauth.url=$&#123;oauth.url:http://localhost:8082&#125;</span><br><span class="line"></span><br><span class="line"># 其它地址</span><br><span class="line">zuul.routes.ui.path=/**</span><br><span class="line">zuul.routes.ui.url=$&#123;ui.url:http://localhost:8083&#125;</span><br><span class="line"></span><br><span class="line">server.port=$&#123;port:8080&#125;</span><br></pre></td></tr></table></figure></p><p>1.首先我们可以从以下代码中看出，<code>Gateway</code>的端口是8080<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=$&#123;port:8080&#125;</span><br></pre></td></tr></table></figure></p><p>2.而当我们访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 时，<code>Gateway</code>把路由转发到了8083端口，所以就访问到了前台界面。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.ui.path=/**</span><br><span class="line">zuul.routes.ui.url=$&#123;ui.url:http://localhost:8083&#125;</span><br></pre></td></tr></table></figure></p><p>3.登陆前台界面，打开网络选项卡<br><img src="/2017/12/29/how-to-start-measurement-project/2.png" alt=""><br>我们可以看到，后台的api信息是以<code>http://localhost:8080/resource/</code>开头的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.resource.path=/resource/**</span><br><span class="line">zuul.routes.resource.url=$&#123;resource.url:http://localhost:8081&#125;</span><br></pre></td></tr></table></figure></p><p>这样，当我们访问的路由是以/resource/开头时，就转发到了8081端口。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过Gateway应用程序，即使在前后台分离的情况下，也可以避免跨域的问题，即：协议、域名、端口号都是一样的。从而提高了用户的安全指数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为程序开发人员，启动项目是开发的第一步。那么，我们如何才能启动测量项目呢，为什么要这样设计。本篇文章为您简单介绍一下。&lt;br&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="SpringMvc" scheme="http://www.mengyunzhi.cn/tags/SpringMvc/"/>
    
      <category term="gateway" scheme="http://www.mengyunzhi.cn/tags/gateway/"/>
    
  </entry>
  
  <entry>
    <title>计量项目前台部分Controller之间的关系</title>
    <link href="http://www.mengyunzhi.cn/2017/11/22/instrument-audit/"/>
    <id>http://www.mengyunzhi.cn/2017/11/22/instrument-audit/</id>
    <published>2017-11-22T09:20:01.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>最简单的编程就是看着图编程。最难维护的项目就是一张图都没有的项目。<br>此文章简介一下自己在修改前台过程中整理的部分功能模块是整理的类图。</p><a id="more"></a><h2 id="类的继承之间的关系"><a href="#类的继承之间的关系" class="headerlink" title="类的继承之间的关系"></a>类的继承之间的关系</h2><p><img src="/2017/11/22/instrument-audit/Class Diagram0.svg" alt=""> </p><p>左边这个分支是查看的功能，右边这个分支是审核的功能。Controller之间的关系基本就是这样的。</p><h2 id="V层和C层之间的图"><a href="#V层和C层之间的图" class="headerlink" title="V层和C层之间的图"></a>V层和C层之间的图</h2><p><img src="/2017/11/22/instrument-audit/c_v.svg" alt=""> </p><p>我想这样更有助于我们理解整个的文件的结构。</p><h2 id="简单的时序图"><a href="#简单的时序图" class="headerlink" title="简单的时序图"></a>简单的时序图</h2><p><img src="/2017/11/22/instrument-audit/c.svg" alt=""> </p><p>这个时序图主要是讲了一下用户在我的工作的时候点击查看按钮发生的事情，调用相应的方法获取获取哪个Controller。然后进获取相应的数据。这只是是一个很粗糙的博客，<strong>想说的就是当我们在查看一个项目代码的时候如果自己不理解一定要自己画图记录代码的流程</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最简单的编程就是看着图编程。最难维护的项目就是一张图都没有的项目。&lt;br&gt;此文章简介一下自己在修改前台过程中整理的部分功能模块是整理的类图。&lt;/p&gt;
    
    </summary>
    
      <category term="gaoliming" scheme="http://www.mengyunzhi.cn/categories/gaoliming/"/>
    
    
  </entry>
  
  <entry>
    <title>java-exception-handling</title>
    <link href="http://www.mengyunzhi.cn/2017/11/20/java-exception-handling/"/>
    <id>http://www.mengyunzhi.cn/2017/11/20/java-exception-handling/</id>
    <published>2017-11-20T13:06:27.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>在开发 程序的过程中，我们可能经常会和异常打交道，那么出现异常时我们应该怎么处理呢，我们一起来学习一下。</p><a id="more"></a><h2 id="基本异常处理"><a href="#基本异常处理" class="headerlink" title="基本异常处理"></a>基本异常处理</h2><p>java提供了在程序中处理某些特定类型条件的方法，能够把程序或方法划分为正常情况或异常情况两部分。异常是一个对象，创建这个对象的过程，也被称为抛出异常。实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void LearnException(int i) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">    if (i &lt; 1)  &#123;</span><br><span class="line">                throw new ArithmeticException(&quot;请传入大于0的整数&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">    int result = 100/i;</span><br><span class="line">&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">    System.out.println(&quot;出现异常了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 从上面这个例子我们可以看出，java处理异常的基本方式有try-throw-catch三元组成。</p><ul><li><p>try语句块。try是尝试的意思，try语句块中的代码通常是你不能百分之百的确定，但是你想进行一次尝试。它的基本轮廓如下；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">    Code_To_Try</span><br><span class="line">    Possibly_Throw_An_Exception</span><br><span class="line">    More_Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throw语句块。上述的例子，也等同与如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArithmeticException arithmeticException = new ArithmeticException(&quot;请传入大于0的整数&quot;);</span><br><span class="line">throw arithmeticException;</span><br></pre></td></tr></table></figure><p>实际上，就是new一个异常对象，然后抛出的过程。当异常被抛出时，该块中的代码停止执行，跳出try语句块。</p></li><li><p>catch语句块。其格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> catch (ArithmeticException e) &#123;</span><br><span class="line">    Handling_Exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识符e就像一个参数，接收刚才抛出的异常，所以e的类型必须等同于抛出的异常类型，否则不能捕获异常。</p></li></ul><h2 id="定义自己的异常类"><a href="#定义自己的异常类" class="headerlink" title="定义自己的异常类"></a>定义自己的异常类</h2><p> 我们也可以自己定义一个异常类，但必须继承已经定义好的异常类的。代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public class DivideByZeroException extends Exception &#123;</span><br><span class="line">    public DivideByZeroException() &#123;</span><br><span class="line">        super(&quot;请传入大于0的整数&quot;);// 调用基类Exception的构造器</span><br><span class="line">    &#125;</span><br><span class="line">    public DivideByZeroException(String message) &#123;</span><br><span class="line">        super(message);// 调用基类Exception的构造器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 调用方法如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">    if (i &lt; 1)  &#123;</span><br><span class="line">        throw new DivideByZeroException();</span><br><span class="line">    &#125;</span><br><span class="line">    int result = 100/i;</span><br><span class="line">&#125; catch (DivideByZeroException e) &#123;</span><br><span class="line">    System.out.println(&quot;出现异常了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 当我们自己定义异常类时，我们需要注意一下三点：</p><ul><li>如果你没有更合理的理由使用其他的异常类作为基类，那么就使用Exception作为基类。</li><li>你定义的异常类至少定义了两个构造器——一个默认构造器，一个拥有String参数的构造器。通常情况下，自己定义的异常类都要保留getMessage方法。</li><li><p>在每一个构造器中，你应该以对基类构造器的调用作为开始，使用super调用。</p><blockquote><p>如果你在写代码时就已经清楚可能会抛出异常，那么最后自己定义一个异常，这样当出现异常时，我们就更容易区分你的异常和预定义类中的异常。</p></blockquote></li></ul><h2 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h2><p> 有时候我们需要延迟处理异常。比如你有一个代码块可能会抛出异常，但你并不想在这个代码块中捕获异常。因为可能某些程序调用该方法抛出异常后应该简单的终止程序，而另一程序调用该方法抛出异常后要做一些其他的处理。所以，当出现类似这种情况时，我们需要在在方法头部声明异常。代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void LearnException(int i) throws DivideByZeroException &#123;</span><br><span class="line">Code_To_Try</span><br><span class="line">throw new DivideByZeroException();</span><br><span class="line">More_Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 如果方法抛出了异常，方法调用立即结束。在方法的首部声明异常的一个好处是，我们可以清楚的区分可能有异常的方法和没有异常的方法，易于阅读。</p><blockquote><p>关键字throw用于抛出异常，throws用于声明异常。</p></blockquote><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>所有的java异常可以分为两类：可控异常，不可控异常。上述的异常属于可控异常，即：异常必须在catch快中捕获或者在方法的首部声明。不可控异常也称为运行时异常（RuntimeException），当出现此类异常时，通常我们应该修正自己的代码，而不是添加catch语句块。</p><h2 id="多重捕获和finally"><a href="#多重捕获和finally" class="headerlink" title="多重捕获和finally"></a>多重捕获和finally</h2><ul><li>多重捕获。一个try语句块可以抛出任意数量的异常，这些异常可以是不同的类型，因为一个catch语句块只能捕获一种异常，所以一个try语句块可以使用多个catch语句块。</li><li>finally关键字 。无论代码是否发生异常，finally中的代码块总会被执行。<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125; catch (DivideByZeroException e1) &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125; catch (IOException) &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2017/11/20/java-exception-handling/102.png" title="层次结构图"><ul><li>我们应该在什么时候抛出异常呢？在 <a href="https://stackoverflow.com/questions/77127/when-to-throw-an-exception" target="_blank" rel="noopener">When to throw an exception?</a> 中，推荐：当发现当前代码块的基本假设是错误时，应该抛出异常。</li><li>对于所有的异常都捕获Exception是否可行？可行但是不推荐。最好catch更为精确的异常。</li><li>在catch语句块中使用<code>e.printStackTrace()</code>是一个好的习惯么？并不推荐使用这种方法，很多情况下，并不能正确的提示代码出错的位置和相关信息。最好使用在控制台打印的方法。</li></ul><blockquote><p>error—错误 ： 是指程序无法处理的错误.比如内存溢出、端口占用、断言错误等。</p></blockquote><p>参考文献：</p><ol><li>《Java程序设计与问题解决》</li><li><a href="http://www.runoob.com/java/java-exceptions.html" target="_blank" rel="noopener">Java 异常处理</a> </li><li><a href="https://stackoverflow.com/questions/77127/when-to-throw-an-exception" target="_blank" rel="noopener">When to throw an exception?</a> </li><li><a href="https://stackoverflow.com/questions/7469316/why-is-exception-printstacktrace-considered-bad-practice" target="_blank" rel="noopener">Why is exception.printStackTrace() considered bad practice?</a> </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发 程序的过程中，我们可能经常会和异常打交道，那么出现异常时我们应该怎么处理呢，我们一起来学习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="java" scheme="http://www.mengyunzhi.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList、LinkedList和HashSet的学习总结</title>
    <link href="http://www.mengyunzhi.cn/2017/11/15/java-dynamic-data-structure/"/>
    <id>http://www.mengyunzhi.cn/2017/11/15/java-dynamic-data-structure/</id>
    <published>2017-11-15T01:00:51.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>java中，一旦程序定义了数组的长度，就不能修改这个数组的长度了。如果我们需要修改数组的长度，我们可以使用ArrayList，以达到改变数组长度的目的。</p><a id="more"></a><h2 id="类ArrayList"><a href="#类ArrayList" class="headerlink" title="类ArrayList"></a>类ArrayList</h2><p>ArrayList的缺点：</p><ul><li>ArrayList比数组的效率低</li><li>ArrayList只能存储对象，不能包含基本类型，比如int、double。</li></ul><p>ArrayList的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList &lt;Base_Type&gt; Variable = new ArrayList&lt;Base_Type&gt;(Capacity);</span><br></pre></td></tr></table></figure></p><p>其中，Base_Type必须为类类型，不能为基本类型。Capacity（容量）表示为这个数据项分配内存空间，如果不传值，默认初始容量为10个数据项。如果初始化给了足够大的初始容量，那么系统就不需要频繁的分配内存了，程序将会运行的更快。反之，如果你吧初始容量弄得太大，就会浪费储存空间。<br>我们对是否分配容量做一个测试，代码实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ListDemo &#123;</span><br><span class="line"></span><br><span class="line">static long timeList(List&lt;String&gt; st) &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">st.add(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return System.currentTimeMillis() - start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main (String args[]) &#123;</span><br><span class="line">System.out.println(&quot;assign capacity ArrayList = &quot;</span><br><span class="line"> + timeList(new ArrayList&lt;String&gt;(100000)));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;default ArrayList = &quot;</span><br><span class="line"> + timeList(new ArrayList&lt;String&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assign capacity ArrayList = 22</span><br><span class="line">default ArrayList = 13</span><br></pre></td></tr></table></figure></p><p>jdk7之前，我们应该这样实例化ArrayList<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></p><p>jdk7开始，我们可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>不仅方便了我们书写，也使代码有更强的可读性。</p><h2 id="类LinkedList"><a href="#类LinkedList" class="headerlink" title="类LinkedList"></a>类LinkedList</h2><p>类LinkedList的基本用法同上，但是LinkedList内部使用双向链表的数据结构，只有在需要时才分配内存，删除元素时随即释放内存。</p><h2 id="类ArrayList和类LinkedList的比较"><a href="#类ArrayList和类LinkedList的比较" class="headerlink" title="类ArrayList和类LinkedList的比较"></a>类ArrayList和类LinkedList的比较</h2><ul><li>类LinkedList插入元素效率高，但访问元素效率低。</li><li>类ArrayList访问元素效率高，但插入效率低。<br>他们的效率相差多少，我们通过实例来了解（仅修改main方法）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String args[]) &#123;</span><br><span class="line">System.out.println(&quot;time for ArrayList = &quot;</span><br><span class="line"> + timeList(new ArrayList&lt;String&gt;()));</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;time for LinkedList = &quot;</span><br><span class="line"> + timeList(new LinkedList&lt;String&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time for ArrayList = 22</span><br><span class="line">time for LinkedList = 13</span><br></pre></td></tr></table></figure></p><p>如果我们指定位置添加元素，将第六行代码<code>st.add(String.valueOf(i));</code>修改为<code>st.add(0, String.valueOf(i));</code><br>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time for ArrayList = 915</span><br><span class="line">time for LinkedList = 11</span><br></pre></td></tr></table></figure></p><p>为什么会差这么多呢，因为每插入一个元素，arraylist都要吧所有的元素都后移，而LinkedList指需要增加一个新的结点，并调整一下对应关系就可以了。<br>我们进行一次新增元素，再进行一次查看元素，他们的效率相差多少呢？将<code>timeList</code>修改为如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static long timeList(List&lt;String&gt; st) &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">st.add(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">st.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return System.currentTimeMillis() - start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time for ArrayList = 17</span><br><span class="line"></span><br><span class="line">time for LinkedList = 156</span><br></pre></td></tr></table></figure></p><p>因此，我们在进行相同次数的查找和添加元素的情况下，ArrayList效率较高。因此，我们使用ArrayList的次数会更多一些。</p><h2 id="Collection-API的层次结构"><a href="#Collection-API的层次结构" class="headerlink" title="Collection API的层次结构"></a>Collection API的层次结构</h2><p>通过上面的学习，我们对动态数据结构有了基本的认识，那么java中关于数组的接口和实现类的层次结构是什么样的呢？如下图：<br><img src="/images/101.png"><br><br>由上图可知，Iterable接口、Collection接口中定义的方法，几个实现类都实现了，只不过他们的具体实现方法会有所差异。同样的，ArrayList和LinkedList都是List接口的实现类，所以他们的方法名都是一样的，但是具体的实现方法有所差异。</p><h2 id="Set接口和List接口"><a href="#Set接口和List接口" class="headerlink" title="Set接口和List接口"></a>Set接口和List接口</h2><p>1.Set对应的中文名是集合，有两个特点：</p><ul><li>不含重复元素</li><li>无序</li></ul><p>2.List接口类似于书续重的序列，也有两个特点：</p><ul><li>可含重复的元素</li><li>有序</li></ul><h2 id="类HashSet"><a href="#类HashSet" class="headerlink" title="类HashSet"></a>类HashSet</h2><p>HashSet继承了Set接口的特性，值得注意的是，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法中使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果。因为new一个HashSet，实际上是new HashMap，并以这个对象的hashCode为key，这个对象本身为value储存。当对象的hashcode改变后，我们可以使用迭代器进行删除的操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;MandatoryInstrument&gt; iterator = mandatoryInstrumentList.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    MandatoryInstrument mandatoryInstrument = iterator.next();</span><br><span class="line">    if (mandatoryInstrument.getCheckDepartment() == null) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>iterator（迭代器）是什么？eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">   st.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，i就是一个迭代器——能够以合理的方式一次访问一个元素、遍历整个数组或者链表的变量。从一个元素走到另一个元素的过程就是是迭代（iterable）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中，一旦程序定义了数组的长度，就不能修改这个数组的长度了。如果我们需要修改数组的长度，我们可以使用ArrayList，以达到改变数组长度的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="java" scheme="http://www.mengyunzhi.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中json和object相互转换</title>
    <link href="http://www.mengyunzhi.cn/2017/10/21/how-to-convert-json-to-from-object-Gson/"/>
    <id>http://www.mengyunzhi.cn/2017/10/21/how-to-convert-json-to-from-object-Gson/</id>
    <published>2017-10-21T13:25:02.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会用到json和oject类型的相互转换，这篇文章记录了通过gson进行object和json的相互转换。</p><a id="more"></a><h2 id="gson-依赖"><a href="#gson-依赖" class="headerlink" title="gson 依赖"></a>gson 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="object转换为json"><a href="#object转换为json" class="headerlink" title="object转换为json"></a>object转换为json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.新建一个对象</span><br><span class="line">FromMessage fromMessage = new FromMessage();</span><br><span class="line">fromMessage.setContent(&quot;test&quot;);</span><br><span class="line">fromMessage.setIsRead(Boolean.FALSE);</span><br><span class="line"></span><br><span class="line">// 2.将对象转化为json字符串</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">String jsonString = gson.toJson(fromMessage);</span><br><span class="line">System.out.println(jsonString);// &#123;&quot;content&quot;:&quot;test&quot;,&quot;isRead&quot;:false&#125;</span><br></pre></td></tr></table></figure><h2 id="json转化为object"><a href="#json转化为object" class="headerlink" title="json转化为object"></a>json转化为object</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new Gson();</span><br><span class="line">String jsonString = &quot;&#123;\&quot;content\&quot;:\&quot;test\&quot;,\&quot;isRead\&quot;:false&#125;&quot;;</span><br><span class="line">FromMessage fromMessage1 = gson.fromJson(jsonString, FromMessage.class);</span><br><span class="line">System.out.println(fromMessage1);  //Message&#123;id=null, content=&apos;test&apos;, title=&apos;null&apos;, isRead=false, fromDepartment=null, toDepartment=null, firstReadTime=null, firstReadUser=null, createUser=null, createTime=null&#125;</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://www.mkyong.com/java/how-do-convert-java-object-to-from-json-format-gson-api/" target="_blank" rel="noopener">How to convert Java object to JSON string</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会用到json和oject类型的相互转换，这篇文章记录了通过gson进行object和json的相互转换。&lt;/p&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="object" scheme="http://www.mengyunzhi.cn/tags/object/"/>
    
      <category term="json" scheme="http://www.mengyunzhi.cn/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>angular和springmvc实现批量删除</title>
    <link href="http://www.mengyunzhi.cn/2017/10/21/angular-spring-batch-delete/"/>
    <id>http://www.mengyunzhi.cn/2017/10/21/angular-spring-batch-delete/</id>
    <published>2017-10-21T13:24:41.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>昨天实现了批量删除的功能，看到了stackoverflow和百度上均有相关的问题，于是决定记录一下。前台angularjs，后台SpringMvc。</p><a id="more"></a><h2 id="checkbox使用"><a href="#checkbox使用" class="headerlink" title="checkbox使用"></a>checkbox使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr ng-repeat=&quot;(key, object) in data.content&quot;&gt;</span><br><span class="line">     &lt;td&gt;&lt;input icheck type=&quot;checkbox&quot; ng-model=&quot;object._checked&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><p>当用户勾选复选框后，对象的_checked属性值为true，我们通过下面这个函数获取勾选的object,可以把这个函数放在公共service中，方便框架的其他地方调用。类似的，我们也可以根据自己的需求，修改_checked属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由某个数组中 筛选中被选中的元素，组成新的数组并返回</span><br><span class="line"> * @param    &#123;array&#125;                 lists 原数组</span><br><span class="line"> * @param    &#123;string&#125;                 key   健值 默认为 _checked</span><br><span class="line"> * @return   &#123;array&#125;                       选中元素组成的数组</span><br><span class="line"> * @author 梦云智 http://www.mengyunzhi.com</span><br><span class="line"> * @DateTime 2017-10-17T15:05:18+0800</span><br><span class="line"> */</span><br><span class="line">self.getCheckedElementsByListsAndKey = function(lists, key) &#123;</span><br><span class="line">    if (typeof(key) === &apos;undefined&apos;) &#123;</span><br><span class="line">        key = &apos;_checked&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var tempList = [];</span><br><span class="line">    angular.forEach(lists, function(list) &#123;</span><br><span class="line">    if (typeof(list[key]) !== &apos;undefined&apos; &amp;&amp; list[key] === true) &#123;</span><br><span class="line">    tempList.push(list);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return tempList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="前后台对接"><a href="#前后台对接" class="headerlink" title="前后台对接"></a>前后台对接</h2><p>前台http请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data =  [1, 3, 4];// 假设要删除id为1,3,4的记录</span><br><span class="line">$http.delete(&apos;/FromMessage/batchDelete/&apos; + data)</span><br><span class="line">.then(function success(response)&#123;</span><br><span class="line">  if (callback) &#123;callback(response.status);&#125;</span><br><span class="line">&#125;, function error(response)&#123;</span><br><span class="line">  alert(&apos;FromMessage.batchDelete error: &apos;, response);</span><br><span class="line">  if (callback) &#123;callback(response.status);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>后台代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ResponseStatus(HttpStatus.NO_CONTENT)</span><br><span class="line">    @DeleteMapping(&quot;/batchDelete/&#123;fromMessageIds&#125;&quot;)</span><br><span class="line">    public void batchDelete(@ApiParam(value = &quot;消息id数组&quot;) @PathVariable List&lt;Integer&gt; fromMessageIds) &#123;</span><br><span class="line">        fromMessageService.batchDelete(fromMessageIds);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>后台接受到的是一个数组。如果把数组放到delete方法的body中，由于不符合api规范，会被tomcat或这spring丢弃，后台就不能正确的接受body信息。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>功能实现后，为了降低代码的维护成本，我们进行单元测试。这里给出示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;模拟请求&quot;);</span><br><span class="line">this.mockMvc.perform(delete(&quot;/FromMessage/batchDelete/&quot; + fromMessage.getId() + &apos;,&apos; + fromMessage1.getId())</span><br><span class="line">.header(&quot;x-auth-token&quot;, xAuthToken))</span><br><span class="line">.andDo(document(&quot;FromMessage_batchDelete&quot;, preprocessResponse(prettyPrint())))</span><br><span class="line">.andExpect(status().is(204));</span><br></pre></td></tr></table></figure></p><p>注意请求的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/FromMessage/batchDelete/2,3</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在进行开发的时候，实现复选框选中、后台接收数组等功能，感觉之前都实现过，但是由于记得不清楚，测试了多次也没能通过，还是及时的google能够节约解决问题的时间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天实现了批量删除的功能，看到了stackoverflow和百度上均有相关的问题，于是决定记录一下。前台angularjs，后台SpringMvc。&lt;/p&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="angularjs" scheme="http://www.mengyunzhi.cn/tags/angularjs/"/>
    
      <category term="SpringMvc" scheme="http://www.mengyunzhi.cn/tags/SpringMvc/"/>
    
  </entry>
  
  <entry>
    <title>angular中使用ng-include后controller中$watch失去作用</title>
    <link href="http://www.mengyunzhi.cn/2017/10/21/includ-watch-angular/"/>
    <id>http://www.mengyunzhi.cn/2017/10/21/includ-watch-angular/</id>
    <published>2017-10-21T10:53:51.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<p>有的时候为了实现代码复用，我们会使用<code>ng-include</code>复用部分代码。</p><a id="more"></a><h2 id="问题简化"><a href="#问题简化" class="headerlink" title="问题简化"></a>问题简化</h2><p><code>about.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;angularTestApp&apos;)</span><br><span class="line">  .controller(&apos;AboutCtrl&apos;, function ($scope) &#123;</span><br><span class="line">      $scope.num = 0;</span><br><span class="line">      $scope.$watch(&quot;num&quot;, function () &#123;</span><br><span class="line">          console.log($scope.num);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>about.html</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is the about view.&lt;/p&gt;</span><br><span class="line">&lt;div ng-include=&quot;&apos;views/include.html&apos;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&#123;&#123;num&#125;&#125;</span><br></pre></td></tr></table></figure></p><p><code>include.html</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; ng-model=&quot;num&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; num &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果我们运行这段代码就会发现一个问题，当我们改变<code>num</code>的值的时候控制台并没有打印<code>num</code>的值。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为我们使用<code>ng-include</code>的时候会会创建一个<code>child scope</code>。然后两个<code>scope</code>的作用域是相互隔离的，所以<code>include.html</code>中的<code>ng-model</code>绑定的是自己的<code>scope</code>, 所以<code>about.js</code>中的<code>num</code>不会发生改变。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>将<code>include.html</code>做如下修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; ng-model=&quot;$parent.num&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; num &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://stackoverflow.com/questions/32775461/ng-model-not-working-inside-ng-include" target="_blank" rel="noopener">ng-model not working inside ng-include</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有的时候为了实现代码复用，我们会使用&lt;code&gt;ng-include&lt;/code&gt;复用部分代码。&lt;/p&gt;
    
    </summary>
    
      <category term="gaoliming" scheme="http://www.mengyunzhi.cn/categories/gaoliming/"/>
    
    
      <category term="angular" scheme="http://www.mengyunzhi.cn/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>如何使用U盘启动的方式更新macos</title>
    <link href="http://www.mengyunzhi.cn/2017/10/20/Create-a-bootable-installer-for-macOS/"/>
    <id>http://www.mengyunzhi.cn/2017/10/20/Create-a-bootable-installer-for-macOS/</id>
    <published>2017-10-20T15:58:32.000Z</published>
    <updated>2017-12-29T06:58:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>苹果系统出现问题，我们往往可以很快的将系统恢复为出厂设置。<br>官方教程： <a href="https://support.apple.com/zh-cn/HT204904" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204904</a></p><p>那么当我们想对原有系统进行升级呢？<br>此时，我们就需要下载macos的新系统，然后采用U盘的形式安装了。</p><a id="more"></a><p>参考官方英文教程： <a href="https://support.apple.com/en-us/HT201372" target="_blank" rel="noopener">https://support.apple.com/en-us/HT201372</a></p><p>简单描述下步骤：</p><h1 id="格式化U盘"><a href="#格式化U盘" class="headerlink" title="格式化U盘"></a>格式化U盘</h1><p>需要注意两点：</p><ol><li>格式应该选择：Mac OS 扩展（日志式）</li><li>名称应该起个简短的，不要有空格。比如起名为：OSX</li></ol><img src="/2017/10/20/Create-a-bootable-installer-for-macOS/2.png" title="说明"><h1 id="将系统写入U盘"><a href="#将系统写入U盘" class="headerlink" title="将系统写入U盘"></a>将系统写入U盘</h1><ol><li>双击下载的dmg文件，并进行安装。</li><li>安装成功后，将在 所有程序 中看到一个名为： 安装 mac os xx</li></ol><img src="/2017/10/20/Create-a-bootable-installer-for-macOS/1.png" title="说明"><ol><li>打开 安装 mac os xx，但不要点继续，就打开放着就可以。</li><li><p>确认自己当前系统的版本<br>点小苹果，关于本机。</p></li><li><p>使用<code>createinstallmedia</code>命令进行U盘写入<br>不同的系统，<code>createinstallmedia</code> 不同，命令也不完全相同，这个需要参考官方文档。</p></li></ol><p>我的方法是，输入<code>/Applications/Install</code>后，按tab键自动补全，然后与官方文档相对应，就能清楚自己的版本号了。</p><ol><li>替换命令中的U盘名称<br>比如我们的起名为OSX, 则将命令中的 /Volumes/MyVolume 换为 /Volumes/OSX</li></ol><p>当然了，你也可以把U盘起名为：MyVolume，这样在输入命令时就不需要变更了。</p><p>示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bogon:Applications apple$ sudo Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/OSX/</span><br><span class="line">Password:</span><br><span class="line">Ready to start.</span><br><span class="line">To <span class="built_in">continue</span> we need to erase the volume at /Volumes/OSX/.</span><br><span class="line">If you wish to <span class="built_in">continue</span> <span class="built_in">type</span> (Y) <span class="keyword">then</span> press <span class="built_in">return</span>: Y</span><br><span class="line">Erasing Disk: 0%... 10%... 20%... 30%...100%...</span><br><span class="line">Copying installer files to disk...</span><br><span class="line">Copy complete.</span><br><span class="line">Making disk bootable...</span><br><span class="line">Copying boot files...</span><br><span class="line">Copy complete.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p><p>然后，我们就可以按<a href="https://support.apple.com/zh-cn/HT204904" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204904</a>的说明来重新安装操作系统了。</p><p><hr><br>以下内容是关于组建<code>funsion driver</code>的<br><code>funsion driver</code> = 一块机器 + 一块SSD。组建容量高速度快的硬盘驱动器。</p><p><hr><br>不更新系统，只是想组建funsion driver，请直接参考官网地址，如下<br><a href="https://support.apple.com/zh-cn/HT207584" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT207584</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果系统出现问题，我们往往可以很快的将系统恢复为出厂设置。&lt;br&gt;官方教程： &lt;a href=&quot;https://support.apple.com/zh-cn/HT204904&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://support.apple.com/zh-cn/HT204904&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么当我们想对原有系统进行升级呢？&lt;br&gt;此时，我们就需要下载macos的新系统，然后采用U盘的形式安装了。&lt;/p&gt;
    
    </summary>
    
      <category term="panjie" scheme="http://www.mengyunzhi.cn/categories/panjie/"/>
    
    
      <category term="macos" scheme="http://www.mengyunzhi.cn/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>review(审阅)pull request的方法</title>
    <link href="http://www.mengyunzhi.cn/2017/10/19/how-to-review-pull-request/"/>
    <id>http://www.mengyunzhi.cn/2017/10/19/how-to-review-pull-request/</id>
    <published>2017-10-19T01:58:11.000Z</published>
    <updated>2017-12-29T06:58:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>在团队开发的过程中，我们需要将自己开发的代码使用<code>pull request</code>的方式提交至<code>github</code>中。本文中，我们给出当我们看到别人提交的代码时，如何快速的来审阅这次代码提交。</p><a id="more"></a><p>首先，假设我们有以下<code>pull request</code>.<br><img src="/2017/10/19/how-to-review-pull-request/1.jpg" title="pullRequest示例"></p><h1 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h1 id="找到提交分支"><a href="#找到提交分支" class="headerlink" title="找到提交分支"></a>找到提交分支</h1><p>如下图，我们查看到，当前的<code>pull request</code>是由<code>reviewPullRequest</code>提交上来的。<br><img src="/2017/10/19/how-to-review-pull-request/2.jpg" title="pullRequest示例"></p><h1 id="切换到提交分支"><a href="#切换到提交分支" class="headerlink" title="切换到提交分支"></a>切换到提交分支</h1><p><hr><br>如果我们正在进行同一项目的开发，那么我们可以先将自己的代码进行<code>commit</code>。</p><p><hr><br>切换至提交<code>pull request</code>的分支<code>reviewPullRequest</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;reviewPullRequest&gt;</span><br></pre></td></tr></table></figure><h1 id="查看效果或是代码"><a href="#查看效果或是代码" class="headerlink" title="查看效果或是代码"></a>查看效果或是代码</h1><p>此时，我们便可以启用本地环境来查看效果了。</p><p>如果我们查看是<code>readme.md</code>文档，那么还可以直接登录<code>github</code>官网，然后在官网上直接切换分支后在线阅览<code>readme.md</code>的效果。</p><img src="/2017/10/19/how-to-review-pull-request/3.jpg" title="pullRequest示例"><p>代码审阅完毕后，我们需要在<code>github</code>中给出审核的意见：</p><img src="/2017/10/19/how-to-review-pull-request/4.jpg" title="pullRequest示例"><p>三种意见：</p><ol><li>Commnet 不同意</li><li>Approve 同意</li><li>Request changes 修改后同意</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在团队开发的过程中，我们需要将自己开发的代码使用&lt;code&gt;pull request&lt;/code&gt;的方式提交至&lt;code&gt;github&lt;/code&gt;中。本文中，我们给出当我们看到别人提交的代码时，如何快速的来审阅这次代码提交。&lt;/p&gt;
    
    </summary>
    
    
      <category term="github" scheme="http://www.mengyunzhi.cn/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>如何启动团队的hexo的博客</title>
    <link href="http://www.mengyunzhi.cn/2017/10/19/how-to-start-team-hexo-bolg/"/>
    <id>http://www.mengyunzhi.cn/2017/10/19/how-to-start-team-hexo-bolg/</id>
    <published>2017-10-19T01:44:17.000Z</published>
    <updated>2017-12-29T06:58:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>本文中，我们将说明，如果在本地配置团队的hexo博客<br>工具准备： <code>nodejs</code>, <code>git</code><br><a id="more"></a></p><h1 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h1><p><code>git clone https://github.com/yunzhiclub/hexo.git hexo</code></p><p>进入项目目录<br><code>cd hexo</code></p><p>新建自己的分支<br><code>git checkout -b &lt;newBranch&gt;</code></p><blockquote><p><code>&lt;abc&gt;</code> 表示此项为必填项，在实际使用中，将abc替换为自己的内容。</p></blockquote><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p><code>npm install</code><br><code>bower install</code></p><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p><code>hexo server</code><br>项目启动后，将在控制台收到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><p>我们可以找开<code>http://localhost:4000/</code>来查看项目，并在控制台中使用<code>Ctrl+C</code>来终止服务。</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p><code>hexo new title</code><br>将新建一篇文章，控制台同时提醒我们新建文章的位置。</p><p>最后，编辑文章，保存，将新的文章添加到git中，并提交<code>pull request</code></p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><img src="https://hexo.io/zh-cn/docs/" alt="https://hexo.io/zh-cn/docs/"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文中，我们将说明，如果在本地配置团队的hexo博客&lt;br&gt;工具准备： &lt;code&gt;nodejs&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="teacherPan" scheme="http://www.mengyunzhi.cn/categories/teacherPan/"/>
    
    
      <category term="hexo" scheme="http://www.mengyunzhi.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>学习hebinate继承映射关系</title>
    <link href="http://www.mengyunzhi.cn/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/"/>
    <id>http://www.mengyunzhi.cn/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/</id>
    <published>2017-10-17T09:18:58.000Z</published>
    <updated>2017-12-29T06:58:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>做计量项目我的消息模块时，消息分为接收消息和发送消息，如果把消息放在一个实体中，当删除发送消息时，对应的接受消息也被删除了，因此决定使用继承的方法。我们通过这个问题学习ＪＰＡ主要的三种映射策略。<br><a id="more"></a></p><h2 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h2><p>假设有三个类animal、cat、dog。cat、dog继承animal类<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/96.png" title="说明"><br>那我们应该通过什么方法生成数据表，生成几张数据表呢，哪种方法最优呢？</p><h2 id="单表继承策略"><a href="#单表继承策略" class="headerlink" title="单表继承策略"></a>单表继承策略</h2><p>单表继承，就是这几个类共用一个数据表。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 继承（策略 = 单表继承）</span><br><span class="line">@DiscriminatorColumn(name = &quot;DB_TYPE&quot;)  // 鉴别的列名为 DB_TYPE，将在数据表中生成该字段，用与区分子表类型</span><br><span class="line">public abstract class Animal implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line">    </span><br><span class="line">    private String age;</span><br><span class="line">    // 省略constructor 、getters、setters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@DiscriminatorValue(&quot;Cat&quot;)</span><br><span class="line">public class Cat extends Animal &#123;</span><br><span class="line">    private String weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@DiscriminatorValue(&quot;Dog&quot;)</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    private String height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成了一张数据表：<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/97.png" title="说明"></p><p>这种方法不仅简单，而且性能也是最优的。因为每个子类使用了@Entity注解，子类的属性都会被映射到Animal表的列中。</p><blockquote><p>这种方法在子类中使用@NotNull注解会被hibernate忽略，因为如果你定义了Dog类的height属性不能为null，但是当保存cat类的数据时，height必然为null。</p></blockquote><h2 id="JOINED策略"><a href="#JOINED策略" class="headerlink" title="JOINED策略"></a>JOINED策略</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy = InheritanceType.JOINED) // 继承（策略 = TABLE_PER_CLASS）</span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)   // 不能使用自动生成主键策略</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    private String height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Cat extends Animal &#123;</span><br><span class="line">    private String weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时生成了三张表<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/100.png" title="说明"><br>我们可以看到dog和cat表中并没有age属性当我们想获取age属性时，我们通过左链接的方式取值。</p><h2 id="TABLE-PER-CLASS策略"><a href="#TABLE-PER-CLASS策略" class="headerlink" title="TABLE_PER_CLASS策略"></a>TABLE_PER_CLASS策略</h2><p>这种策略不能使用自动生成主键的策略，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // 继承（策略 = TABLE_PER_CLASS）</span><br><span class="line">public class Animal &#123;</span><br><span class="line">    @Id</span><br><span class="line">    //@GeneratedValue(strategy = GenerationType.AUTO)   // 不能使用自动生成主键策略</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Cat extends Animal &#123;</span><br><span class="line">    private String weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    private String height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成了三张数据表：<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/98.png" title="说明"><br>如果把Animal改为abstract类，则只会生成两张表<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/99.png" title="说明"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习了以上三种方式，那么我们在什么情况下使用他们呢？</p><ul><li>当父类的属性较多时，我们使用<code>InheritanceType.SINGLE_TABLE</code>策略，已达到最少可为空的列的数量。</li><li>当父类的属性较少，而子类的属性较多时，我们使用<code>InheritanceType.JOINED</code>策略。</li><li>当我们很少对父类进行操作时，我们使用<code>InheritanceType.TABLE_PER_CLASS</code>策略，这种方法倾向于把每一个类对应一个具体的表。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做计量项目我的消息模块时，消息分为接收消息和发送消息，如果把消息放在一个实体中，当删除发送消息时，对应的接受消息也被删除了，因此决定使用继承的方法。我们通过这个问题学习ＪＰＡ主要的三种映射策略。&lt;br&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="JPA" scheme="http://www.mengyunzhi.cn/tags/JPA/"/>
    
      <category term="Hibernate" scheme="http://www.mengyunzhi.cn/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>FreeBSD如何更新freebsd的port tree</title>
    <link href="http://www.mengyunzhi.cn/2017/10/13/how-to-update-port-tree/"/>
    <id>http://www.mengyunzhi.cn/2017/10/13/how-to-update-port-tree/</id>
    <published>2017-10-13T08:26:23.000Z</published>
    <updated>2017-12-29T06:58:04.828Z</updated>
    
    <content type="html"><![CDATA[<p>在使用freebsd系统进行软件安装时，如果该软件发生了安全问题，则freebsd的ports服务器会更新其对应的版本。此时，如果我们的本地服务器未更新到最新的ports，则会提示“该软件发现了安全问题，请更新ports tree后再来安装”的提示。</p><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>比如，我在安装nodejs时，报了以下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">===&gt;  node-8.1.3 has known vulnerabilities:</span><br><span class="line">node-8.1.3 is vulnerable:</span><br><span class="line">node.js -- multiple vulnerabilities</span><br><span class="line">WWW: https://vuxml.FreeBSD.org/freebsd/3eff66c5-66c9-11e7-aa1d-3d2e663cef42.html</span><br><span class="line"></span><br><span class="line">1 problem(s) <span class="keyword">in</span> the installed packages found.</span><br><span class="line">=&gt; Please update your ports tree and try again.</span><br><span class="line">=&gt; Note: Vulnerable ports are marked as such even <span class="keyword">if</span> there is no update available.</span><br><span class="line">=&gt; If you wish to ignore this vulnerability rebuild with <span class="string">'make DISABLE_VULNERABILITIES=yes'</span></span><br></pre></td></tr></table></figure></p><p>我们常说小白，小白只所以白，往往是由于我们发现错误后，根本就不看错误给我的提示，然后就胡乱的进行一通错误的排查。而错误提醒却恰恰是解决这个问题关键。</p><p>是的，我们往往在开发程序时，也会把一些重要的话输出出来，来提醒使用者他那底错在哪了。告别小白，从看错误提示开始.<br><a id="more"></a></p><p>解决的方法，当然是上述的提示进行操作了。</p><blockquote><p>Please update your ports tree and try again =》 请更新你的ports tree后再次尝试。</p></blockquote><h1 id="GOOGLE关键字"><a href="#GOOGLE关键字" class="headerlink" title="GOOGLE关键字"></a>GOOGLE关键字</h1><p>有了上面的错误提示，此时，我们google时，方向就更明确了。我们以freebsd update ports tree来进行搜索。很快，将会获得我们想要的答案。比如，我查询时，获取了以下信息：</p><blockquote><p>Portsnap is the tool we will use to update our ports tree. It is fast, and simple to use. The first time you run portsnap, it needs to download the entire ports tree, which is a download in the tens of megabytes.</p><p><code>portsnap fetch</code><br><code>portsnap extract</code></p><p>Henceforth, anytime you want to update your ports tree, you will only have to run this command:</p><p><code>portsnap fetch update</code></p></blockquote><p>碰到英文如果读不懂的话，就慢点读，找自己认识的单词读，先尝试了解这个文章的大概意思。当然，最重要的还是坚持。如果对比英文水平，应该是大一的水平最强，越往后水平越差。如果你不幸在大一大二期间没有阅读过英文的站点，这时候你选择的不应该是放弃，而是比别人多下一番功夫。</p><p>我简单的译一下上面的英文：</p><blockquote><p>我们可以使用Portsnap这个工具来更新我们的ports tree。Portsnap使用起来即简单又高效。如果你在本服务器上第一次使用Portsnaphe，则需要下载整个ports tree。当然了，下载的东西会很多。以下是首次使用的两个命令。</p><p><code>portsnap fetch</code><br><code>portsnap extract</code></p><p>当下次我们再更新ports tree时，只需要使用以下命令就可以了。</p><p><code>portsnap fetch update</code></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题并不复杂。解决问题的难易取决于英文阅读能力的高低。<br>简单的事情重复做，你就是专家。在平常的学习时，我们离不开使用google查找一些问题。当某个问题你是参考某个英文站点解决的，那么请多花些时间在你刚刚参考的英文页面上，尝试性的翻译大多数的英文单词，来彻底的搞明白这个帮你解决了问题的页面到底说了些什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用freebsd系统进行软件安装时，如果该软件发生了安全问题，则freebsd的ports服务器会更新其对应的版本。此时，如果我们的本地服务器未更新到最新的ports，则会提示“该软件发现了安全问题，请更新ports tree后再来安装”的提示。&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;比如，我在安装nodejs时，报了以下错误：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;===&amp;gt;  node-8.1.3 has known vulnerabilities:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;node-8.1.3 is vulnerable:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;node.js -- multiple vulnerabilities&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WWW: https://vuxml.FreeBSD.org/freebsd/3eff66c5-66c9-11e7-aa1d-3d2e663cef42.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 problem(s) &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; the installed packages found.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt; Please update your ports tree and try again.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt; Note: Vulnerable ports are marked as such even &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; there is no update available.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;=&amp;gt; If you wish to ignore this vulnerability rebuild with &lt;span class=&quot;string&quot;&gt;&#39;make DISABLE_VULNERABILITIES=yes&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们常说小白，小白只所以白，往往是由于我们发现错误后，根本就不看错误给我的提示，然后就胡乱的进行一通错误的排查。而错误提醒却恰恰是解决这个问题关键。&lt;/p&gt;
&lt;p&gt;是的，我们往往在开发程序时，也会把一些重要的话输出出来，来提醒使用者他那底错在哪了。告别小白，从看错误提示开始.&lt;br&gt;
    
    </summary>
    
      <category term="teacherPan" scheme="http://www.mengyunzhi.cn/categories/teacherPan/"/>
    
    
      <category term="freebsd" scheme="http://www.mengyunzhi.cn/tags/freebsd/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC+Angularjs上传图片</title>
    <link href="http://www.mengyunzhi.cn/2017/10/10/SpringMVC-Angularjs-upload-image/"/>
    <id>http://www.mengyunzhi.cn/2017/10/10/SpringMVC-Angularjs-upload-image/</id>
    <published>2017-10-10T07:24:23.000Z</published>
    <updated>2017-12-29T06:58:04.824Z</updated>
    
    <content type="html"><![CDATA[<p>最近，完成了图片上传的功能，中间也遇到了一些问题，本文记录了上传图片的代码段，希望下次开发相同的功能时尽可能的节约时间。环境：后台SpringMvc，前台angularjs，前台插件<a href="https://www.npmjs.com/package/angular-file-upload" target="_blank" rel="noopener">angular-file-upload </a> 。</p><a id="more"></a><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><ul><li>开发顺序：先开发前台，再开发后台。从而避免开发后台的功能后，前台不需要此功能的情况。</li><li>前台开发：我们把图片作为一个指令，以方便在各个模块中的使用。引入angular-file-upload插件。</li><li>后台应该建立图片相关实体，后台获取到图片后，对文件流进行sha1或md5加密，判断如果后台服务器已经存在相同的图片，则不在上传该图片，直接引用之前上传的图片，以节约服务器资源。类似地，删除图片时，也应该判断是否改图片被引用多次，如果被引用多次，则不需要删除服务器中的图片，只删除图片实体中的那一条记录即可。如果用户要删除的图片只被引用一次，则删除图片实体中的记录，并删除服务器中的图片，释放服务器资源。同时，参考<a href="https://spring.io/guides/gs/uploading-files/" target="_blank" rel="noopener">官方文档</a> ，并根据前台需求，完成后台功能代码。<blockquote><p>通过这种方法，如果用户上传较大的文件，且服务器之前已经上传过相同的文件，那么就可以实现秒传，同时节约了服务器的资源。所以，有时我们在一些平台上（如迅雷）上传几百兆或者几个Ｇ的文件，也可秒传，并不是网速很快，而是因为服务器上已经存在相同的文件。</p></blockquote></li><li>给出附件实体实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@ApiModel(value = &quot;Attachment (附件)&quot;, description = &quot;附件&quot;)</span><br><span class="line">public class Attachment implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @ManyToOne</span><br><span class="line">    @ApiModelProperty(&quot;操作用户&quot;)</span><br><span class="line">    private User operator;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;sha1值&quot;)</span><br><span class="line">    private String sha1;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;md5值&quot;)</span><br><span class="line">    private String md5;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件扩展名&quot;)</span><br><span class="line">    private String ext;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件大小&quot;)</span><br><span class="line">    private String size;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件上传时间&quot;)</span><br><span class="line">    private Long createTime;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件更新时间&quot;)</span><br><span class="line">    private Long updateTime;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件名称&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件存储路径&quot;)</span><br><span class="line">    private String savePath;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件存储名称&quot;)</span><br><span class="line">    private String saveName;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;MIME类型&quot;)</span><br><span class="line">    private String MIME;</span><br><span class="line">    // 省略constructor、getters、setters</span><br></pre></td></tr></table></figure></li></ul><h2 id="前台代码"><a href="#前台代码" class="headerlink" title="前台代码"></a>前台代码</h2><p>界面的效果图如下：<br><img src="../94.png"></p><blockquote><p>前台代码放在github上，代码地址：<a href="https://github.com/chuhang123/blog/tree/master/2017/uploadImage" target="_blank" rel="noopener">https://github.com/chuhang123/blog/tree/master/2017/uploadImage</a> 。</p></blockquote><p>在前台代码中，我们需要对图片标题<a href="https://github.com/chuhang123/blog/blob/master/2017/uploadImage/imagetitle.js" target="_blank" rel="noopener">长度过滤</a> ，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 长度为２０</span><br><span class="line">return function (input) &#123;</span><br><span class="line">    var r=/[^\x00-\xff]/g;</span><br><span class="line">    if(input.replace(r,&quot;mm&quot;).length&lt;=20)&#123;return input;&#125;</span><br><span class="line">    var m=Math.floor(20/2);</span><br><span class="line">    for(var i=m;i&lt;input.length;i++)&#123;</span><br><span class="line">        if(input.substr(0,i).replace(r,&quot;mm&quot;).length&gt;=20)&#123;</span><br><span class="line">            return input.substr(0,i)+&quot;...&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return input;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>显示图片的<a href="https://github.com/chuhang123/blog/blob/master/2017/uploadImage/yunzhithumb.js" target="_blank" rel="noopener">缩略图</a> ，并根据项目需求请求后台代码。</p><h2 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h2><p>在后台的附件控制器中建立三个请求借口：删除、上传、图片访问入口。同时参考<a href="https://spring.io/guides/gs/uploading-files/" target="_blank" rel="noopener">官方文档</a> 。</p><p><img src="/images/95.png"></p><ul><li>如上图所示，需要注意４个地方：</li></ul><ol><li>预览图片时，我们要根据图片的保存名称来浏览图片，我们要使用<code>{saveName:.+}</code>获取图片的名称，否则不能正确获取图片的名称。</li><li>参考官方教程浏览图片时，控制台会抛出<code>HttpMessageNotWritableException</code>异常，我们需要设置响应信息的内容类型，就把这个异常给解决了。</li><li>官方文档是把文件流放在响应信息中，但这种方式相当消耗服务器的资源，假设一个图片１Ｍ，有１００个并发请求，那么就要消耗服务器１００Ｍ的内存，那么如果有更多的并发请求，那么就非常消耗资源。所以等项目上线后把开放图片路径，以节约服务器资源。</li><li>上传的图片类型为<code>MultipartFile</code>, 所以前台的请求内容类型应该为<code>Content-Type:multipart/form-data</code>，请求实例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var formData = new FormData();</span><br><span class="line">formData.append(&apos;attachment&apos;, image);</span><br><span class="line"></span><br><span class="line">$http.post(url, formData, &#123;</span><br><span class="line">transformRequest: angular.identity,</span><br><span class="line">headers: &#123;&apos;Content-Type&apos;: undefined&#125;</span><br><span class="line">&#125;)........</span><br></pre></td></tr></table></figure></li></ol><ul><li>设置图片大小上限，在配置文件中增加如下代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设置图片最大为３Ｍ</span><br><span class="line">spring.http.multipart.max-file-size=3072KB　</span><br><span class="line">spring.http.multipart.max-request-size=3072KB</span><br></pre></td></tr></table></figure><ul><li><p>当其他实体和附件相关时，比如强检申请：附件=1：n，因为可能还会有很多实体和附件相关联，因此在强检申请实体中使用@OneToMany单向映射较为合适。为了操作方便，通过使用 @JoinColumn不再建立中间表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@OneToMany</span><br><span class="line"> @JoinColumn(name = &quot;mandatoryInstrumentApply_id&quot;)</span><br></pre></td></tr></table></figure></li><li><p>因为我们需要对MultipartFile类型的文件进行sha1、md5加密，所以这里给出hash加密算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据指定的算法加密文件数据, 返回固定长度的十六进制小写哈希值</span><br><span class="line">     *</span><br><span class="line">     * @param multipartFile 需要加密的文件</span><br><span class="line">     * @param algorithm 加密算法, 例如: MD5, SHA-1, SHA-256, SHA-512 等</span><br><span class="line">     */</span><br><span class="line">    static String encrypt(MultipartFile multipartFile, String algorithm) throws Exception &#123;</span><br><span class="line">        InputStream in = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 1. 根据算法名称获实现了算法的加密实例</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance(algorithm);</span><br><span class="line"></span><br><span class="line">            in = multipartFile.getInputStream();</span><br><span class="line">            byte[] buf = new byte[1024];</span><br><span class="line">            int len = -1;</span><br><span class="line">            while ((len = in.read(buf)) != -1) &#123;</span><br><span class="line">                // 2. 文件数据通常比较大, 使用 update() 方法逐步添加</span><br><span class="line">                digest.update(buf, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 3. 计算数据的哈希值, 添加完数据后 digest() 方法只能被调用一次</span><br><span class="line">            byte[] cipher = digest.digest();</span><br><span class="line"></span><br><span class="line">            // 4. 将结果转换为十六进制小写</span><br><span class="line">            return bytesToString(cipher);</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // nothing</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将字节转为字符串</span><br><span class="line">    static String bytesToString(byte[] bytes) &#123;</span><br><span class="line">        if (bytes == null || bytes.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(HEXES[(b &gt;&gt; 4) &amp; 0x0F]);</span><br><span class="line">            stringBuilder.append(HEXES[b &amp; 0x0F]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 十六进制字符数组</span><br><span class="line">    static char[] HEXES = &#123;</span><br><span class="line">            &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;,</span><br><span class="line">            &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;,</span><br><span class="line">            &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;,</span><br><span class="line">            &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次附件上传花费了较长的时间，一方面水平不够，一方面有些追求完美，从而耽误了时间，所以完成任务是第一位的，切忌追求完美。望以后注意。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，完成了图片上传的功能，中间也遇到了一些问题，本文记录了上传图片的代码段，希望下次开发相同的功能时尽可能的节约时间。环境：后台SpringMvc，前台angularjs，前台插件&lt;a href=&quot;https://www.npmjs.com/package/angular-file-upload&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;angular-file-upload &lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="SpringMVC" scheme="http://www.mengyunzhi.cn/tags/SpringMVC/"/>
    
      <category term="angular" scheme="http://www.mengyunzhi.cn/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>学习JPA的@OneToMany注解</title>
    <link href="http://www.mengyunzhi.cn/2017/10/09/Learning-JPA-OneToMany/"/>
    <id>http://www.mengyunzhi.cn/2017/10/09/Learning-JPA-OneToMany/</id>
    <published>2017-10-09T07:05:43.000Z</published>
    <updated>2017-12-29T06:58:04.824Z</updated>
    
    <content type="html"><![CDATA[<p>在JPA中，最常用的关系大概就是一对多了。假设实体A、B的关系为A:B=1:n，通常情况下，我们会在B实体中使用@ManyToOne的注解。但是有时我们需要在A实体中使用@OneToMany的注解，那么我们应该怎么办呢？</p><blockquote><p>以下代码中，假设实体One和Many的关系为One:Many=1:n</p></blockquote><h2 id="单向映射-OneToMany"><a href="#单向映射-OneToMany" class="headerlink" title="单向映射@OneToMany"></a>单向映射@OneToMany</h2><p>我们只在One实体中使用注解，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class One &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    @OneToMany</span><br><span class="line">    private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();</span><br><span class="line">    // 省略构造函数，getters and setters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Many &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的数据表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [springmvc]&gt; select * from one;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from many;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from one_manys;</span><br><span class="line">+--------+----------+</span><br><span class="line">| one_id | manys_id |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        1 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><ul><li>现在，我们如果想要在中间表中存一条记录，就必须先要保证many实体中存在一条记录，然后保存one对象时设置和many的关联关系？代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;新建One实体&quot;);</span><br><span class="line">One one = new One();</span><br><span class="line"></span><br><span class="line">logger.info(&quot;新建并保存Many实体&quot;);</span><br><span class="line">Many many = new Many(&quot;test&quot;);</span><br><span class="line">manyRepository.save(many);// 能不能省略这行代码呢？</span><br><span class="line"></span><br><span class="line">logger.info(&quot;保存&quot;);</span><br><span class="line">List&lt;Many&gt; manies = new ArrayList&lt;&gt;();</span><br><span class="line">manies.add(many);</span><br><span class="line">one.setManys(manies);</span><br><span class="line">oneRepository.save(one);</span><br></pre></td></tr></table></figure></li></ul><p>我们能不能省略<code>manyRepository.save(many);</code>，答案是可以的。直接在One实体中的@OneToMany注解后面加入括号(cascade = CascadeType.ALL, orphanRemoval = true)，JPA仍然会自动保存many实体。</p><ul><li>此时，如果我们把Many实体表中id为1的记录删除，会报一个外键约束的错误，我们需要先把one_manys表中的记录删除，才可以删除Many实体表中id为1的记录。这样是不是有点麻烦呢？有没有办法直接删除Many实体中的记录呢？我们在One实体中增加一个注解@JoinColumn就可以了，代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class One &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    @OneToMany</span><br><span class="line">    @JoinColumn(name = &quot;many_id&quot;)</span><br><span class="line">    private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据表的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [springmvc]&gt; select * from one;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from many;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | many_id |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | test |       1 |</span><br><span class="line">+----+------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from one_manys;</span><br><span class="line">ERROR 1146 (42S02): Table &apos;springmvc.one_manys&apos; doesn&apos;t exist</span><br></pre></td></tr></table></figure></p><p>这样就不会增加中间表了，此时我们可以直接删除many实体中的记录了。</p><h2 id="双向映射-OneToMany"><a href="#双向映射-OneToMany" class="headerlink" title="双向映射@OneToMany"></a>双向映射@OneToMany</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Many &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @ManyToOne</span><br><span class="line">    private One one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class One &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    @OneToMany</span><br><span class="line">    private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的数据表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [springmvc]&gt; select * from one_manys;</span><br><span class="line">+--------+----------+</span><br><span class="line">| one_id | manys_id |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        1 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from many;</span><br><span class="line">+----+------+--------+</span><br><span class="line">| id | name | one_id |</span><br><span class="line">+----+------+--------+</span><br><span class="line">|  1 | test |      1 |</span><br><span class="line">+----+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from one;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们经常会用到实体间的关系，但是往往在实际的项目中，由于项目过于庞大，增加了学习成本。因此，比较好的学习方法就是在一个测试的项目中学习，减少学习成本。</p><p>参考链接：<br><a href="https://vladmihalcea.com/2017/03/29/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/" target="_blank" rel="noopener">The best way to map a @OneToMany relationship with JPA and Hibernate</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JPA中，最常用的关系大概就是一对多了。假设实体A、B的关系为A:B=1:n，通常情况下，我们会在B实体中使用@ManyToOne的注解。但是有时我们需要在A实体中使用@OneToMany的注解，那么我们应该怎么办呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下代码中，
      
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="JPA" scheme="http://www.mengyunzhi.cn/tags/JPA/"/>
    
      <category term="Hibernate" scheme="http://www.mengyunzhi.cn/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>js的浅拷贝和深拷贝学习</title>
    <link href="http://www.mengyunzhi.cn/2017/10/08/js-deep-copy-and-shallow-copy/"/>
    <id>http://www.mengyunzhi.cn/2017/10/08/js-deep-copy-and-shallow-copy/</id>
    <published>2017-10-08T08:31:00.000Z</published>
    <updated>2017-12-29T06:58:04.824Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目时，发现把A赋值给B，当我改变B时，A也随之改变了。google了一下，了解到在js中，当一个变量复制另一个变量时，其实复制的是一个地址，改变其中一个变量，另一个也会随之改变。</p><p>这种复制分两种情况：拷贝引用（浅拷贝）和拷贝实例（深拷贝）<br><a id="more"></a></p><h2 id="浅copy"><a href="#浅copy" class="headerlink" title="浅copy"></a>浅copy</h2><ul><li><p>拷贝原对象的引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;a: 1&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">console.log(o1 === o2);  // =&gt;true</span><br><span class="line">o2.a = 2; </span><br><span class="line">console.log(o1.a); // =&gt; 2</span><br></pre></td></tr></table></figure></li><li><p>拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o1 = [&apos;darko&apos;, &#123;age: 22&#125;];</span><br><span class="line">var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的浅拷贝对象</span><br><span class="line"></span><br><span class="line">console.log(o1 === o2); // =&gt; false，说明o2拷贝的是o1的一个实例</span><br><span class="line"></span><br><span class="line">o2[0] = &apos;lee&apos;;</span><br><span class="line">console.log(o1[0]); // =&gt; &quot;darko&quot; o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响</span><br><span class="line"></span><br><span class="line">o2[1].age = 23;</span><br><span class="line">console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响</span><br></pre></td></tr></table></figure></li></ul><p>浅copy实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function shallowClone(source) &#123;</span><br><span class="line">    if (!source || typeof source !== &apos;object&apos;) &#123;</span><br><span class="line">        throw new Error(&apos;error arguments&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var targetObj = source.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    for (var keys in source) &#123;</span><br><span class="line">        if (source.hasOwnProperty(keys)) &#123;</span><br><span class="line">            targetObj[keys] = source[keys];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="深copy"><a href="#深copy" class="headerlink" title="深copy"></a>深copy</h2><p>深copy有两种方法</p><ul><li>使用JSON.stringify和JSON.parse。<br><code>JSON.parse(JSON.stringify(object))</code>。这种方法只能copy对象的属性，不能copy对象的方法。</li><li>使用递归的方法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(source)&#123;</span><br><span class="line">   if(!source || typeof source !== &apos;object&apos;)&#123;</span><br><span class="line">     throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">   var targetObj = source.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">   for(var keys in source)&#123;</span><br><span class="line">      if(source.hasOwnProperty(keys))&#123;</span><br><span class="line">         if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123;</span><br><span class="line">           targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">           targetObj[keys] = deepClone(source[keys]);</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">           targetObj[keys] = source[keys];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考链接：</p><ol><li><a href="https://segmentfault.com/a/1190000008637489" target="_blank" rel="noopener">JavaScript中的浅拷贝和深拷贝</a> </li><li><a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">javascript中的深拷贝和浅拷贝？</a> </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做项目时，发现把A赋值给B，当我改变B时，A也随之改变了。google了一下，了解到在js中，当一个变量复制另一个变量时，其实复制的是一个地址，改变其中一个变量，另一个也会随之改变。&lt;/p&gt;
&lt;p&gt;这种复制分两种情况：拷贝引用（浅拷贝）和拷贝实例（深拷贝）&lt;br&gt;
    
    </summary>
    
      <category term="chuhang" scheme="http://www.mengyunzhi.cn/categories/chuhang/"/>
    
    
      <category term="js" scheme="http://www.mengyunzhi.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>多关键字实体的更新方法</title>
    <link href="http://www.mengyunzhi.cn/2017/09/30/how-to-update-entity-of-multiple-key/"/>
    <id>http://www.mengyunzhi.cn/2017/09/30/how-to-update-entity-of-multiple-key/</id>
    <published>2017-09-30T00:31:44.000Z</published>
    <updated>2017-12-29T06:58:04.824Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们有以下实体，该实体共有4个属性，其中有2个属性组成了组合主键。</p><img src="/2017/09/30/how-to-update-entity-of-multiple-key/1.png" title="ER图"><p>下面，简单阐述下如何正确的实现对上述实体类型的更新操作。<br><a id="more"></a></p><h1 id="操作习惯"><a href="#操作习惯" class="headerlink" title="操作习惯"></a>操作习惯</h1><p>在进行更新时，按以往的方法，我们只需要设置好这个实体的主键，然后调用<code>save</code>方法，就可以了。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(DeviceInstrument deviceInstrument)</span> </span>&#123;</span><br><span class="line">    deviceInstrumentRepository.save(deviceInstrument);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：失败。</p><h1 id="有则更新，无则插入"><a href="#有则更新，无则插入" class="headerlink" title="有则更新，无则插入"></a>有则更新，无则插入</h1><p>那么我们换种思路：<br>造成前面的方法失效的原因：可能是<code>SpringMVC</code>在进行<code>save</code>操作时，不能够区分是插入还是更新。</p><p>解决方法：在进行数据保存前，先查找是否有历史记录。如果有，执行更新操作；没有，则执行插入操作。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(DeviceInstrument deviceInstrument)</span> </span>&#123;</span><br><span class="line">    DeviceInstrument oldDeviceInstrument = deviceInstrumentRepository.findOne(deviceInstrument.getId());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == oldDeviceInstrument) &#123;</span><br><span class="line">        logger.info(<span class="string">"新记录，保存"</span>);</span><br><span class="line">        deviceInstrumentRepository.save(deviceInstrument);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"老记录，更新"</span>);</span><br><span class="line">        oldDeviceInstrument.setAccuracy(deviceInstrument.getAccuracy());</span><br><span class="line">        oldDeviceInstrument.setMeasureScale(deviceInstrument.getMeasureScale());</span><br><span class="line">        deviceInstrumentRepository.save(oldDeviceInstrument);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对此，我也写了单元测试，单元测试显示成功的更新了数据。但是，正常调用过程中，数据表的数据仍然未改变。我猜想可能是由于<code>SpringMVC</code>的缓存机制，数据没有成功更新吧。看来还需要进一步对单元测试与<code>SpringMVC</code>的<code>JPA</code>加强学习。</p><h1 id="先删除，再插入"><a href="#先删除，再插入" class="headerlink" title="先删除，再插入"></a>先删除，再插入</h1><p>通过前面尝试，我猜想可能是多主键时，<code>udpate</code>并没有起作用，也就是说，想使用<code>update</code>的方法来直接更新实体信息这个思路是错误的。</p><p>解决方法：先删除原有的记录，然后再插入一条新的记录。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(DeviceInstrument deviceInstrument)</span> </span>&#123;</span><br><span class="line">    DeviceInstrument oldDeviceInstrument = deviceInstrumentRepository.findOne(deviceInstrument.getId());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != oldDeviceInstrument) &#123;</span><br><span class="line">        logger.info(<span class="string">"老记录，先删除原记录"</span>);</span><br><span class="line">        deviceInstrumentRepository.delete(oldDeviceInstrument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deviceInstrumentRepository.save(deviceInstrument);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是单元测试还是生产环境，上述代码都得到了期待的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在多主键表中，我们需要使用先删除再插入的方法来实现更新操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设我们有以下实体，该实体共有4个属性，其中有2个属性组成了组合主键。&lt;/p&gt;
&lt;img src=&quot;/2017/09/30/how-to-update-entity-of-multiple-key/1.png&quot; title=&quot;ER图&quot;&gt;
&lt;p&gt;下面，简单阐述下如何正确的实现对上述实体类型的更新操作。&lt;br&gt;
    
    </summary>
    
      <category term="teacherPan" scheme="http://www.mengyunzhi.cn/categories/teacherPan/"/>
    
    
      <category term="SpringMVC" scheme="http://www.mengyunzhi.cn/tags/SpringMVC/"/>
    
      <category term="JPA" scheme="http://www.mengyunzhi.cn/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>在angularjs中，设置元素不可见替代隐藏元素的方法</title>
    <link href="http://www.mengyunzhi.cn/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/"/>
    <id>http://www.mengyunzhi.cn/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/</id>
    <published>2017-09-28T05:33:34.000Z</published>
    <updated>2017-12-29T06:58:04.824Z</updated>
    
    <content type="html"><![CDATA[<p>在AngularJS中，我们都知道使用<code>ng-hide</code>来隐藏元素。但有时候，我们需要的却是元素不可见。</p><p>此时，我们需要使用<code>ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;</code>来代替<code>ng-hide=&quot;express&quot;</code>。其中，<code>express</code>为变量或是表达式。</p><p>元素不可见与元素隐藏有什么关系呢？</p><p>在<code>CSS</code>中:<br>隐藏元素 = <code>display: none</code><br>元素不可见 = <code>visibility: hidden</code></p><p>下面，我们通过下面的小例子，来看看具体他们的区别，以及元素不可见的应用场景。<br><a id="more"></a></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>在计量的项目中，我们需要对精确度进行排序，假设现在效果如下：</p><img src="/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/1.gif" title="排序示例图"><p>点击上、下图标时，可以改变精确度的顺序。</p><h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>我们的实际需求是这样的：</p><img src="/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/1.png" title="实际想要的效果"><p>即，使用<code>visibility: hidden</code>，不显示（同时，仍然占有原来的位置）第一条的“向上箭头”，不显示（同时，仍然占有原来的位置）最后一条的“向下箭头”。<br>代码段为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng-style="&#123;'visibility': $last ? 'hidden' : 'visible'&#125;"</span><br></pre></td></tr></table></figure></p><p>其中，<code>$last</code>为变量或是表达式。</p><h1 id="ng-hide"><a href="#ng-hide" class="headerlink" title="ng-hide"></a>ng-hide</h1><p>我们将第一条的<code>visibility: hidden</code>，更改为<code>ng-hide</code><br>修改前：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">ng-style</span>=<span class="string">"&#123;'visibility': $first ? 'hidden' : 'visible'&#125;"</span> <span class="attr">ng-click</span>=<span class="string">"upAccuracy(data)"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-caret-square-o-up text-success"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&amp;nbsp;</span><br></pre></td></tr></table></figure></p><p>修改后：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">ng-hide</span>=<span class="string">"$first"</span> <span class="attr">ng-click</span>=<span class="string">"upAccuracy(data)"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-caret-square-o-up text-success"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&amp;nbsp;</span><br></pre></td></tr></table></figure></p><p>修改后效果：</p><img src="/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/2.png" title="bug效果"><p>我们看到，通过<code>ng-hide</code>后，后面的元素视为该元素不存在，所以占用了隐藏元素原来的位置。而使用<code>ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;</code>后，虽然其隐藏掉了，但后面的元素依然视该元素存在。近而保持了格式的统一。</p><p>参考：<a href="https://stackoverflow.com/questions/26927585/visibility-hidden-in-angularjs" target="_blank" rel="noopener">https://stackoverflow.com/questions/26927585/visibility-hidden-in-angularjs</a></p><p>google关键字：<code>ng-hide visibility hidden</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在AngularJS中，我们都知道使用&lt;code&gt;ng-hide&lt;/code&gt;来隐藏元素。但有时候，我们需要的却是元素不可见。&lt;/p&gt;
&lt;p&gt;此时，我们需要使用&lt;code&gt;ng-style=&amp;quot;{&amp;#39;visibility&amp;#39;: express ? &amp;#39;hidden&amp;#39; : &amp;#39;visible&amp;#39;}&amp;quot;&lt;/code&gt;来代替&lt;code&gt;ng-hide=&amp;quot;express&amp;quot;&lt;/code&gt;。其中，&lt;code&gt;express&lt;/code&gt;为变量或是表达式。&lt;/p&gt;
&lt;p&gt;元素不可见与元素隐藏有什么关系呢？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;CSS&lt;/code&gt;中:&lt;br&gt;隐藏元素 = &lt;code&gt;display: none&lt;/code&gt;&lt;br&gt;元素不可见 = &lt;code&gt;visibility: hidden&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面，我们通过下面的小例子，来看看具体他们的区别，以及元素不可见的应用场景。&lt;br&gt;
    
    </summary>
    
      <category term="teacherPan" scheme="http://www.mengyunzhi.cn/categories/teacherPan/"/>
    
    
      <category term="AngularJS" scheme="http://www.mengyunzhi.cn/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>统计实验数据的步骤</title>
    <link href="http://www.mengyunzhi.cn/2017/09/28/The-steps-of-laboratory-data-statistics-data/"/>
    <id>http://www.mengyunzhi.cn/2017/09/28/The-steps-of-laboratory-data-statistics-data/</id>
    <published>2017-09-28T03:01:34.000Z</published>
    <updated>2017-12-29T06:58:04.824Z</updated>
    
    <content type="html"><![CDATA[<p>本年一次的数据统计总是耗费过多的时间，现将统计步骤总结如下：<br><a id="more"></a></p><h1 id="安装统计软件"><a href="#安装统计软件" class="headerlink" title="安装统计软件"></a>安装统计软件</h1><p>该软件建议安装在win7上。<br>进行QQ邮箱，查找关键字：实验室统计软件及数据。<br>下载相关的软件及往年的数据。安装后，将往年的数据解压到安装软件对应的数据的位置上。</p><p>注意：如果软件进行重新安装，那么卸载后，还需要手工删除原来的程序文件夹，否则在安装过程中，不提示使用钥匙盘，将报错。</p><h1 id="较验历史数据"><a href="#较验历史数据" class="headerlink" title="较验历史数据"></a>较验历史数据</h1><p>当使用新库（教务处给的），替换掉原来的老库时，需要对数据较验。发现较验错误后，查看是否为新库的字段与老库不一致造成了问题，如果出现该问题，则需要在数据维护时注意。</p><h1 id="获取实验数据"><a href="#获取实验数据" class="headerlink" title="获取实验数据"></a>获取实验数据</h1><p>找到本学年所有实验室1-16周的实验数据，并整理到A4纸上。统计的格式如下：</p><p>课程名称 实验教师 上课班级 上课总人数 实验室</p><h1 id="获取班级人数"><a href="#获取班级人数" class="headerlink" title="获取班级人数"></a>获取班级人数</h1><p>班级人数可以找楼下教学秘书获取，也可以查看年末的监考信息，在监考信息中，有每个班级的人数。计算后，补充到整理的A4纸上，以备录入。</p><h1 id="数据录入"><a href="#数据录入" class="headerlink" title="数据录入"></a>数据录入</h1><p>如果有新教师加入，需要先进行教师管理，维护新的教师信息。</p><p>修改本学年的实验数据，除需要保证所有的 <code>*</code> 的字段都正确以外，还需要选择任课教师，填写上课班级。<br>注意：同一门课程可以合并。</p><p>建议安装VF软件，统一删除上学年有，而本学年没有数据。在软件中，逐条删除设置的不合理。</p><p>删除完不该存在历史数据后，添加新的数据。</p><p>如果是新课程，则需要先维护课程名以及课程对应的多个实验名。该信息，需要参考教学计划，教学计划找主老师协助。</p><h1 id="较验数据"><a href="#较验数据" class="headerlink" title="较验数据"></a>较验数据</h1><p>数据填写完毕后，点击数据较验，较验系统数据。正常来讲，如果开始较难过数据，就已经早早的发现基本库发生的变化，在填写数据时，肯定也已经注意到了。所以此时的较验压力会小很多。</p><h1 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h1><p>点击 系统维护 数据备份 选择所有的数据进行备份，然后进行备份文件夹，打包发给教务处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本年一次的数据统计总是耗费过多的时间，现将统计步骤总结如下：&lt;br&gt;
    
    </summary>
    
      <category term="teacherPan" scheme="http://www.mengyunzhi.cn/categories/teacherPan/"/>
    
    
      <category term="tute" scheme="http://www.mengyunzhi.cn/tags/tute/"/>
    
  </entry>
  
  <entry>
    <title>如何在本地使用hexo发表文章</title>
    <link href="http://www.mengyunzhi.cn/2017/09/28/how-to-use-hexo-in-local/"/>
    <id>http://www.mengyunzhi.cn/2017/09/28/how-to-use-hexo-in-local/</id>
    <published>2017-09-28T00:57:14.000Z</published>
    <updated>2017-12-29T06:58:04.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p><code>hexo</code>是nodejs下的一个小软件，我们需要使用npm进行安装.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p><code>hexo</code>在创建新项目时，会使用<code>git</code>命令。如果你是新队员，那么在安装<code>hexo-cli</code>前，还需要安装<code>github</code>或<code>git</code>。</p></blockquote><h1 id="clone团队项目"><a href="#clone团队项目" class="headerlink" title="clone团队项目"></a>clone团队项目</h1><p>项目地址： <code>https://github.com/yunzhiclub/hexo</code><br>clone后，使用命令行，进入所在文件夹。进行<code>npm</code>依赖安装：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>clone主题<br>团队blog的主题在原第三方主题的基础上，进行了个性化的设置。设置后的内容上传到了团队的仓库中，当前团队应用的主题为：hext(具体可以查看根目录下的.travis.yml文件)。<br>我们依然在项目的根目录下，执行以下命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/mengyunzhi/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>操作后，你将在<code>themes</code>文件夹上得到一个<code>next</code>文件夹，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── source</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   ├── categories</span><br><span class="line">│   ├── images</span><br><span class="line">│   └── tags</span><br><span class="line">└── themes</span><br><span class="line">    └── next</span><br></pre></td></tr></table></figure></p><h1 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h1><p>在项目master分支的基础上，新建自己的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b yourBranchName(替换为你分支的名字，比如xiaoming)</span><br></pre></td></tr></table></figure></p><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>项目启动后，我们便可以在浏览器中打开<code>http://localhost:4000/</code>来实时阅览项目了。</p><h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;new title&quot;</span><br></pre></td></tr></table></figure><p>这里标题尽量使用英文。命令成功执行后，将在<code>source/_posts</code>下生成新的文章。</p><p>比如：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: new title</span><br><span class="line">date: 2017-05-31 16:57:35</span><br><span class="line">tags: </span><br><span class="line">category: </span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><blockquote><p>这里，我们尽量的采用英文的名称先进行命名，因为它会自动我们生成文件名。在文件名中保证不出现中文，是个好个习惯。</p></blockquote><p>然后：我们将这里的<code>title</code>修改为中文。<code>tags</code>是标签，如果是多个，可以这样写:<code>[html,css]</code>。<br><code>category</code>类别，这里写上自己的名字。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 如何在本地使用hexo发表文章</span><br><span class="line">date: 2017-05-31 16:57:35</span><br><span class="line">tags: hexo</span><br><span class="line">category: teacherPan</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>最后，就是我们使用markdown语言进行BLOG的写作了。</p><p>内容完成后，像我们参与其它的团队项目的开发一样，进行<code>pull request</code>。代码审核后，你的文章将自动的出现在<a href="http://www.mengyunzhi.cn">http://www.mengyunzhi.cn</a>中.</p><hr><p>更多内容请参考 ：<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">https://hexo.io/docs/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h1&gt;&lt;p&gt;&lt;code&gt;hexo&lt;/code&gt;是nodejs下的一个小软件，我们需要使用npm进行安装.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;hexo&lt;/code&gt;在创建新项目时，会使用&lt;code&gt;git&lt;/code&gt;命令。如果你是新队员，那么在安装&lt;code&gt;hexo-cli&lt;/code&gt;前，还需要安装&lt;code&gt;github&lt;/code&gt;或&lt;code&gt;git&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;clone团队项目&quot;&gt;&lt;a href=&quot;#clone团队项目&quot; class=&quot;headerlink&quot; title=&quot;clone团队项目&quot;&gt;&lt;/a&gt;clone团队项目&lt;/h1&gt;&lt;p&gt;项目地址： &lt;code&gt;https://github.com/yunzhiclub/hexo&lt;/code&gt;&lt;br&gt;clone后，使用命令行，进入所在文件夹。进行&lt;code&gt;npm&lt;/code&gt;依赖安装：&lt;/p&gt;
    
    </summary>
    
      <category term="teacherPan" scheme="http://www.mengyunzhi.cn/categories/teacherPan/"/>
    
    
      <category term="hexo" scheme="http://www.mengyunzhi.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
