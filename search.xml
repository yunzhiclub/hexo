<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/12/29/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何启动测量项目]]></title>
      <url>/2017/12/29/how-to-start-measurement-project/</url>
      <content type="html"><![CDATA[<p>作为程序开发人员，启动项目是开发的第一步。那么，我们如何才能启动测量项目呢，为什么要这样设计。本篇文章为您简单介绍一下。<br><a id="more"></a> </p>
<h2 id="如何启动测量项目"><a href="#如何启动测量项目" class="headerlink" title="如何启动测量项目"></a>如何启动测量项目</h2><p>1.拉取最新的开发分支，分别启动<code>GatewayApplication</code>、<code>ResourceApplication</code><br><img src="/2017/12/29/how-to-start-measurement-project/1.png" alt=""><br>2.切换到Webapp目录下，<code>grunt serve</code>启动前台。<br>3.访问： <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>
<blockquote>
<p>如果不能正常启动项目，建议idea重新导入项目</p>
</blockquote>
<h2 id="原因说明"><a href="#原因说明" class="headerlink" title="原因说明"></a>原因说明</h2><p>我们可以观察到，当我们<code>grunt serve</code>启动前台时，实际上启动的是8083端口，为什么通过8080端口才能访问前台呢？我们访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> ，实际上是访问<code>GatewayApplication</code>应用程序，<code>Gateway</code>想当于代理的作用，我们观察<code>Gateway</code>的配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ribbon.eureka.enabled=false</span><br><span class="line"># 资源地址</span><br><span class="line">zuul.routes.resource.path=/resource/**</span><br><span class="line"># 不排除任何header信息</span><br><span class="line">zuul.routes.resource.sensitiveHeaders=</span><br><span class="line">zuul.routes.resource.url=$&#123;resource.url:http://localhost:8081&#125;</span><br><span class="line"></span><br><span class="line"># 认证地址(获取accessToken)</span><br><span class="line">zuul.routes.oauthToken.path=/oauth/token</span><br><span class="line"># 携带前缀转发数据</span><br><span class="line">zuul.routes.oauthToken.stripPrefix=false</span><br><span class="line">zuul.routes.oauthToken.sensitiveHeaders=</span><br><span class="line">zuul.routes.oauthToken.url=$&#123;oauth.url:http://localhost:8082&#125;</span><br><span class="line"></span><br><span class="line"># 认证地址(其它)</span><br><span class="line">zuul.routes.oauth.path=/oauth/**</span><br><span class="line"># 携带前缀转发数据</span><br><span class="line">zuul.routes.oauth.url=$&#123;oauth.url:http://localhost:8082&#125;</span><br><span class="line"></span><br><span class="line"># 其它地址</span><br><span class="line">zuul.routes.ui.path=/**</span><br><span class="line">zuul.routes.ui.url=$&#123;ui.url:http://localhost:8083&#125;</span><br><span class="line"></span><br><span class="line">server.port=$&#123;port:8080&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.首先我们可以从以下代码中看出，<code>Gateway</code>的端口是8080<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=$&#123;port:8080&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.而当我们访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 时，<code>Gateway</code>把路由转发到了8083端口，所以就访问到了前台界面。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.ui.path=/**</span><br><span class="line">zuul.routes.ui.url=$&#123;ui.url:http://localhost:8083&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.登陆前台界面，打开网络选项卡<br><img src="/2017/12/29/how-to-start-measurement-project/2.png" alt=""><br>我们可以看到，后台的api信息是以<code>http://localhost:8080/resource/</code>开头的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zuul.routes.resource.path=/resource/**</span><br><span class="line">zuul.routes.resource.url=$&#123;resource.url:http://localhost:8081&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，当我们访问的路由是以/resource/开头时，就转发到了8081端口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过Gateway应用程序，即使在前后台分离的情况下，也可以避免跨域的问题，即：协议、域名、端口号都是一样的。从而提高了用户的安全指数。</p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMvc </tag>
            
            <tag> gateway </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计量项目前台部分Controller之间的关系]]></title>
      <url>/2017/11/22/instrument-audit/</url>
      <content type="html"><![CDATA[<p>最简单的编程就是看着图编程。最难维护的项目就是一张图都没有的项目。<br>此文章简介一下自己在修改前台过程中整理的部分功能模块是整理的类图。</p>
<a id="more"></a>
<h2 id="类的继承之间的关系"><a href="#类的继承之间的关系" class="headerlink" title="类的继承之间的关系"></a>类的继承之间的关系</h2><p><img src="/2017/11/22/instrument-audit/Class Diagram0.svg" alt=""> </p>
<p>左边这个分支是查看的功能，右边这个分支是审核的功能。Controller之间的关系基本就是这样的。</p>
<h2 id="V层和C层之间的图"><a href="#V层和C层之间的图" class="headerlink" title="V层和C层之间的图"></a>V层和C层之间的图</h2><p><img src="/2017/11/22/instrument-audit/c_v.svg" alt=""> </p>
<p>我想这样更有助于我们理解整个的文件的结构。</p>
<h2 id="简单的时序图"><a href="#简单的时序图" class="headerlink" title="简单的时序图"></a>简单的时序图</h2><p><img src="/2017/11/22/instrument-audit/c.svg" alt=""> </p>
<p>这个时序图主要是讲了一下用户在我的工作的时候点击查看按钮发生的事情，调用相应的方法获取获取哪个Controller。然后进获取相应的数据。这只是是一个很粗糙的博客，<strong>想说的就是当我们在查看一个项目代码的时候如果自己不理解一定要自己画图记录代码的流程</strong>。</p>
]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[java-exception-handling]]></title>
      <url>/2017/11/20/java-exception-handling/</url>
      <content type="html"><![CDATA[<p>在开发 程序的过程中，我们可能经常会和异常打交道，那么出现异常时我们应该怎么处理呢，我们一起来学习一下。</p>
<a id="more"></a>
<h2 id="基本异常处理"><a href="#基本异常处理" class="headerlink" title="基本异常处理"></a>基本异常处理</h2><p>java提供了在程序中处理某些特定类型条件的方法，能够把程序或方法划分为正常情况或异常情况两部分。异常是一个对象，创建这个对象的过程，也被称为抛出异常。实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void LearnException(int i) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">	    if (i &lt; 1)  &#123;</span><br><span class="line">                throw new ArithmeticException(&quot;请传入大于0的整数&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">	    int result = 100/i;</span><br><span class="line">	&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">	    System.out.println(&quot;出现异常了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 从上面这个例子我们可以看出，java处理异常的基本方式有try-throw-catch三元组成。</p>
<ul>
<li><p>try语句块。try是尝试的意思，try语句块中的代码通常是你不能百分之百的确定，但是你想进行一次尝试。它的基本轮廓如下；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">    Code_To_Try</span><br><span class="line">    Possibly_Throw_An_Exception</span><br><span class="line">    More_Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw语句块。上述的例子，也等同与如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArithmeticException arithmeticException = new ArithmeticException(&quot;请传入大于0的整数&quot;);</span><br><span class="line">throw arithmeticException;</span><br></pre></td></tr></table></figure>
<p>实际上，就是new一个异常对象，然后抛出的过程。当异常被抛出时，该块中的代码停止执行，跳出try语句块。</p>
</li>
<li><p>catch语句块。其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> catch (ArithmeticException e) &#123;</span><br><span class="line">    Handling_Exception</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标识符e就像一个参数，接收刚才抛出的异常，所以e的类型必须等同于抛出的异常类型，否则不能捕获异常。</p>
</li>
</ul>
<h2 id="定义自己的异常类"><a href="#定义自己的异常类" class="headerlink" title="定义自己的异常类"></a>定义自己的异常类</h2><p> 我们也可以自己定义一个异常类，但必须继承已经定义好的异常类的。代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public class DivideByZeroException extends Exception &#123;</span><br><span class="line">    public DivideByZeroException() &#123;</span><br><span class="line">        super(&quot;请传入大于0的整数&quot;);		// 调用基类Exception的构造器</span><br><span class="line">    &#125;</span><br><span class="line">    public DivideByZeroException(String message) &#123;</span><br><span class="line">        super(message);	// 调用基类Exception的构造器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 调用方法如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">    if (i &lt; 1)  &#123;</span><br><span class="line">        throw new DivideByZeroException();</span><br><span class="line">    &#125;</span><br><span class="line">    int result = 100/i;</span><br><span class="line">&#125; catch (DivideByZeroException e) &#123;</span><br><span class="line">    System.out.println(&quot;出现异常了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 当我们自己定义异常类时，我们需要注意一下三点：</p>
<ul>
<li>如果你没有更合理的理由使用其他的异常类作为基类，那么就使用Exception作为基类。</li>
<li>你定义的异常类至少定义了两个构造器——一个默认构造器，一个拥有String参数的构造器。通常情况下，自己定义的异常类都要保留getMessage方法。</li>
<li><p>在每一个构造器中，你应该以对基类构造器的调用作为开始，使用super调用。</p>
<blockquote>
<p>如果你在写代码时就已经清楚可能会抛出异常，那么最后自己定义一个异常，这样当出现异常时，我们就更容易区分你的异常和预定义类中的异常。</p>
</blockquote>
</li>
</ul>
<h2 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h2><p> 有时候我们需要延迟处理异常。比如你有一个代码块可能会抛出异常，但你并不想在这个代码块中捕获异常。因为可能某些程序调用该方法抛出异常后应该简单的终止程序，而另一程序调用该方法抛出异常后要做一些其他的处理。所以，当出现类似这种情况时，我们需要在在方法头部声明异常。代码如下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void LearnException(int i) throws DivideByZeroException &#123;</span><br><span class="line">	Code_To_Try</span><br><span class="line">	throw new DivideByZeroException();</span><br><span class="line">	More_Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 如果方法抛出了异常，方法调用立即结束。在方法的首部声明异常的一个好处是，我们可以清楚的区分可能有异常的方法和没有异常的方法，易于阅读。</p>
<blockquote>
<p>关键字throw用于抛出异常，throws用于声明异常。</p>
</blockquote>
<h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>所有的java异常可以分为两类：可控异常，不可控异常。上述的异常属于可控异常，即：异常必须在catch快中捕获或者在方法的首部声明。不可控异常也称为运行时异常（RuntimeException），当出现此类异常时，通常我们应该修正自己的代码，而不是添加catch语句块。</p>
<h2 id="多重捕获和finally"><a href="#多重捕获和finally" class="headerlink" title="多重捕获和finally"></a>多重捕获和finally</h2><ul>
<li>多重捕获。一个try语句块可以抛出任意数量的异常，这些异常可以是不同的类型，因为一个catch语句块只能捕获一种异常，所以一个try语句块可以使用多个catch语句块。</li>
<li>finally关键字 。无论代码是否发生异常，finally中的代码块总会被执行。<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125; catch (DivideByZeroException e1) &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125; catch (IOException) &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2017/11/20/java-exception-handling/102.png" title="层次结构图">
<ul>
<li>我们应该在什么时候抛出异常呢？在 <a href="https://stackoverflow.com/questions/77127/when-to-throw-an-exception" target="_blank" rel="noopener">When to throw an exception?</a> 中，推荐：当发现当前代码块的基本假设是错误时，应该抛出异常。</li>
<li>对于所有的异常都捕获Exception是否可行？可行但是不推荐。最好catch更为精确的异常。</li>
<li>在catch语句块中使用<code>e.printStackTrace()</code>是一个好的习惯么？并不推荐使用这种方法，很多情况下，并不能正确的提示代码出错的位置和相关信息。最好使用在控制台打印的方法。</li>
</ul>
<blockquote>
<p>error—错误 ： 是指程序无法处理的错误.比如内存溢出、端口占用、断言错误等。</p>
</blockquote>
<p>参考文献：</p>
<ol>
<li>《Java程序设计与问题解决》</li>
<li><a href="http://www.runoob.com/java/java-exceptions.html" target="_blank" rel="noopener">Java 异常处理</a> </li>
<li><a href="https://stackoverflow.com/questions/77127/when-to-throw-an-exception" target="_blank" rel="noopener">When to throw an exception?</a> </li>
<li><a href="https://stackoverflow.com/questions/7469316/why-is-exception-printstacktrace-considered-bad-practice" target="_blank" rel="noopener">Why is exception.printStackTrace() considered bad practice?</a> </li>
</ol>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList、LinkedList和HashSet的学习总结]]></title>
      <url>/2017/11/15/java-dynamic-data-structure/</url>
      <content type="html"><![CDATA[<p>java中，一旦程序定义了数组的长度，就不能修改这个数组的长度了。如果我们需要修改数组的长度，我们可以使用ArrayList，以达到改变数组长度的目的。</p>
<a id="more"></a>
<h2 id="类ArrayList"><a href="#类ArrayList" class="headerlink" title="类ArrayList"></a>类ArrayList</h2><p>ArrayList的缺点：</p>
<ul>
<li>ArrayList比数组的效率低</li>
<li>ArrayList只能存储对象，不能包含基本类型，比如int、double。</li>
</ul>
<p>ArrayList的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList &lt;Base_Type&gt; Variable = new ArrayList&lt;Base_Type&gt;(Capacity);</span><br></pre></td></tr></table></figure></p>
<p>其中，Base_Type必须为类类型，不能为基本类型。Capacity（容量）表示为这个数据项分配内存空间，如果不传值，默认初始容量为10个数据项。如果初始化给了足够大的初始容量，那么系统就不需要频繁的分配内存了，程序将会运行的更快。反之，如果你吧初始容量弄得太大，就会浪费储存空间。<br>我们对是否分配容量做一个测试，代码实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ListDemo &#123;</span><br><span class="line"></span><br><span class="line">	static long timeList(List&lt;String&gt; st) &#123;</span><br><span class="line">		long start = System.currentTimeMillis();</span><br><span class="line">		for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">			st.add(String.valueOf(i));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return System.currentTimeMillis() - start;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main (String args[]) &#123;</span><br><span class="line">		System.out.println(&quot;assign capacity ArrayList = &quot;</span><br><span class="line">		 + timeList(new ArrayList&lt;String&gt;(100000)));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;default ArrayList = &quot;</span><br><span class="line">		 + timeList(new ArrayList&lt;String&gt;()));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assign capacity ArrayList = 22</span><br><span class="line">default ArrayList = 13</span><br></pre></td></tr></table></figure></p>
<p>jdk7之前，我们应该这样实例化ArrayList<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></p>
<p>jdk7开始，我们可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>不仅方便了我们书写，也使代码有更强的可读性。</p>
<h2 id="类LinkedList"><a href="#类LinkedList" class="headerlink" title="类LinkedList"></a>类LinkedList</h2><p>类LinkedList的基本用法同上，但是LinkedList内部使用双向链表的数据结构，只有在需要时才分配内存，删除元素时随即释放内存。</p>
<h2 id="类ArrayList和类LinkedList的比较"><a href="#类ArrayList和类LinkedList的比较" class="headerlink" title="类ArrayList和类LinkedList的比较"></a>类ArrayList和类LinkedList的比较</h2><ul>
<li>类LinkedList插入元素效率高，但访问元素效率低。</li>
<li>类ArrayList访问元素效率高，但插入效率低。<br>他们的效率相差多少，我们通过实例来了解（仅修改main方法）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String args[]) &#123;</span><br><span class="line">	System.out.println(&quot;time for ArrayList = &quot;</span><br><span class="line">	 + timeList(new ArrayList&lt;String&gt;()));</span><br><span class="line"></span><br><span class="line">	System.out.println(&quot;time for LinkedList = &quot;</span><br><span class="line">	 + timeList(new LinkedList&lt;String&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time for ArrayList = 22</span><br><span class="line">time for LinkedList = 13</span><br></pre></td></tr></table></figure></p>
<p>如果我们指定位置添加元素，将第六行代码<code>st.add(String.valueOf(i));</code>修改为<code>st.add(0, String.valueOf(i));</code><br>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time for ArrayList = 915</span><br><span class="line">time for LinkedList = 11</span><br></pre></td></tr></table></figure></p>
<p>为什么会差这么多呢，因为每插入一个元素，arraylist都要吧所有的元素都后移，而LinkedList指需要增加一个新的结点，并调整一下对应关系就可以了。<br>我们进行一次新增元素，再进行一次查看元素，他们的效率相差多少呢？将<code>timeList</code>修改为如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static long timeList(List&lt;String&gt; st) &#123;</span><br><span class="line">	long start = System.currentTimeMillis();</span><br><span class="line">	for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">		st.add(String.valueOf(i));</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">		st.get(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return System.currentTimeMillis() - start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time for ArrayList = 17</span><br><span class="line"></span><br><span class="line">time for LinkedList = 156</span><br></pre></td></tr></table></figure></p>
<p>因此，我们在进行相同次数的查找和添加元素的情况下，ArrayList效率较高。因此，我们使用ArrayList的次数会更多一些。</p>
<h2 id="Collection-API的层次结构"><a href="#Collection-API的层次结构" class="headerlink" title="Collection API的层次结构"></a>Collection API的层次结构</h2><p>通过上面的学习，我们对动态数据结构有了基本的认识，那么java中关于数组的接口和实现类的层次结构是什么样的呢？如下图：<br><img src="/images/101.png"><br><br>由上图可知，Iterable接口、Collection接口中定义的方法，几个实现类都实现了，只不过他们的具体实现方法会有所差异。同样的，ArrayList和LinkedList都是List接口的实现类，所以他们的方法名都是一样的，但是具体的实现方法有所差异。</p>
<h2 id="Set接口和List接口"><a href="#Set接口和List接口" class="headerlink" title="Set接口和List接口"></a>Set接口和List接口</h2><p>1.Set对应的中文名是集合，有两个特点：</p>
<ul>
<li>不含重复元素</li>
<li>无序</li>
</ul>
<p>2.List接口类似于书续重的序列，也有两个特点：</p>
<ul>
<li>可含重复的元素</li>
<li>有序</li>
</ul>
<h2 id="类HashSet"><a href="#类HashSet" class="headerlink" title="类HashSet"></a>类HashSet</h2><p>HashSet继承了Set接口的特性，值得注意的是，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法中使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果。因为new一个HashSet，实际上是new HashMap，并以这个对象的hashCode为key，这个对象本身为value储存。当对象的hashcode改变后，我们可以使用迭代器进行删除的操作，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;MandatoryInstrument&gt; iterator = mandatoryInstrumentList.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    MandatoryInstrument mandatoryInstrument = iterator.next();</span><br><span class="line">    if (mandatoryInstrument.getCheckDepartment() == null) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>iterator（迭代器）是什么？eg：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">   st.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，i就是一个迭代器——能够以合理的方式一次访问一个元素、遍历整个数组或者链表的变量。从一个元素走到另一个元素的过程就是是迭代（iterable）</p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java中json和object相互转换]]></title>
      <url>/2017/10/21/how-to-convert-json-to-from-object-Gson/</url>
      <content type="html"><![CDATA[<p>我们经常会用到json和oject类型的相互转换，这篇文章记录了通过gson进行object和json的相互转换。</p>
<a id="more"></a>
<h2 id="gson-依赖"><a href="#gson-依赖" class="headerlink" title="gson 依赖"></a>gson 依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    	&lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    	&lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    	&lt;version&gt;2.6.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="object转换为json"><a href="#object转换为json" class="headerlink" title="object转换为json"></a>object转换为json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 1.新建一个对象</span><br><span class="line">FromMessage fromMessage = new FromMessage();</span><br><span class="line">fromMessage.setContent(&quot;test&quot;);</span><br><span class="line">fromMessage.setIsRead(Boolean.FALSE);</span><br><span class="line"></span><br><span class="line">// 2.将对象转化为json字符串</span><br><span class="line">Gson gson = new Gson();</span><br><span class="line">String jsonString = gson.toJson(fromMessage);</span><br><span class="line">System.out.println(jsonString);			// &#123;&quot;content&quot;:&quot;test&quot;,&quot;isRead&quot;:false&#125;</span><br></pre></td></tr></table></figure>
<h2 id="json转化为object"><a href="#json转化为object" class="headerlink" title="json转化为object"></a>json转化为object</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Gson gson = new Gson();</span><br><span class="line">String jsonString = &quot;&#123;\&quot;content\&quot;:\&quot;test\&quot;,\&quot;isRead\&quot;:false&#125;&quot;;</span><br><span class="line">FromMessage fromMessage1 = gson.fromJson(jsonString, FromMessage.class);</span><br><span class="line">System.out.println(fromMessage1);  		//Message&#123;id=null, content=&apos;test&apos;, title=&apos;null&apos;, isRead=false, fromDepartment=null, toDepartment=null, firstReadTime=null, firstReadUser=null, createUser=null, createTime=null&#125;</span><br></pre></td></tr></table></figure>
<p>参考文章：<br><a href="https://www.mkyong.com/java/how-do-convert-java-object-to-from-json-format-gson-api/" target="_blank" rel="noopener">How to convert Java object to JSON string</a> </p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> object </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[angular和springmvc实现批量删除]]></title>
      <url>/2017/10/21/angular-spring-batch-delete/</url>
      <content type="html"><![CDATA[<p>昨天实现了批量删除的功能，看到了stackoverflow和百度上均有相关的问题，于是决定记录一下。前台angularjs，后台SpringMvc。</p>
<a id="more"></a>
<h2 id="checkbox使用"><a href="#checkbox使用" class="headerlink" title="checkbox使用"></a>checkbox使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr ng-repeat=&quot;(key, object) in data.content&quot;&gt;</span><br><span class="line">     &lt;td&gt;&lt;input icheck type=&quot;checkbox&quot; ng-model=&quot;object._checked&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>
<p>当用户勾选复选框后，对象的_checked属性值为true，我们通过下面这个函数获取勾选的object,可以把这个函数放在公共service中，方便框架的其他地方调用。类似的，我们也可以根据自己的需求，修改_checked属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 由某个数组中 筛选中被选中的元素，组成新的数组并返回</span><br><span class="line"> * @param    &#123;array&#125;                 lists 原数组</span><br><span class="line"> * @param    &#123;string&#125;                 key   健值 默认为 _checked</span><br><span class="line"> * @return   &#123;array&#125;                       选中元素组成的数组</span><br><span class="line"> * @author 梦云智 http://www.mengyunzhi.com</span><br><span class="line"> * @DateTime 2017-10-17T15:05:18+0800</span><br><span class="line"> */</span><br><span class="line">self.getCheckedElementsByListsAndKey = function(lists, key) &#123;</span><br><span class="line">    if (typeof(key) === &apos;undefined&apos;) &#123;</span><br><span class="line">        key = &apos;_checked&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var tempList = [];</span><br><span class="line">    angular.forEach(lists, function(list) &#123;</span><br><span class="line">    	if (typeof(list[key]) !== &apos;undefined&apos; &amp;&amp; list[key] === true) &#123;</span><br><span class="line">    		tempList.push(list);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return tempList;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="前后台对接"><a href="#前后台对接" class="headerlink" title="前后台对接"></a>前后台对接</h2><p>前台http请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data =  [1, 3, 4];		// 假设要删除id为1,3,4的记录</span><br><span class="line">$http.delete(&apos;/FromMessage/batchDelete/&apos; + data)</span><br><span class="line">	.then(function success(response)&#123;</span><br><span class="line">	  if (callback) &#123;callback(response.status);&#125;</span><br><span class="line">	&#125;, function error(response)&#123;</span><br><span class="line">	  alert(&apos;FromMessage.batchDelete error: &apos;, response);</span><br><span class="line">	  if (callback) &#123;callback(response.status);&#125;</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure></p>
<p>后台代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@ResponseStatus(HttpStatus.NO_CONTENT)</span><br><span class="line">    @DeleteMapping(&quot;/batchDelete/&#123;fromMessageIds&#125;&quot;)</span><br><span class="line">    public void batchDelete(@ApiParam(value = &quot;消息id数组&quot;) @PathVariable List&lt;Integer&gt; fromMessageIds) &#123;</span><br><span class="line">        fromMessageService.batchDelete(fromMessageIds);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>后台接受到的是一个数组。如果把数组放到delete方法的body中，由于不符合api规范，会被tomcat或这spring丢弃，后台就不能正确的接受body信息。</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>功能实现后，为了降低代码的维护成本，我们进行单元测试。这里给出示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;模拟请求&quot;);</span><br><span class="line">this.mockMvc.perform(delete(&quot;/FromMessage/batchDelete/&quot; + fromMessage.getId() + &apos;,&apos; + fromMessage1.getId())</span><br><span class="line">.header(&quot;x-auth-token&quot;, xAuthToken))</span><br><span class="line">.andDo(document(&quot;FromMessage_batchDelete&quot;, preprocessResponse(prettyPrint())))</span><br><span class="line">.andExpect(status().is(204));</span><br></pre></td></tr></table></figure></p>
<p>注意请求的url<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/FromMessage/batchDelete/2,3</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在进行开发的时候，实现复选框选中、后台接收数组等功能，感觉之前都实现过，但是由于记得不清楚，测试了多次也没能通过，还是及时的google能够节约解决问题的时间。</p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angularjs </tag>
            
            <tag> SpringMvc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[angular中使用ng-include后controller中$watch失去作用]]></title>
      <url>/2017/10/21/includ-watch-angular/</url>
      <content type="html"><![CDATA[<p>有的时候为了实现代码复用，我们会使用<code>ng-include</code>复用部分代码。</p>
<a id="more"></a>
<h2 id="问题简化"><a href="#问题简化" class="headerlink" title="问题简化"></a>问题简化</h2><p><code>about.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">angular.module(&apos;angularTestApp&apos;)</span><br><span class="line">  .controller(&apos;AboutCtrl&apos;, function ($scope) &#123;</span><br><span class="line">      $scope.num = 0;</span><br><span class="line">      $scope.$watch(&quot;num&quot;, function () &#123;</span><br><span class="line">          console.log($scope.num);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p><code>about.html</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is the about view.&lt;/p&gt;</span><br><span class="line">&lt;div ng-include=&quot;&apos;views/include.html&apos;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&#123;&#123;num&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>include.html</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; ng-model=&quot;num&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; num &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们运行这段代码就会发现一个问题，当我们改变<code>num</code>的值的时候控制台并没有打印<code>num</code>的值。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为我们使用<code>ng-include</code>的时候会会创建一个<code>child scope</code>。然后两个<code>scope</code>的作用域是相互隔离的，所以<code>include.html</code>中的<code>ng-model</code>绑定的是自己的<code>scope</code>, 所以<code>about.js</code>中的<code>num</code>不会发生改变。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>将<code>include.html</code>做如下修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; ng-model=&quot;$parent.num&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; num &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://stackoverflow.com/questions/32775461/ng-model-not-working-inside-ng-include" target="_blank" rel="noopener">ng-model not working inside ng-include</a> </p>
]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何使用U盘启动的方式更新macos]]></title>
      <url>/2017/10/20/Create-a-bootable-installer-for-macOS/</url>
      <content type="html"><![CDATA[<p>苹果系统出现问题，我们往往可以很快的将系统恢复为出厂设置。<br>官方教程： <a href="https://support.apple.com/zh-cn/HT204904" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204904</a></p>
<p>那么当我们想对原有系统进行升级呢？<br>此时，我们就需要下载macos的新系统，然后采用U盘的形式安装了。</p>
<a id="more"></a>
<p>参考官方英文教程： <a href="https://support.apple.com/en-us/HT201372" target="_blank" rel="noopener">https://support.apple.com/en-us/HT201372</a></p>
<p>简单描述下步骤：</p>
<h1 id="格式化U盘"><a href="#格式化U盘" class="headerlink" title="格式化U盘"></a>格式化U盘</h1><p>需要注意两点：</p>
<ol>
<li>格式应该选择：Mac OS 扩展（日志式）</li>
<li>名称应该起个简短的，不要有空格。比如起名为：OSX</li>
</ol>
<img src="/2017/10/20/Create-a-bootable-installer-for-macOS/2.png" title="说明">
<h1 id="将系统写入U盘"><a href="#将系统写入U盘" class="headerlink" title="将系统写入U盘"></a>将系统写入U盘</h1><ol>
<li>双击下载的dmg文件，并进行安装。</li>
<li>安装成功后，将在 所有程序 中看到一个名为： 安装 mac os xx</li>
</ol>
<img src="/2017/10/20/Create-a-bootable-installer-for-macOS/1.png" title="说明">
<ol>
<li>打开 安装 mac os xx，但不要点继续，就打开放着就可以。</li>
<li><p>确认自己当前系统的版本<br>点小苹果，关于本机。</p>
</li>
<li><p>使用<code>createinstallmedia</code>命令进行U盘写入<br>不同的系统，<code>createinstallmedia</code> 不同，命令也不完全相同，这个需要参考官方文档。</p>
</li>
</ol>
<p>我的方法是，输入<code>/Applications/Install</code>后，按tab键自动补全，然后与官方文档相对应，就能清楚自己的版本号了。</p>
<ol>
<li>替换命令中的U盘名称<br>比如我们的起名为OSX, 则将命令中的 /Volumes/MyVolume 换为 /Volumes/OSX</li>
</ol>
<p>当然了，你也可以把U盘起名为：MyVolume，这样在输入命令时就不需要变更了。</p>
<p>示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bogon:Applications apple$ sudo Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/OSX/</span><br><span class="line">Password:</span><br><span class="line">Ready to start.</span><br><span class="line">To <span class="built_in">continue</span> we need to erase the volume at /Volumes/OSX/.</span><br><span class="line">If you wish to <span class="built_in">continue</span> <span class="built_in">type</span> (Y) <span class="keyword">then</span> press <span class="built_in">return</span>: Y</span><br><span class="line">Erasing Disk: 0%... 10%... 20%... 30%...100%...</span><br><span class="line">Copying installer files to disk...</span><br><span class="line">Copy complete.</span><br><span class="line">Making disk bootable...</span><br><span class="line">Copying boot files...</span><br><span class="line">Copy complete.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p>
<p>然后，我们就可以按<a href="https://support.apple.com/zh-cn/HT204904" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT204904</a>的说明来重新安装操作系统了。</p>
<p><hr><br>以下内容是关于组建<code>funsion driver</code>的<br><code>funsion driver</code> = 一块机器 + 一块SSD。组建容量高速度快的硬盘驱动器。</p>
<p><hr><br>不更新系统，只是想组建funsion driver，请直接参考官网地址，如下<br><a href="https://support.apple.com/zh-cn/HT207584" target="_blank" rel="noopener">https://support.apple.com/zh-cn/HT207584</a></p>
]]></content>
      
        <categories>
            
            <category> panjie </category>
            
        </categories>
        
        
        <tags>
            
            <tag> macos </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[review(审阅)pull request的方法]]></title>
      <url>/2017/10/19/how-to-review-pull-request/</url>
      <content type="html"><![CDATA[<p>在团队开发的过程中，我们需要将自己开发的代码使用<code>pull request</code>的方式提交至<code>github</code>中。本文中，我们给出当我们看到别人提交的代码时，如何快速的来审阅这次代码提交。</p>
<a id="more"></a>
<p>首先，假设我们有以下<code>pull request</code>.<br><img src="/2017/10/19/how-to-review-pull-request/1.jpg" title="pullRequest示例"></p>
<h1 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h1 id="找到提交分支"><a href="#找到提交分支" class="headerlink" title="找到提交分支"></a>找到提交分支</h1><p>如下图，我们查看到，当前的<code>pull request</code>是由<code>reviewPullRequest</code>提交上来的。<br><img src="/2017/10/19/how-to-review-pull-request/2.jpg" title="pullRequest示例"></p>
<h1 id="切换到提交分支"><a href="#切换到提交分支" class="headerlink" title="切换到提交分支"></a>切换到提交分支</h1><p><hr><br>如果我们正在进行同一项目的开发，那么我们可以先将自己的代码进行<code>commit</code>。</p>
<p><hr><br>切换至提交<code>pull request</code>的分支<code>reviewPullRequest</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;reviewPullRequest&gt;</span><br></pre></td></tr></table></figure>
<h1 id="查看效果或是代码"><a href="#查看效果或是代码" class="headerlink" title="查看效果或是代码"></a>查看效果或是代码</h1><p>此时，我们便可以启用本地环境来查看效果了。</p>
<p>如果我们查看是<code>readme.md</code>文档，那么还可以直接登录<code>github</code>官网，然后在官网上直接切换分支后在线阅览<code>readme.md</code>的效果。</p>
<img src="/2017/10/19/how-to-review-pull-request/3.jpg" title="pullRequest示例">
<p>代码审阅完毕后，我们需要在<code>github</code>中给出审核的意见：</p>
<img src="/2017/10/19/how-to-review-pull-request/4.jpg" title="pullRequest示例">
<p>三种意见：</p>
<ol>
<li>Commnet 不同意</li>
<li>Approve 同意</li>
<li>Request changes 修改后同意</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何启动团队的hexo的博客]]></title>
      <url>/2017/10/19/how-to-start-team-hexo-bolg/</url>
      <content type="html"><![CDATA[<p>本文中，我们将说明，如果在本地配置团队的hexo博客<br>工具准备： <code>nodejs</code>, <code>git</code><br><a id="more"></a></p>
<h1 id="clone-项目"><a href="#clone-项目" class="headerlink" title="clone 项目"></a>clone 项目</h1><p><code>git clone https://github.com/yunzhiclub/hexo.git hexo</code></p>
<p>进入项目目录<br><code>cd hexo</code></p>
<p>新建自己的分支<br><code>git checkout -b &lt;newBranch&gt;</code></p>
<blockquote>
<p><code>&lt;abc&gt;</code> 表示此项为必填项，在实际使用中，将abc替换为自己的内容。</p>
</blockquote>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p><code>npm install</code><br><code>bower install</code></p>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><p><code>hexo server</code><br>项目启动后，将在控制台收到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p>
<p>我们可以找开<code>http://localhost:4000/</code>来查看项目，并在控制台中使用<code>Ctrl+C</code>来终止服务。</p>
<h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><p><code>hexo new title</code><br>将新建一篇文章，控制台同时提醒我们新建文章的位置。</p>
<p>最后，编辑文章，保存，将新的文章添加到git中，并提交<code>pull request</code></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><img src="https://hexo.io/zh-cn/docs/" alt="https://hexo.io/zh-cn/docs/"></p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习hebinate继承映射关系]]></title>
      <url>/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/</url>
      <content type="html"><![CDATA[<p>做计量项目我的消息模块时，消息分为接收消息和发送消息，如果把消息放在一个实体中，当删除发送消息时，对应的接受消息也被删除了，因此决定使用继承的方法。我们通过这个问题学习ＪＰＡ主要的三种映射策略。<br><a id="more"></a></p>
<h2 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h2><p>假设有三个类animal、cat、dog。cat、dog继承animal类<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/96.png" title="说明"><br>那我们应该通过什么方法生成数据表，生成几张数据表呢，哪种方法最优呢？</p>
<h2 id="单表继承策略"><a href="#单表继承策略" class="headerlink" title="单表继承策略"></a>单表继承策略</h2><p>单表继承，就是这几个类共用一个数据表。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 继承（策略 = 单表继承）</span><br><span class="line">@DiscriminatorColumn(name = &quot;DB_TYPE&quot;)  // 鉴别的列名为 DB_TYPE，将在数据表中生成该字段，用与区分子表类型</span><br><span class="line">public abstract class Animal implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line">    </span><br><span class="line">    private String age;</span><br><span class="line">    // 省略constructor 、getters、setters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@DiscriminatorValue(&quot;Cat&quot;)</span><br><span class="line">public class Cat extends Animal &#123;</span><br><span class="line">    private String weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">@DiscriminatorValue(&quot;Dog&quot;)</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    private String height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成了一张数据表：<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/97.png" title="说明"></p>
<p>这种方法不仅简单，而且性能也是最优的。因为每个子类使用了@Entity注解，子类的属性都会被映射到Animal表的列中。</p>
<blockquote>
<p>这种方法在子类中使用@NotNull注解会被hibernate忽略，因为如果你定义了Dog类的height属性不能为null，但是当保存cat类的数据时，height必然为null。</p>
</blockquote>
<h2 id="JOINED策略"><a href="#JOINED策略" class="headerlink" title="JOINED策略"></a>JOINED策略</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy = InheritanceType.JOINED) // 继承（策略 = TABLE_PER_CLASS）</span><br><span class="line">public abstract class Animal &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)   // 不能使用自动生成主键策略</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    private String height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Cat extends Animal &#123;</span><br><span class="line">    private String weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时生成了三张表<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/100.png" title="说明"><br>我们可以看到dog和cat表中并没有age属性当我们想获取age属性时，我们通过左链接的方式取值。</p>
<h2 id="TABLE-PER-CLASS策略"><a href="#TABLE-PER-CLASS策略" class="headerlink" title="TABLE_PER_CLASS策略"></a>TABLE_PER_CLASS策略</h2><p>这种策略不能使用自动生成主键的策略，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) // 继承（策略 = TABLE_PER_CLASS）</span><br><span class="line">public class Animal &#123;</span><br><span class="line">    @Id</span><br><span class="line">    //@GeneratedValue(strategy = GenerationType.AUTO)   // 不能使用自动生成主键策略</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Cat extends Animal &#123;</span><br><span class="line">    private String weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Dog extends Animal &#123;</span><br><span class="line">    private String height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成了三张数据表：<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/98.png" title="说明"><br>如果把Animal改为abstract类，则只会生成两张表<br><img src="/2017/10/17/Learning-to-use-entity-inheritance-with-JPA-and-Hibernate/99.png" title="说明"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习了以上三种方式，那么我们在什么情况下使用他们呢？</p>
<ul>
<li>当父类的属性较多时，我们使用<code>InheritanceType.SINGLE_TABLE</code>策略，已达到最少可为空的列的数量。</li>
<li>当父类的属性较少，而子类的属性较多时，我们使用<code>InheritanceType.JOINED</code>策略。</li>
<li>当我们很少对父类进行操作时，我们使用<code>InheritanceType.TABLE_PER_CLASS</code>策略，这种方法倾向于把每一个类对应一个具体的表。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JPA </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeBSD如何更新freebsd的port tree]]></title>
      <url>/2017/10/13/how-to-update-port-tree/</url>
      <content type="html"><![CDATA[<p>在使用freebsd系统进行软件安装时，如果该软件发生了安全问题，则freebsd的ports服务器会更新其对应的版本。此时，如果我们的本地服务器未更新到最新的ports，则会提示“该软件发现了安全问题，请更新ports tree后再来安装”的提示。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>比如，我在安装nodejs时，报了以下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">===&gt;  node-8.1.3 has known vulnerabilities:</span><br><span class="line">node-8.1.3 is vulnerable:</span><br><span class="line">node.js -- multiple vulnerabilities</span><br><span class="line">WWW: https://vuxml.FreeBSD.org/freebsd/3eff66c5-66c9-11e7-aa1d-3d2e663cef42.html</span><br><span class="line"></span><br><span class="line">1 problem(s) <span class="keyword">in</span> the installed packages found.</span><br><span class="line">=&gt; Please update your ports tree and try again.</span><br><span class="line">=&gt; Note: Vulnerable ports are marked as such even <span class="keyword">if</span> there is no update available.</span><br><span class="line">=&gt; If you wish to ignore this vulnerability rebuild with <span class="string">'make DISABLE_VULNERABILITIES=yes'</span></span><br></pre></td></tr></table></figure></p>
<p>我们常说小白，小白只所以白，往往是由于我们发现错误后，根本就不看错误给我的提示，然后就胡乱的进行一通错误的排查。而错误提醒却恰恰是解决这个问题关键。</p>
<p>是的，我们往往在开发程序时，也会把一些重要的话输出出来，来提醒使用者他那底错在哪了。告别小白，从看错误提示开始.<br><a id="more"></a></p>
<p>解决的方法，当然是上述的提示进行操作了。</p>
<blockquote>
<p>Please update your ports tree and try again =》 请更新你的ports tree后再次尝试。</p>
</blockquote>
<h1 id="GOOGLE关键字"><a href="#GOOGLE关键字" class="headerlink" title="GOOGLE关键字"></a>GOOGLE关键字</h1><p>有了上面的错误提示，此时，我们google时，方向就更明确了。我们以freebsd update ports tree来进行搜索。很快，将会获得我们想要的答案。比如，我查询时，获取了以下信息：</p>
<blockquote>
<p>Portsnap is the tool we will use to update our ports tree. It is fast, and simple to use. The first time you run portsnap, it needs to download the entire ports tree, which is a download in the tens of megabytes.</p>
<p><code>portsnap fetch</code><br><code>portsnap extract</code></p>
<p>Henceforth, anytime you want to update your ports tree, you will only have to run this command:</p>
<p><code>portsnap fetch update</code></p>
</blockquote>
<p>碰到英文如果读不懂的话，就慢点读，找自己认识的单词读，先尝试了解这个文章的大概意思。当然，最重要的还是坚持。如果对比英文水平，应该是大一的水平最强，越往后水平越差。如果你不幸在大一大二期间没有阅读过英文的站点，这时候你选择的不应该是放弃，而是比别人多下一番功夫。</p>
<p>我简单的译一下上面的英文：</p>
<blockquote>
<p>我们可以使用Portsnap这个工具来更新我们的ports tree。Portsnap使用起来即简单又高效。如果你在本服务器上第一次使用Portsnaphe，则需要下载整个ports tree。当然了，下载的东西会很多。以下是首次使用的两个命令。</p>
<p><code>portsnap fetch</code><br><code>portsnap extract</code></p>
<p>当下次我们再更新ports tree时，只需要使用以下命令就可以了。</p>
<p><code>portsnap fetch update</code></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问题并不复杂。解决问题的难易取决于英文阅读能力的高低。<br>简单的事情重复做，你就是专家。在平常的学习时，我们离不开使用google查找一些问题。当某个问题你是参考某个英文站点解决的，那么请多花些时间在你刚刚参考的英文页面上，尝试性的翻译大多数的英文单词，来彻底的搞明白这个帮你解决了问题的页面到底说了些什么。</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> freebsd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SpringMVC+Angularjs上传图片]]></title>
      <url>/2017/10/10/SpringMVC-Angularjs-upload-image/</url>
      <content type="html"><![CDATA[<p>最近，完成了图片上传的功能，中间也遇到了一些问题，本文记录了上传图片的代码段，希望下次开发相同的功能时尽可能的节约时间。环境：后台SpringMvc，前台angularjs，前台插件<a href="https://www.npmjs.com/package/angular-file-upload" target="_blank" rel="noopener">angular-file-upload </a> 。</p>
<a id="more"></a>
<h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><ul>
<li>开发顺序：先开发前台，再开发后台。从而避免开发后台的功能后，前台不需要此功能的情况。</li>
<li>前台开发：我们把图片作为一个指令，以方便在各个模块中的使用。引入angular-file-upload插件。</li>
<li>后台应该建立图片相关实体，后台获取到图片后，对文件流进行sha1或md5加密，判断如果后台服务器已经存在相同的图片，则不在上传该图片，直接引用之前上传的图片，以节约服务器资源。类似地，删除图片时，也应该判断是否改图片被引用多次，如果被引用多次，则不需要删除服务器中的图片，只删除图片实体中的那一条记录即可。如果用户要删除的图片只被引用一次，则删除图片实体中的记录，并删除服务器中的图片，释放服务器资源。同时，参考<a href="https://spring.io/guides/gs/uploading-files/" target="_blank" rel="noopener">官方文档</a> ，并根据前台需求，完成后台功能代码。<blockquote>
<p>通过这种方法，如果用户上传较大的文件，且服务器之前已经上传过相同的文件，那么就可以实现秒传，同时节约了服务器的资源。所以，有时我们在一些平台上（如迅雷）上传几百兆或者几个Ｇ的文件，也可秒传，并不是网速很快，而是因为服务器上已经存在相同的文件。</p>
</blockquote>
</li>
<li>给出附件实体实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@ApiModel(value = &quot;Attachment (附件)&quot;, description = &quot;附件&quot;)</span><br><span class="line">public class Attachment implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @ManyToOne</span><br><span class="line">    @ApiModelProperty(&quot;操作用户&quot;)</span><br><span class="line">    private User operator;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;sha1值&quot;)</span><br><span class="line">    private String sha1;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;md5值&quot;)</span><br><span class="line">    private String md5;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件扩展名&quot;)</span><br><span class="line">    private String ext;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件大小&quot;)</span><br><span class="line">    private String size;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件上传时间&quot;)</span><br><span class="line">    private Long createTime;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件更新时间&quot;)</span><br><span class="line">    private Long updateTime;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件名称&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件存储路径&quot;)</span><br><span class="line">    private String savePath;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;附件存储名称&quot;)</span><br><span class="line">    private String saveName;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(&quot;MIME类型&quot;)</span><br><span class="line">    private String MIME;</span><br><span class="line">    // 省略constructor、getters、setters</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="前台代码"><a href="#前台代码" class="headerlink" title="前台代码"></a>前台代码</h2><p>界面的效果图如下：<br><img src="../94.png"></p>
<blockquote>
<p>前台代码放在github上，代码地址：<a href="https://github.com/chuhang123/blog/tree/master/2017/uploadImage" target="_blank" rel="noopener">https://github.com/chuhang123/blog/tree/master/2017/uploadImage</a> 。</p>
</blockquote>
<p>在前台代码中，我们需要对图片标题<a href="https://github.com/chuhang123/blog/blob/master/2017/uploadImage/imagetitle.js" target="_blank" rel="noopener">长度过滤</a> ，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 长度为２０</span><br><span class="line">return function (input) &#123;</span><br><span class="line">    var r=/[^\x00-\xff]/g;</span><br><span class="line">    if(input.replace(r,&quot;mm&quot;).length&lt;=20)&#123;return input;&#125;</span><br><span class="line">    var m=Math.floor(20/2);</span><br><span class="line">    for(var i=m;i&lt;input.length;i++)&#123;</span><br><span class="line">        if(input.substr(0,i).replace(r,&quot;mm&quot;).length&gt;=20)&#123;</span><br><span class="line">            return input.substr(0,i)+&quot;...&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return input;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>显示图片的<a href="https://github.com/chuhang123/blog/blob/master/2017/uploadImage/yunzhithumb.js" target="_blank" rel="noopener">缩略图</a> ，并根据项目需求请求后台代码。</p>
<h2 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h2><p>在后台的附件控制器中建立三个请求借口：删除、上传、图片访问入口。同时参考<a href="https://spring.io/guides/gs/uploading-files/" target="_blank" rel="noopener">官方文档</a> 。</p>
<p><img src="/images/95.png"></p>
<ul>
<li>如上图所示，需要注意４个地方：</li>
</ul>
<ol>
<li>预览图片时，我们要根据图片的保存名称来浏览图片，我们要使用<code>{saveName:.+}</code>获取图片的名称，否则不能正确获取图片的名称。</li>
<li>参考官方教程浏览图片时，控制台会抛出<code>HttpMessageNotWritableException</code>异常，我们需要设置响应信息的内容类型，就把这个异常给解决了。</li>
<li>官方文档是把文件流放在响应信息中，但这种方式相当消耗服务器的资源，假设一个图片１Ｍ，有１００个并发请求，那么就要消耗服务器１００Ｍ的内存，那么如果有更多的并发请求，那么就非常消耗资源。所以等项目上线后把开放图片路径，以节约服务器资源。</li>
<li>上传的图片类型为<code>MultipartFile</code>, 所以前台的请求内容类型应该为<code>Content-Type:multipart/form-data</code>，请求实例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var formData = new FormData();</span><br><span class="line">formData.append(&apos;attachment&apos;, image);</span><br><span class="line"></span><br><span class="line">$http.post(url, formData, &#123;</span><br><span class="line">transformRequest: angular.identity,</span><br><span class="line">headers: &#123;&apos;Content-Type&apos;: undefined&#125;</span><br><span class="line">&#125;)........</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>设置图片大小上限，在配置文件中增加如下代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 设置图片最大为３Ｍ</span><br><span class="line">spring.http.multipart.max-file-size=3072KB　</span><br><span class="line">spring.http.multipart.max-request-size=3072KB</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当其他实体和附件相关时，比如强检申请：附件=1：n，因为可能还会有很多实体和附件相关联，因此在强检申请实体中使用@OneToMany单向映射较为合适。为了操作方便，通过使用 @JoinColumn不再建立中间表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@OneToMany</span><br><span class="line"> @JoinColumn(name = &quot;mandatoryInstrumentApply_id&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为我们需要对MultipartFile类型的文件进行sha1、md5加密，所以这里给出hash加密算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 根据指定的算法加密文件数据, 返回固定长度的十六进制小写哈希值</span><br><span class="line">     *</span><br><span class="line">     * @param multipartFile 需要加密的文件</span><br><span class="line">     * @param algorithm 加密算法, 例如: MD5, SHA-1, SHA-256, SHA-512 等</span><br><span class="line">     */</span><br><span class="line">    static String encrypt(MultipartFile multipartFile, String algorithm) throws Exception &#123;</span><br><span class="line">        InputStream in = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 1. 根据算法名称获实现了算法的加密实例</span><br><span class="line">            MessageDigest digest = MessageDigest.getInstance(algorithm);</span><br><span class="line"></span><br><span class="line">            in = multipartFile.getInputStream();</span><br><span class="line">            byte[] buf = new byte[1024];</span><br><span class="line">            int len = -1;</span><br><span class="line">            while ((len = in.read(buf)) != -1) &#123;</span><br><span class="line">                // 2. 文件数据通常比较大, 使用 update() 方法逐步添加</span><br><span class="line">                digest.update(buf, 0, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 3. 计算数据的哈希值, 添加完数据后 digest() 方法只能被调用一次</span><br><span class="line">            byte[] cipher = digest.digest();</span><br><span class="line"></span><br><span class="line">            // 4. 将结果转换为十六进制小写</span><br><span class="line">            return bytesToString(cipher);</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (in != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // nothing</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将字节转为字符串</span><br><span class="line">    static String bytesToString(byte[] bytes) &#123;</span><br><span class="line">        if (bytes == null || bytes.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">        for (byte b : bytes) &#123;</span><br><span class="line">            stringBuilder.append(HEXES[(b &gt;&gt; 4) &amp; 0x0F]);</span><br><span class="line">            stringBuilder.append(HEXES[b &amp; 0x0F]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 十六进制字符数组</span><br><span class="line">    static char[] HEXES = &#123;</span><br><span class="line">            &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;,</span><br><span class="line">            &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;,</span><br><span class="line">            &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;,</span><br><span class="line">            &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次附件上传花费了较长的时间，一方面水平不够，一方面有些追求完美，从而耽误了时间，所以完成任务是第一位的，切忌追求完美。望以后注意。</p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习JPA的@OneToMany注解]]></title>
      <url>/2017/10/09/Learning-JPA-OneToMany/</url>
      <content type="html"><![CDATA[<p>在JPA中，最常用的关系大概就是一对多了。假设实体A、B的关系为A:B=1:n，通常情况下，我们会在B实体中使用@ManyToOne的注解。但是有时我们需要在A实体中使用@OneToMany的注解，那么我们应该怎么办呢？</p>
<blockquote>
<p>以下代码中，假设实体One和Many的关系为One:Many=1:n</p>
</blockquote>
<h2 id="单向映射-OneToMany"><a href="#单向映射-OneToMany" class="headerlink" title="单向映射@OneToMany"></a>单向映射@OneToMany</h2><p>我们只在One实体中使用注解，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class One &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    @OneToMany</span><br><span class="line">    private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();</span><br><span class="line">    // 省略构造函数，getters and setters</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class Many &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的数据表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [springmvc]&gt; select * from one;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from many;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from one_manys;</span><br><span class="line">+--------+----------+</span><br><span class="line">| one_id | manys_id |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        1 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>现在，我们如果想要在中间表中存一条记录，就必须先要保证many实体中存在一条记录，然后保存one对象时设置和many的关联关系？代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;新建One实体&quot;);</span><br><span class="line">One one = new One();</span><br><span class="line"></span><br><span class="line">logger.info(&quot;新建并保存Many实体&quot;);</span><br><span class="line">Many many = new Many(&quot;test&quot;);</span><br><span class="line">manyRepository.save(many);	// 能不能省略这行代码呢？</span><br><span class="line"></span><br><span class="line">logger.info(&quot;保存&quot;);</span><br><span class="line">List&lt;Many&gt; manies = new ArrayList&lt;&gt;();</span><br><span class="line">manies.add(many);</span><br><span class="line">one.setManys(manies);</span><br><span class="line">oneRepository.save(one);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们能不能省略<code>manyRepository.save(many);</code>，答案是可以的。直接在One实体中的@OneToMany注解后面加入括号(cascade = CascadeType.ALL, orphanRemoval = true)，JPA仍然会自动保存many实体。</p>
<ul>
<li>此时，如果我们把Many实体表中id为1的记录删除，会报一个外键约束的错误，我们需要先把one_manys表中的记录删除，才可以删除Many实体表中id为1的记录。这样是不是有点麻烦呢？有没有办法直接删除Many实体中的记录呢？我们在One实体中增加一个注解@JoinColumn就可以了，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class One &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    @OneToMany</span><br><span class="line">    @JoinColumn(name = &quot;many_id&quot;)</span><br><span class="line">    private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据表的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [springmvc]&gt; select * from one;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from many;</span><br><span class="line">+----+------+---------+</span><br><span class="line">| id | name | many_id |</span><br><span class="line">+----+------+---------+</span><br><span class="line">|  1 | test |       1 |</span><br><span class="line">+----+------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from one_manys;</span><br><span class="line">ERROR 1146 (42S02): Table &apos;springmvc.one_manys&apos; doesn&apos;t exist</span><br></pre></td></tr></table></figure></p>
<p>这样就不会增加中间表了，此时我们可以直接删除many实体中的记录了。</p>
<h2 id="双向映射-OneToMany"><a href="#双向映射-OneToMany" class="headerlink" title="双向映射@OneToMany"></a>双向映射@OneToMany</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Many &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @ManyToOne</span><br><span class="line">    private One one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Entity</span><br><span class="line">public class One &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO) private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    @OneToMany</span><br><span class="line">    private List&lt;Many&gt; manys = new ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的数据表如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [springmvc]&gt; select * from one_manys;</span><br><span class="line">+--------+----------+</span><br><span class="line">| one_id | manys_id |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      1 |        1 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from many;</span><br><span class="line">+----+------+--------+</span><br><span class="line">| id | name | one_id |</span><br><span class="line">+----+------+--------+</span><br><span class="line">|  1 | test |      1 |</span><br><span class="line">+----+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [springmvc]&gt; select * from one;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们经常会用到实体间的关系，但是往往在实际的项目中，由于项目过于庞大，增加了学习成本。因此，比较好的学习方法就是在一个测试的项目中学习，减少学习成本。</p>
<p>参考链接：<br><a href="https://vladmihalcea.com/2017/03/29/the-best-way-to-map-a-onetomany-association-with-jpa-and-hibernate/" target="_blank" rel="noopener">The best way to map a @OneToMany relationship with JPA and Hibernate</a> </p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JPA </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js的浅拷贝和深拷贝学习]]></title>
      <url>/2017/10/08/js-deep-copy-and-shallow-copy/</url>
      <content type="html"><![CDATA[<p>最近做项目时，发现把A赋值给B，当我改变B时，A也随之改变了。google了一下，了解到在js中，当一个变量复制另一个变量时，其实复制的是一个地址，改变其中一个变量，另一个也会随之改变。</p>
<p>这种复制分两种情况：拷贝引用（浅拷贝）和拷贝实例（深拷贝）<br><a id="more"></a></p>
<h2 id="浅copy"><a href="#浅copy" class="headerlink" title="浅copy"></a>浅copy</h2><ul>
<li><p>拷贝原对象的引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 = &#123;a: 1&#125;;</span><br><span class="line">var o2 = o1;</span><br><span class="line"></span><br><span class="line">console.log(o1 === o2);  // =&gt;true</span><br><span class="line">o2.a = 2; </span><br><span class="line">console.log(o1.a); // =&gt; 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o1 = [&apos;darko&apos;, &#123;age: 22&#125;];</span><br><span class="line">var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的浅拷贝对象</span><br><span class="line"></span><br><span class="line">console.log(o1 === o2); // =&gt; false，说明o2拷贝的是o1的一个实例</span><br><span class="line"></span><br><span class="line">o2[0] = &apos;lee&apos;;</span><br><span class="line">console.log(o1[0]); // =&gt; &quot;darko&quot; o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响</span><br><span class="line"></span><br><span class="line">o2[1].age = 23;</span><br><span class="line">console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>浅copy实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function shallowClone(source) &#123;</span><br><span class="line">    if (!source || typeof source !== &apos;object&apos;) &#123;</span><br><span class="line">        throw new Error(&apos;error arguments&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    var targetObj = source.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">    for (var keys in source) &#123;</span><br><span class="line">        if (source.hasOwnProperty(keys)) &#123;</span><br><span class="line">            targetObj[keys] = source[keys];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="深copy"><a href="#深copy" class="headerlink" title="深copy"></a>深copy</h2><p>深copy有两种方法</p>
<ul>
<li>使用JSON.stringify和JSON.parse。<br><code>JSON.parse(JSON.stringify(object))</code>。这种方法只能copy对象的属性，不能copy对象的方法。</li>
<li>使用递归的方法实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(source)&#123;</span><br><span class="line">   if(!source || typeof source !== &apos;object&apos;)&#123;</span><br><span class="line">     throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;);</span><br><span class="line">   &#125;</span><br><span class="line">   var targetObj = source.constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">   for(var keys in source)&#123;</span><br><span class="line">      if(source.hasOwnProperty(keys))&#123;</span><br><span class="line">         if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123;</span><br><span class="line">           targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;;</span><br><span class="line">           targetObj[keys] = deepClone(source[keys]);</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">           targetObj[keys] = source[keys];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   return targetObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考链接：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000008637489" target="_blank" rel="noopener">JavaScript中的浅拷贝和深拷贝</a> </li>
<li><a href="https://www.zhihu.com/question/23031215" target="_blank" rel="noopener">javascript中的深拷贝和浅拷贝？</a> </li>
</ol>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多关键字实体的更新方法]]></title>
      <url>/2017/09/30/how-to-update-entity-of-multiple-key/</url>
      <content type="html"><![CDATA[<p>假设我们有以下实体，该实体共有4个属性，其中有2个属性组成了组合主键。</p>
<img src="/2017/09/30/how-to-update-entity-of-multiple-key/1.png" title="ER图">
<p>下面，简单阐述下如何正确的实现对上述实体类型的更新操作。<br><a id="more"></a></p>
<h1 id="操作习惯"><a href="#操作习惯" class="headerlink" title="操作习惯"></a>操作习惯</h1><p>在进行更新时，按以往的方法，我们只需要设置好这个实体的主键，然后调用<code>save</code>方法，就可以了。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(DeviceInstrument deviceInstrument)</span> </span>&#123;</span><br><span class="line">    deviceInstrumentRepository.save(deviceInstrument);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：失败。</p>
<h1 id="有则更新，无则插入"><a href="#有则更新，无则插入" class="headerlink" title="有则更新，无则插入"></a>有则更新，无则插入</h1><p>那么我们换种思路：<br>造成前面的方法失效的原因：可能是<code>SpringMVC</code>在进行<code>save</code>操作时，不能够区分是插入还是更新。</p>
<p>解决方法：在进行数据保存前，先查找是否有历史记录。如果有，执行更新操作；没有，则执行插入操作。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(DeviceInstrument deviceInstrument)</span> </span>&#123;</span><br><span class="line">    DeviceInstrument oldDeviceInstrument = deviceInstrumentRepository.findOne(deviceInstrument.getId());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == oldDeviceInstrument) &#123;</span><br><span class="line">        logger.info(<span class="string">"新记录，保存"</span>);</span><br><span class="line">        deviceInstrumentRepository.save(deviceInstrument);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"老记录，更新"</span>);</span><br><span class="line">        oldDeviceInstrument.setAccuracy(deviceInstrument.getAccuracy());</span><br><span class="line">        oldDeviceInstrument.setMeasureScale(deviceInstrument.getMeasureScale());</span><br><span class="line">        deviceInstrumentRepository.save(oldDeviceInstrument);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对此，我也写了单元测试，单元测试显示成功的更新了数据。但是，正常调用过程中，数据表的数据仍然未改变。我猜想可能是由于<code>SpringMVC</code>的缓存机制，数据没有成功更新吧。看来还需要进一步对单元测试与<code>SpringMVC</code>的<code>JPA</code>加强学习。</p>
<h1 id="先删除，再插入"><a href="#先删除，再插入" class="headerlink" title="先删除，再插入"></a>先删除，再插入</h1><p>通过前面尝试，我猜想可能是多主键时，<code>udpate</code>并没有起作用，也就是说，想使用<code>update</code>的方法来直接更新实体信息这个思路是错误的。</p>
<p>解决方法：先删除原有的记录，然后再插入一条新的记录。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrUpdate</span><span class="params">(DeviceInstrument deviceInstrument)</span> </span>&#123;</span><br><span class="line">    DeviceInstrument oldDeviceInstrument = deviceInstrumentRepository.findOne(deviceInstrument.getId());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != oldDeviceInstrument) &#123;</span><br><span class="line">        logger.info(<span class="string">"老记录，先删除原记录"</span>);</span><br><span class="line">        deviceInstrumentRepository.delete(oldDeviceInstrument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deviceInstrumentRepository.save(deviceInstrument);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是单元测试还是生产环境，上述代码都得到了期待的结果。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在多主键表中，我们需要使用先删除再插入的方法来实现更新操作。</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> JPA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在angularjs中，设置元素不可见替代隐藏元素的方法]]></title>
      <url>/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/</url>
      <content type="html"><![CDATA[<p>在AngularJS中，我们都知道使用<code>ng-hide</code>来隐藏元素。但有时候，我们需要的却是元素不可见。</p>
<p>此时，我们需要使用<code>ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;</code>来代替<code>ng-hide=&quot;express&quot;</code>。其中，<code>express</code>为变量或是表达式。</p>
<p>元素不可见与元素隐藏有什么关系呢？</p>
<p>在<code>CSS</code>中:<br>隐藏元素 = <code>display: none</code><br>元素不可见 = <code>visibility: hidden</code></p>
<p>下面，我们通过下面的小例子，来看看具体他们的区别，以及元素不可见的应用场景。<br><a id="more"></a></p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>在计量的项目中，我们需要对精确度进行排序，假设现在效果如下：</p>
<img src="/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/1.gif" title="排序示例图">
<p>点击上、下图标时，可以改变精确度的顺序。</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>我们的实际需求是这样的：</p>
<img src="/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/1.png" title="实际想要的效果">
<p>即，使用<code>visibility: hidden</code>，不显示（同时，仍然占有原来的位置）第一条的“向上箭头”，不显示（同时，仍然占有原来的位置）最后一条的“向下箭头”。<br>代码段为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng-style="&#123;'visibility': $last ? 'hidden' : 'visible'&#125;"</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>$last</code>为变量或是表达式。</p>
<h1 id="ng-hide"><a href="#ng-hide" class="headerlink" title="ng-hide"></a>ng-hide</h1><p>我们将第一条的<code>visibility: hidden</code>，更改为<code>ng-hide</code><br>修改前：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">ng-style</span>=<span class="string">"&#123;'visibility': $first ? 'hidden' : 'visible'&#125;"</span> <span class="attr">ng-click</span>=<span class="string">"upAccuracy(data)"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-caret-square-o-up text-success"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&amp;nbsp;</span><br></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0);"</span> <span class="attr">ng-hide</span>=<span class="string">"$first"</span> <span class="attr">ng-click</span>=<span class="string">"upAccuracy(data)"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-caret-square-o-up text-success"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&amp;nbsp;</span><br></pre></td></tr></table></figure></p>
<p>修改后效果：</p>
<img src="/2017/09/28/Make-element-visibility-but-not-hidden-in-AngularJs/2.png" title="bug效果">
<p>我们看到，通过<code>ng-hide</code>后，后面的元素视为该元素不存在，所以占用了隐藏元素原来的位置。而使用<code>ng-style=&quot;{&#39;visibility&#39;: express ? &#39;hidden&#39; : &#39;visible&#39;}&quot;</code>后，虽然其隐藏掉了，但后面的元素依然视该元素存在。近而保持了格式的统一。</p>
<p>参考：<a href="https://stackoverflow.com/questions/26927585/visibility-hidden-in-angularjs" target="_blank" rel="noopener">https://stackoverflow.com/questions/26927585/visibility-hidden-in-angularjs</a></p>
<p>google关键字：<code>ng-hide visibility hidden</code></p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AngularJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[统计实验数据的步骤]]></title>
      <url>/2017/09/28/The-steps-of-laboratory-data-statistics-data/</url>
      <content type="html"><![CDATA[<p>本年一次的数据统计总是耗费过多的时间，现将统计步骤总结如下：<br><a id="more"></a></p>
<h1 id="安装统计软件"><a href="#安装统计软件" class="headerlink" title="安装统计软件"></a>安装统计软件</h1><p>该软件建议安装在win7上。<br>进行QQ邮箱，查找关键字：实验室统计软件及数据。<br>下载相关的软件及往年的数据。安装后，将往年的数据解压到安装软件对应的数据的位置上。</p>
<p>注意：如果软件进行重新安装，那么卸载后，还需要手工删除原来的程序文件夹，否则在安装过程中，不提示使用钥匙盘，将报错。</p>
<h1 id="较验历史数据"><a href="#较验历史数据" class="headerlink" title="较验历史数据"></a>较验历史数据</h1><p>当使用新库（教务处给的），替换掉原来的老库时，需要对数据较验。发现较验错误后，查看是否为新库的字段与老库不一致造成了问题，如果出现该问题，则需要在数据维护时注意。</p>
<h1 id="获取实验数据"><a href="#获取实验数据" class="headerlink" title="获取实验数据"></a>获取实验数据</h1><p>找到本学年所有实验室1-16周的实验数据，并整理到A4纸上。统计的格式如下：</p>
<p>课程名称 实验教师 上课班级 上课总人数 实验室</p>
<h1 id="获取班级人数"><a href="#获取班级人数" class="headerlink" title="获取班级人数"></a>获取班级人数</h1><p>班级人数可以找楼下教学秘书获取，也可以查看年末的监考信息，在监考信息中，有每个班级的人数。计算后，补充到整理的A4纸上，以备录入。</p>
<h1 id="数据录入"><a href="#数据录入" class="headerlink" title="数据录入"></a>数据录入</h1><p>如果有新教师加入，需要先进行教师管理，维护新的教师信息。</p>
<p>修改本学年的实验数据，除需要保证所有的 <code>*</code> 的字段都正确以外，还需要选择任课教师，填写上课班级。<br>注意：同一门课程可以合并。</p>
<p>建议安装VF软件，统一删除上学年有，而本学年没有数据。在软件中，逐条删除设置的不合理。</p>
<p>删除完不该存在历史数据后，添加新的数据。</p>
<p>如果是新课程，则需要先维护课程名以及课程对应的多个实验名。该信息，需要参考教学计划，教学计划找主老师协助。</p>
<h1 id="较验数据"><a href="#较验数据" class="headerlink" title="较验数据"></a>较验数据</h1><p>数据填写完毕后，点击数据较验，较验系统数据。正常来讲，如果开始较难过数据，就已经早早的发现基本库发生的变化，在填写数据时，肯定也已经注意到了。所以此时的较验压力会小很多。</p>
<h1 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h1><p>点击 系统维护 数据备份 选择所有的数据进行备份，然后进行备份文件夹，打包发给教务处。</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tute </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在本地使用hexo发表文章]]></title>
      <url>/2017/09/28/how-to-use-hexo-in-local/</url>
      <content type="html"><![CDATA[<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p><code>hexo</code>是nodejs下的一个小软件，我们需要使用npm进行安装.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hexo</code>在创建新项目时，会使用<code>git</code>命令。如果你是新队员，那么在安装<code>hexo-cli</code>前，还需要安装<code>github</code>或<code>git</code>。</p>
</blockquote>
<h1 id="clone团队项目"><a href="#clone团队项目" class="headerlink" title="clone团队项目"></a>clone团队项目</h1><p>项目地址： <code>https://github.com/yunzhiclub/hexo</code><br>clone后，使用命令行，进入所在文件夹。进行<code>npm</code>依赖安装：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>clone主题<br>团队blog的主题在原第三方主题的基础上，进行了个性化的设置。设置后的内容上传到了团队的仓库中，当前团队应用的主题为：hext(具体可以查看根目录下的.travis.yml文件)。<br>我们依然在项目的根目录下，执行以下命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/mengyunzhi/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<p>操作后，你将在<code>themes</code>文件夹上得到一个<code>next</code>文件夹，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── source</span><br><span class="line">│   ├── _posts</span><br><span class="line">│   ├── categories</span><br><span class="line">│   ├── images</span><br><span class="line">│   └── tags</span><br><span class="line">└── themes</span><br><span class="line">    └── next</span><br></pre></td></tr></table></figure></p>
<h1 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h1><p>在项目master分支的基础上，新建自己的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b yourBranchName(替换为你分支的名字，比如xiaoming)</span><br></pre></td></tr></table></figure></p>
<h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>项目启动后，我们便可以在浏览器中打开<code>http://localhost:4000/</code>来实时阅览项目了。</p>
<h1 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;new title&quot;</span><br></pre></td></tr></table></figure>
<p>这里标题尽量使用英文。命令成功执行后，将在<code>source/_posts</code>下生成新的文章。</p>
<p>比如：<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: new title</span><br><span class="line">date: 2017-05-31 16:57:35</span><br><span class="line">tags: </span><br><span class="line">category: </span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里，我们尽量的采用英文的名称先进行命名，因为它会自动我们生成文件名。在文件名中保证不出现中文，是个好个习惯。</p>
</blockquote>
<p>然后：我们将这里的<code>title</code>修改为中文。<code>tags</code>是标签，如果是多个，可以这样写:<code>[html,css]</code>。<br><code>category</code>类别，这里写上自己的名字。</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 如何在本地使用hexo发表文章</span><br><span class="line">date: 2017-05-31 16:57:35</span><br><span class="line">tags: hexo</span><br><span class="line">category: teacherPan</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>最后，就是我们使用markdown语言进行BLOG的写作了。</p>
<p>内容完成后，像我们参与其它的团队项目的开发一样，进行<code>pull request</code>。代码审核后，你的文章将自动的出现在<a href="http://www.mengyunzhi.cn">http://www.mengyunzhi.cn</a>中.</p>
<hr>
<p>更多内容请参考 ：<a href="https://hexo.io/docs/index.html" target="_blank" rel="noopener">https://hexo.io/docs/index.html</a></p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[旅游项目如何实现手机预览]]></title>
      <url>/2017/09/22/localhost-pc-phone/</url>
      <content type="html"><![CDATA[<p>当我们真的想实现手机微信扫一扫实现预览网页的功能的时候我们不必将项目放在服务器上，本地也可以。</p>
<a id="more"></a>
<p><strong>环境</strong> : ubuntu16.04，android手机</p>
<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>首先我们在终端输入<code>ifconfig</code>来查看本机的ip地址。<br><img src="/2017/09/22/localhost-pc-phone/选区_010.png" alt=""> </p>
<h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>然后我们打开<code>index/view/article/preview.html</code> 将配置原来的url配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;:ROOT_DOMAIN&#125;/index/article/main?articleId=&#123;$articleId&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.0.101:80/beautifulArtical/thinkphp/public/index/article/main?articleId=&#123;$articleId&#125;</span><br></pre></td></tr></table></figure>
<p>然后此时我们扫描二维码就可以用微信预览了。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>当我们输入url的时候电脑会发送给DNS服务器解析出此域名对应的ip地址，然后我们的电脑才会向路由器发送数据包，然后路由器根据目的ip找到相应的电脑。但是如果我们直接输入ip地址，现在我们的手机机会向路由器和本局域网下的所有电脑发送数据包，然后我的电脑和路由器会同时接收到这个数据包，但是路由器会丢弃这个数据包，因为路由器根据转发表发现此ip地址位于本局域网的一台电脑，而我的电脑则会向我的手机发送具体的数据包，这样手机上就可以访问localhost的网页内容了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我本已经学过了计算机网络，这是最简单的道理，但自己却没有想到。用课本知识解决实际问题的能力还是太差。</p>
]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[安装protracto记]]></title>
      <url>/2017/09/19/how-to-install-protracto/</url>
      <content type="html"><![CDATA[<p><code>protracto</code>是<code>angularjs</code>下的一个<code>E2E</code>集成测试工具。所谓集成测试，就是把各个模块开发完，对接好后，一起跑一下系统，然后看各个模块的关联是否有问题。</p>
<p>我们在项目中，往往通过手工点击的方法来完成集成测试。由于每个人对项目的理解都不一致，加之每次测试的状态及我们所处的环境不同。导致了前后可能测试了100次，但却使用了100次不同的测试步骤。</p>
<p>有了集成测试工具，我们只需要把相关点击和输入的操作放在代码中，然后看着浏览器自动为我们执行操作就可以了。</p>
<p>我们还可以像单元测试一样，写一些断言。当测试跑完，系统会自动告诉我们哪些测试没有通过，期待的值是什么，又实际返回了什么值。</p>
<a id="more"></a>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>我进行安装前，首先，我找到了官方文档：<br><a href="http://www.protractortest.org/#/tutorial" target="_blank" rel="noopener">http://www.protractortest.org/#/tutorial</a></p>
<p>然后就是按照官方文档的步骤进行安装。<br>官方文档的介绍，大体分为以下几步。</p>
<ol>
<li>安装protractor</li>
<li>升级webdriver-manager</li>
<li>启动webdriver-manager</li>
<li>写测试文件</li>
<li>写配置文件</li>
<li>运行第一个测试</li>
<li>完善测试</li>
</ol>
<p>首先，我们先进入<code>angularjs</code>的项目根目录，比如<code>webApp</code>。</p>
<h1 id="安装protractor"><a href="#安装protractor" class="headerlink" title="安装protractor"></a>安装protractor</h1><p>安装protractor，我们需要使用命令：<br><code>npm install -g protractor</code><br>这代码着，<code>protractor</code>依赖于<code>nodejs</code>.</p>
<h1 id="升级webdriver-manager"><a href="#升级webdriver-manager" class="headerlink" title="升级webdriver-manager"></a>升级webdriver-manager</h1><p>使用命令：<br><code>webdriver-manager update</code></p>
<p>实际的安装中，我遇到了以下问题：</p>
<ul>
<li><code>nodejs</code>版本较低，导致输入上述命令时，提示语法错误（高版本新的语法，低版本的<code>nodejs</code>不支持）</li>
<li>提示发生了<code>access</code>权限问题</li>
<li>在线更新包时，发生了超时连接的错误</li>
</ul>
<p>解决方法如下：</p>
<ul>
<li>进入<code>nodejs</code>官网，下载最新版本的<code>nodejs</code>并安装.</li>
<li>在使用命令时，使用<code>sudo webdriver-manager update</code>（windows权限问题，请<code>google</code>解决）</li>
<li>由于我使用了<code>shadowsocks</code>做为代理，<code>shadowsocks</code>仅支持<code>Socks5</code>代理方式，但我们的<code>shell</code>仅支持<code>http</code>,所以我们需要需要解决将<code>Socks5</code>转化为<code>http</code>的问题。<ul>
<li>使用<code>brew install privoxy</code>命令，安装了并配置了<code>privoxy</code>，将<code>socks</code>代理变为<code>http</code>代理。</li>
<li>使用<code>webdriver-manager --help</code>命令，获取到我可以使用<code>--proxy</code>参数来指定代理。</li>
<li>使用<code>sudo webdriver-manager update --proxy=http://127.0.0.1:8118</code>来完成了更新操作.</li>
</ul>
</li>
</ul>
<p>MAC系统安装与配置<code>privoxy</code>请参考:<code>http://www.iosugar.com/2017/02/19/Mac-terminal-environment/</code><br>大体总结如下：1.安装privoxy 2.配置privoxy 3. 启动privoxy 4.将privoxy设置为开机自启动(在~/user(你的用户名)下，修改<code>.bash_profile</code>, 并增加<code>/usr/local/sbin/privoxy /usr/local/etc/privoxy/config</code>一行)</p>
<h1 id="启动webdriver-manager"><a href="#启动webdriver-manager" class="headerlink" title="启动webdriver-manager"></a>启动webdriver-manager</h1><p>同样，我使用了官方的<code>webdriver-manager start</code>来尝试启动这个应用。运气不太好，获取了无法执行的错误。<code>google</code>查询后，得到了当前路径的<code>node_modules</code>中不存在<code>webdriver-manager</code>导致出错的原因。观察<code>package.json</code>发现，的确未自动写入关于<code>protracto</code>。再经过查询，得到以下文章，并主要进行了参考：</p>
<p><a href="http://thejackalofjavascript.com/end-to-end-testing-with-protractor/" target="_blank" rel="noopener">http://thejackalofjavascript.com/end-to-end-testing-with-protractor/</a></p>
<p>略过前面安装<code>yoman</code>的部分，分别执行以下语句：<br><code>npm i protractor --save-dev</code><br><code>sudo ./node_modules/protractor/bin/webdriver-manager update --proxy=http://127.0.0.1:8118</code><br><code>sudo ./node_modules/protractor/bin/webdriver-manager start</code><br>服务成功启动。</p>
<blockquote>
<p>我们将服务窗口最小化(注意：不是关闭)，然后继续操作。再次启动时，需要先启动privoxy，再执行以上的update及start</p>
</blockquote>
<h1 id="写测试文件"><a href="#写测试文件" class="headerlink" title="写测试文件"></a>写测试文件</h1><p>在<code>test</code>文件夹中，新建<code>e2e</code>文件夹，及<code>login</code>文件。</p>
<img src="/2017/09/19/how-to-install-protracto/1.png" title="新建文件">
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Protractor Demo App'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'should have a title'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    browser.get(<span class="string">''</span>);        <span class="comment">// 打开根地址（相对于配置文件的baseUrl）</span></span><br><span class="line">    expect(browser.getTitle()).toEqual(<span class="string">'计量器具管理平台'</span>); <span class="comment">// 断言标题</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="写配置文件"><a href="#写配置文件" class="headerlink" title="写配置文件"></a>写配置文件</h1><p>在根目录中，我们建立<code>protractor-e2e.js</code>，并加入以下配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">exports.config = &#123;</span><br><span class="line">    <span class="comment">// 运行所有的脚本的最长时间</span></span><br><span class="line">    allScriptsTimeout: <span class="number">99999</span>,</span><br><span class="line">    <span class="comment">// The address of a running selenium server.前面，我们使用start命令启动的服务地址</span></span><br><span class="line">    seleniumAddress: <span class="string">'http://localhost:4444/wd/hub'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Capabilities to be passed to the webdriver instance. 测试兼容性的浏览器设置</span></span><br><span class="line">    capabilities: &#123;</span><br><span class="line">        <span class="string">'browserName'</span>: <span class="string">'chrome'</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 项目地址</span></span><br><span class="line">    baseUrl: <span class="string">'http://localhost:9000/'</span>,</span><br><span class="line"></span><br><span class="line">    framework: <span class="string">'jasmine'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spec patterns are relative to the current working directly when</span></span><br><span class="line">    <span class="comment">// protractor is called.</span></span><br><span class="line">    <span class="comment">// 测试文件所在位置（使用的是表达式）</span></span><br><span class="line">    specs: [<span class="string">'test/e2e/*.js'</span>],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Options to be passed to Jasmine-node.</span></span><br><span class="line">    <span class="comment">// 其它选项</span></span><br><span class="line">    jasmineNodeOpts: &#123;</span><br><span class="line">        showColors: <span class="literal">true</span>,</span><br><span class="line">        defaultTimeoutInterval: <span class="number">30000</span>,</span><br><span class="line">        isVerbose: <span class="literal">true</span>,</span><br><span class="line">        includeStackTrace: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="运行第一个测试"><a href="#运行第一个测试" class="headerlink" title="运行第一个测试"></a>运行第一个测试</h1><p><code>./node_modules/protractor/bin/protractor protractor-e2e.js</code><br>此时，浏览器当自动当前我们测试文件中设置的地址，然后获取标题信息，并进行断言。</p>
<h1 id="完善测试"><a href="#完善测试" class="headerlink" title="完善测试"></a>完善测试</h1><p>继续完善login.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* https://github.com/angular/protractor/blob/master/docs/getting-started.md */</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'my app'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    browser.ignoreSynchronization = <span class="literal">true</span>;</span><br><span class="line">    browser.waitForAngular();</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        browser.get(<span class="string">''</span>);    <span class="comment">// 每次测试前，都先尝试打开根目录</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'自动跳转至用户登录界面'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(browser.getTitle()).toEqual(<span class="string">'计量器具管理平台'</span>); <span class="comment">// 获取并断言标题</span></span><br><span class="line">        <span class="comment">// 获取当前的url信息，并断言必然跳转至/login</span></span><br><span class="line">        browser.driver.getCurrentUrl().then(<span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">var</span> absUrl = url.split(<span class="string">'#!'</span>);</span><br><span class="line">            expect(absUrl[<span class="number">1</span>]).toEqual(<span class="string">'/login'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">'正确的用户名密码进行登录'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获取username password和登录按钮</span></span><br><span class="line">        <span class="keyword">var</span> username = element(by.model(<span class="string">'user.username'</span>));</span><br><span class="line">        <span class="keyword">var</span> password = element(by.model(<span class="string">'user.password'</span>));</span><br><span class="line">        <span class="keyword">var</span> login = element(by.partialButtonText(<span class="string">'登'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动输入用户名和密码</span></span><br><span class="line">        username.sendKeys(<span class="string">'admin'</span>);</span><br><span class="line">        password.sendKeys(<span class="string">'admin'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前击登录</span></span><br><span class="line">        login.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟3秒等待系统完成登录</span></span><br><span class="line">        browser.driver.sleep(<span class="number">3000</span>);</span><br><span class="line">        browser.waitForAngular();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前地址为首页的仪表台地址</span></span><br><span class="line">        browser.driver.getCurrentUrl().then(<span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> absUrl = url.split(<span class="string">'#!'</span>);</span><br><span class="line">            expect(absUrl[<span class="number">1</span>]).toEqual(<span class="string">'/main/dashboard'</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(url);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>重新启动测试，效果如下图：</p>
<img src="/2017/09/19/how-to-install-protracto/1.gif" title="新建文件">
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>安装环境是一项具有挑战性的工作。它能够考验自己对工具掌握及理解的情况。如果我们在安装环境中碰到了问题，要尝试着去翻译各种提示的英文文字，然后借助<code>google</code>去找到问题的原因及解决方案。</p>
<p>注：安装顺利.</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AngularJS </tag>
            
            <tag> protracto </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php + xdebug + phpstrom断点调试]]></title>
      <url>/2017/09/18/php-xdebug-phpstorm/</url>
      <content type="html"><![CDATA[<p>我们说<code>sublime</code>和<code>xdebug</code>调试php程序的时候数组变量有的时候不能显示完全，所以就给我们调试程序带来了不方便，如果使用<code>var_dump</code>又太浪费时间（可能是因为本人技术水平不佳）。</p>
<a id="more"></a>
<p><strong>环境</strong>: Ubuntu16.04, lampp, phpStorm</p>
<h2 id="download-xdebug"><a href="#download-xdebug" class="headerlink" title="download xdebug"></a>download xdebug</h2><p>我们可以新建一个php文件，然后写上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phpinfo();</span><br></pre></td></tr></table></figure></p>
<p>来查看自己安装php的具体信息，以方便我们找到合适自己的<code>xdebug</code><br><img src="/2017/09/18/php-xdebug-phpstorm/phpinfo.png" alt=""> </p>
<p>然后我们打开网址<a href="https://xdebug.org/wizard.php" target="_blank" rel="noopener">https://xdebug.org/wizard.php</a> <code>Ctrl + A</code>全选将自己的php信息输入到空白页面。<br>点击<strong>Analyse my phpinfo() output</strong></p>
<p>然后<code>xdebug</code>官网就会推荐合适xdebug版本而且给出详尽的安装步骤。</p>
<h2 id="install-xdebug"><a href="#install-xdebug" class="headerlink" title="install xdebug"></a>install xdebug</h2><p>下面的步骤因为个人安装路径的不同而不同，不用担心，因为<code>xdebug</code>官网分析的已经非常到位了，只要能简单读懂英语相信都可以安装成功。</p>
<h3 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvzf xdebug-2.5.4.tgz</span><br><span class="line">cd xdebug-2.5.4/</span><br><span class="line">phpize</span><br></pre></td></tr></table></figure>
<p>然后我们会发现提示以下错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序“phpize”尚未安装。 您可以使用以下命令安装：</span><br><span class="line">sudo apt install php7.0-dev</span><br></pre></td></tr></table></figure>
<h3 id="install-php7-0-dev"><a href="#install-php7-0-dev" class="headerlink" title="install php7.0-dev"></a>install php7.0-dev</h3><p>我们安装提示继续进行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install php7.0-dev</span><br><span class="line">sudo phpize</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo cp modules/xdebug.so /opt/lampp/lib/php/extensions/no-debug-non-zts-20151012</span><br></pre></td></tr></table></figure>
<h3 id="编辑php-ini"><a href="#编辑php-ini" class="headerlink" title="编辑php.ini"></a>编辑php.ini</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit /opt/lampp/etc/php.ini</span><br></pre></td></tr></table></figure>
<p>最后一行添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">zend_extension = /opt/lampp/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so</span><br><span class="line">//调试信息代码使用</span><br><span class="line">xdebug.remote_host = 127.0.0.1</span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line">xdebug.remote_port = 9000</span><br><span class="line">xdebug.remote_handler = dbgp</span><br><span class="line">xdebug.remote_mode = req</span><br></pre></td></tr></table></figure>
<h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/lampp/lampp restart</span><br></pre></td></tr></table></figure>
<p>然后我们重复第一步查看自己的php信息发现<code>xdebug</code>安装成功<br><img src="/2017/09/18/php-xdebug-phpstorm/xdebug.png" alt=""> </p>
<h2 id="install-Xdebug-extension-helper"><a href="#install-Xdebug-extension-helper" class="headerlink" title="install Xdebug extension helper"></a>install Xdebug extension helper</h2><h3 id="google-chrome"><a href="#google-chrome" class="headerlink" title="google chrome"></a>google chrome</h3><p>插件安装地址<br><a href="https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc?hl=en" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc?hl=en </a> </p>
<p>因为<code>google</code>被墙了，如果想要安装所以请自行在<code>github</code> or <code>老D</code>上下载<code>hosts</code>。</p>
<h3 id="IDEKey"><a href="#IDEKey" class="headerlink" title="IDEKey"></a>IDEKey</h3><p>在<code>Xdebug extension helper</code>的<code>选项</code> 中 <code>IDE key</code>   中选择<code>phpStorm</code>。<br><img src="/2017/09/18/php-xdebug-phpstorm/xdebug_helper.png" alt=""> </p>
<p>开启<code>Xdebug extension helper</code>调试模式<br><img src="/2017/09/18/php-xdebug-phpstorm/xdebug_start.gif" alt=""> </p>
<h2 id="配置PhpStorm"><a href="#配置PhpStorm" class="headerlink" title="配置PhpStorm"></a>配置PhpStorm</h2><p>然后我们打开phpStorm中<code>Run</code> , <code>Start Listening for PHP Debug Connections.</code><br>然后我们就可以调试了:<br><img src="/2017/09/18/php-xdebug-phpstorm/break_point.png" alt=""> </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://blog.csdn.net/dm_vincent/article/details/44678347" target="_blank" rel="noopener">[PHP+xdebug] 在Ubuntu 14.04下的PhpStorm中配置xdebug调试环境</a><br><a href="https://confluence.jetbrains.com/display/PhpStorm/Zero-configuration+Web+Application+Debugging+with+Xdebug+and+PhpStorm" target="_blank" rel="noopener">Zero-configuration Web Application Debugging with Xdebug and PhpStorm</a> </p>
]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[两个sql.Date日期相减的方法]]></title>
      <url>/2017/08/23/how-to-sub-two-sql-date/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何给某个java.sql.Date加上固定的天数]]></title>
      <url>/2017/08/23/how-to-add-days-to-java-sql-date/</url>
      <content type="html"><![CDATA[<p>在计量项目中，碰到了如下问题：</p>
<ol>
<li>计量器具设置了上次的检定日期。</li>
<li>计量器具设置了检定周期（天）</li>
</ol>
<p>我们想得到：计量器具下次应该去进行检定的时间。</p>
<p>算法：上次的检定日期 + 检定周期 = 下次应该检定的日期。<br><a id="more"></a></p>
<hr>

<p>那么，在JAVA中，是如何做到在一个日期类型上加入固定的天数呢？<br>这里我们需要用到借助<code>Calendar</code>类中的<code>add</code>方法来实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * java.sql.Date加上固定的天数</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span>    &#123;java.sql.Date&#125;                 java.sql.Data date 原始日期</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span>    &#123;int&#125;                 int           days 加上的天数</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@author</span> 梦云智 http://www.mengyunzhi.com</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@DateTime</span> 2017-09-19T14:56:25+0800</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> java.sql.<span class="function">Date <span class="title">addDate</span><span class="params">(java.sql.Data date, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">            java.util.Calendar calendar = java.util.Calendar.getInstance();   <span class="comment">// 实例化</span></span><br><span class="line">            calendar.setTime(date);                                           <span class="comment">// 设置日期</span></span><br><span class="line">            calendar.add(calendar.DATE, days);                                <span class="comment">// 与 天数 相加</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> java.sql.Date(calendar.getTimeInMillis());             <span class="comment">// 使用calendar.getTimeInMillis()实例化java.sql.Date</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> sql.Date </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学入学习JPA的@ManyToMany注解 study jpa @ManyToMany deeply]]></title>
      <url>/2017/08/09/study-jpa-ManyToMany-deeply/</url>
      <content type="html"><![CDATA[<p>在JPA中，实间的关系属<code>@ManyToMany</code>最难理解，使用起来最为复杂。当存在某个实体的关键字由多个属性组成时，复杂程序就更大了。借此， 我们以以下ER图为例，对<code>@ManyToMany</code>进行一次深入学习。</p>
<p>ER图如下：<br><img src="/2017/08/09/study-jpa-ManyToMany-deeply/1.png" title="ER图"><br><a id="more"></a></p>
<h1 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h1><h2 id="标准装置实体"><a href="#标准装置实体" class="headerlink" title="标准装置实体"></a>标准装置实体</h2><p>普通的实体，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="meta">@Entity</span> <span class="meta">@ApiModel</span>(value = <span class="string">"DeviceSet (计量标准装置)"</span>, description = <span class="string">"计量标准装置实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceSet</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// setter/getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="授权检定项目实体"><a href="#授权检定项目实体" class="headerlink" title="授权检定项目实体"></a>授权检定项目实体</h2><p>该实体的主键由两个外键组成(如何使用组合键，并不属于本文的讨论范围)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"DeviceInstrument (装置授权检定项目)"</span>, description = <span class="string">"装置授权检定项目实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceInstrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Embeddable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Id</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;        <span class="comment">//封装组合健</span></span><br><span class="line">        <span class="meta">@Column</span>(name = <span class="string">"accuracy_id"</span>, nullable = <span class="keyword">false</span>, insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> Long accuracyId;</span><br><span class="line">        <span class="meta">@Column</span>(name = <span class="string">"measure_scale_id"</span>, nullable = <span class="keyword">false</span>, insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> Long measureScaleId;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Id</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Id</span><span class="params">(Long accuracyId, Long measureScaleId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.accuracyId = accuracyId;</span><br><span class="line">            <span class="keyword">this</span>.measureScaleId = measureScaleId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getMeasureScaleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> measureScaleId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasureScaleId</span><span class="params">(Long measureScaleId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.measureScaleId = measureScaleId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Long <span class="title">getAccuracyId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> accuracyId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccuracyId</span><span class="params">(Long accuracyId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.accuracyId = accuracyId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Id)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            Id id = (Id) o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!measureScaleId.equals(id.measureScaleId)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> accuracyId.equals(id.accuracyId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = measureScaleId.hashCode();</span><br><span class="line">            result = <span class="number">31</span> * result + accuracyId.hashCode();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EmbeddedId</span>                 <span class="comment">//映射组合建</span></span><br><span class="line">    <span class="keyword">private</span> Id id = <span class="keyword">new</span> Id();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"对应的测量范围"</span>)        <span class="comment">//关联测量范围</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> MeasureScale measureScale;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"对应的精度"</span>)         <span class="comment">//关联精度</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Accuracy accuracy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它set/get代码省略，下同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="默认-ManyToMany"><a href="#默认-ManyToMany" class="headerlink" title="默认@ManyToMany"></a>默认@ManyToMany</h1><h2 id="标准装置实体-1"><a href="#标准装置实体-1" class="headerlink" title="标准装置实体"></a>标准装置实体</h2><p>我们在该实体中加入多对多的字段，查看其为我们生成的默认字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="meta">@ApiModel</span>(value = <span class="string">"DeviceSet (计量标准装置)"</span>, description = <span class="string">"计量标准装置实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceSet</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"对应的装置授权检定项目"</span>)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;DeviceInstrument&gt; deviceInstruments = <span class="keyword">new</span> HashSet&lt;DeviceInstrument&gt;();</span><br></pre></td></tr></table></figure></p>
<p>进行单元测试：<br><img src="/2017/08/09/study-jpa-ManyToMany-deeply/2.png" title="表基本结构"></p>
<img src="/2017/08/09/study-jpa-ManyToMany-deeply/1.gif" title="表主键及外键">
<p>最终，我们得出以下结论：</p>
<blockquote>
<p>当一个普通实体与另一个组合主键实体进行多对多关联系时:</p>
</blockquote>
<ol>
<li>为了保存多对多关系，JPA为我们自动创建一个中间表。表名为：<code>本表名_关联表名s</code></li>
<li>此表为我们生成了三个字段，三个字段均为主键。</li>
<li>其中一个主键与 <code>普通实体</code> 主键相关联，命名为：<code>表名_主键名</code></li>
<li>另两个主键组合在一起，与 <code>组合主键实体</code> 的组合主键相关联。命名为：<code>表名s_主键名</code></li>
</ol>
<h2 id="授权检定项目实体-1"><a href="#授权检定项目实体-1" class="headerlink" title="授权检定项目实体"></a>授权检定项目实体</h2><p>同样，我们加入默认的多对多注解，不做任何设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"DeviceInstrument (装置授权检定项目)"</span>, description = <span class="string">"装置授权检定项目实体"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceInstrument</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参考网址http://codego.net/144328/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@EmbeddedId</span>                 <span class="comment">//映射组合建</span></span><br><span class="line">    <span class="keyword">private</span> Id id = <span class="keyword">new</span> Id();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"对应的测量范围"</span>)        <span class="comment">//关联测量范围</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> MeasureScale measureScale;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"对应的精度"</span>)         <span class="comment">//关联精度</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(insertable = <span class="keyword">false</span>, updatable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Accuracy accuracy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;DeviceSet&gt; deviceSets;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，任意进行单元测试，重新生成数据表：<br><img src="/2017/08/09/study-jpa-ManyToMany-deeply/3.png" title="表基本结构"></p>
<img src="/2017/08/09/study-jpa-ManyToMany-deeply/2.gif" title="表主键及外键">
<p>最终，我们得出以下结论：</p>
<blockquote>
<p>当一个组合主键实体与另一个普通实体进行多对多关联系时:</p>
</blockquote>
<ol>
<li>为了保存多对多关系，JPA为我们自动创建一个中间表。表名为：<code>本表名_关联表名s</code></li>
<li>此表为我们生成了三个字段，三个字段均为主键</li>
<li>其中一个主键与 <code>普通实体</code> 主键相关联，命名为：<code>表名s_主键名</code></li>
<li>另两个主键组合在一起，与 <code>组合主键实体</code> 的组合主键相关联。命名为：<code>表名_主键名</code></li>
</ol>
<p>我们将以上规律进行总结后不难得出：</p>
<ol>
<li>为了保存多对多关系，JPA为我们自动创建一个中间表。表名为：本表名_关联表名s</li>
<li>此表为我们生成了三个字段，三个字段均为主键</li>
<li>其中一组主键（可能是一个，也可以是多个）与本实体主键相关联，命名为：<code>表名_主键名0</code>, <code>表名_主键名1</code></li>
<li>另一组主键(可能是一个，也可以是多个)关联实体相关联，命名为：<code>关联实体表名s_主键名0</code>, <code>关联实体表名s_主键名1</code></li>
</ol>
<h1 id="自定义多对多"><a href="#自定义多对多" class="headerlink" title="自定义多对多"></a>自定义多对多</h1><p>两个<code>@ManyToMany</code>虽然已经生效，但是却生成了两张数据表，而且这两张表对应的字段也不一样，那么如何使用一个数据表来存储两个实体的<code>@ManyToMany</code>关系呢？</p>
<h2 id="统一字段"><a href="#统一字段" class="headerlink" title="统一字段"></a>统一字段</h2><p>两个表合一的前提是字段名统一，由于上述第4点原因，导致关联实体的字段名中有个多余的<code>s</code>，下面，我们使用注解来自定义自段名称.</p>
<h3 id="标准装置实体-2"><a href="#标准装置实体-2" class="headerlink" title="标准装置实体"></a>标准装置实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceSet</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"对应的装置授权检定项目"</span>)</span><br><span class="line">    <span class="meta">@JoinTable</span>(</span><br><span class="line">        joinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"device_set_id"</span>, referencedColumnName = <span class="string">"id"</span>)&#125;</span><br><span class="line">        inverseJoinColumns = &#123;</span><br><span class="line">                <span class="meta">@JoinColumn</span>(name = <span class="string">"accuracy_id"</span>, referencedColumnName = <span class="string">"accuracy_id"</span>),</span><br><span class="line">                <span class="meta">@JoinColumn</span>(name = <span class="string">"measure_scale_id"</span>, referencedColumnName = <span class="string">"measure_scale_id"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">private</span> Set&lt;DeviceInstrument&gt; deviceInstruments = <span class="keyword">new</span> HashSet&lt;DeviceInstrument&gt;();</span><br></pre></td></tr></table></figure>
<p><code>@JoinTable</code>有两个(不止这两个)重要的属性：<code>joinColumns</code>(关联列）和<code>inverseJoinColumns</code>(反关联列), 在这里，它们的主体都是系统为我们生成的中间表。<br><code>joinColumns = {@JoinColumn(name = &quot;device_set_id&quot;, referencedColumnName = &quot;id&quot;)}</code>译为：<br>关联列属性：本表（系统生成的中间表）中的<code>device_set_id</code>关联当前实体的<code>id</code>字段。</p>
<p><hr><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inverseJoinColumns = &#123;</span><br><span class="line">        <span class="meta">@JoinColumn</span>(name = <span class="string">"accuracy_id"</span>, referencedColumnName = <span class="string">"accuracy_id"</span>),</span><br><span class="line">        <span class="meta">@JoinColumn</span>(name = <span class="string">"measure_scale_id"</span>, referencedColumnName = <span class="string">"measure_scale_id"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>译为：</p>
<p>反（上面自动关系的当前实体，这个“反”字，代表关联ToMany的另一个实体）关联列属性： 1. 本表（系统生成的中间表）中的<code>accuracy_id</code>字段，关联另一个实体的<code>accuracy_id</code>字段; 2.  本表（系统生成的中间表）中的<code>measure_scale_id</code>字段，关联另一个实体（授权检定项目）的<code>measure_scale_id</code>字段;</p>
<p>我们启动单元测试：<br><img src="/2017/08/09/study-jpa-ManyToMany-deeply/4.png" title="表基本结构"></p>
<h3 id="授权检定项目实体-2"><a href="#授权检定项目实体-2" class="headerlink" title="授权检定项目实体"></a>授权检定项目实体</h3><p>有了前面的经验，下面就很简单了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceInstrument</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable</span>(</span><br><span class="line">            joinColumns = &#123;</span><br><span class="line">                    <span class="meta">@JoinColumn</span>(name = <span class="string">"accuracy_id"</span>, referencedColumnName = <span class="string">"accuracy_id"</span>),</span><br><span class="line">                    <span class="meta">@JoinColumn</span>(name = <span class="string">"measure_scale_id"</span>, referencedColumnName = <span class="string">"measure_scale_id"</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            inverseJoinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"device_set_id"</span>, referencedColumnName = <span class="string">"id"</span>)&#125;)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;DeviceSet&gt; deviceSets;</span><br></pre></td></tr></table></figure></p>
<p>同样，我们翻译一下：<br>joinColumns: 中间表字段关联属性：1. 本中间表的accuracy_id对应当前实体的accuracy_id; 2.本中间表的measure_scale_id对应当前实体的measure_scale_id<br>inverseJoinColumns: 中间表字段关联对方实体属性: 1. 本中间表的device_set_id字段，对应对方实体(标准装置)id字段。</p>
<p>单元测试略</p>
<h2 id="统一表名"><a href="#统一表名" class="headerlink" title="统一表名"></a>统一表名</h2><p>最后，我们统一使用<code>@JoinTable</code>的<code>name</code>属性，来统一表名，将以前系统合并的两张表，用一张表来表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToMany</span></span><br><span class="line"><span class="meta">@JoinTable</span>(</span><br><span class="line">        name = <span class="string">"device_set_device_instruments"</span>,</span><br><span class="line">        joinColumns = &#123;</span><br><span class="line">                <span class="meta">@JoinColumn</span>(name = <span class="string">"accuracy_id"</span>, referencedColumnName = <span class="string">"accuracy_id"</span>),</span><br><span class="line">                <span class="meta">@JoinColumn</span>(name = <span class="string">"measure_scale_id"</span>, referencedColumnName = <span class="string">"measure_scale_id"</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        inverseJoinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"device_set_id"</span>, referencedColumnName = <span class="string">"id"</span>)&#125;)</span><br><span class="line"><span class="keyword">private</span> Set&lt;DeviceSet&gt; deviceSets;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManyToMany</span></span><br><span class="line"><span class="meta">@ApiModelProperty</span>(<span class="string">"对应的装置授权检定项目"</span>)</span><br><span class="line"><span class="meta">@JoinTable</span>(</span><br><span class="line">        name = <span class="string">"device_set_device_instruments"</span>,</span><br><span class="line">        joinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"device_set_id"</span>, referencedColumnName = <span class="string">"id"</span>)&#125;,</span><br><span class="line">        inverseJoinColumns = &#123;</span><br><span class="line">                <span class="meta">@JoinColumn</span>(name = <span class="string">"accuracy_id"</span>, referencedColumnName = <span class="string">"accuracy_id"</span>),</span><br><span class="line">                <span class="meta">@JoinColumn</span>(name = <span class="string">"measure_scale_id"</span>, referencedColumnName = <span class="string">"measure_scale_id"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">private</span> Set&lt;DeviceInstrument&gt; deviceInstruments = <span class="keyword">new</span> HashSet&lt;DeviceInstrument&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>一直在多对多的问题上一知半解，使用的注解大多也来源于课本和网络。但最终掌握该问题最好最快最牢的方法仍然是“实战”。没错，通过半小时的实战，我们一点点的用代码测试出了<code>@JoinTable</code>的几个核心注解的功能。当以后再出现多对多注解时，我们知道：<br>1.当前注解的对象为：中间表。<br>2.关联的字段与反关联的字段，分别是指当前实体与对方实体。<br>3.关联的表名，字段名都可以自定义。<br>4.关联的字段，本来就是一个数组<code>{}</code>，这个数组中可以有一个参数，也可以有多个参数。</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jpa </tag>
            
            <tag> @ManyToMany </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决使用spring boot mvc的@JsonView注解返回page为空的问题]]></title>
      <url>/2017/07/30/spring-boot-mvc-JsonView-page-emtpy-object/</url>
      <content type="html"><![CDATA[<p>要<code>spring mvc</code>中，我们使用<code>@JsonView</code>注解来定义内容输出。但如果我们返回分页数据<code>Page</code>的话，却意外的行到了<code>{}</code>。这是由于<code>@JsonView</code>注解并没有在<code>Page</code>类型上起作用。所以导致返回类型为<code>Page</code>时，输出空内容。</p>
<a id="more"></a>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>针对此问题，网上的解决方案并不统一。最后，找到如下解决方案: 即对<code>WebMvcConfigurerAdapter</code>进行配置。重写<code>public void configureMessageConverters</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> Logger logger = Logger.getLogger(WebConfig.class.getName());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决spring mvc <span class="doctag">@jsonview</span> page empty(springMvc 使用jsonView时，返回page信息为空对象)的问题</span></span><br><span class="line"><span class="comment">     * 这个问题的解决方案适用的比较少，而且还有信息存在误导。</span></span><br><span class="line"><span class="comment">     * 最后总结下解决方法：</span></span><br><span class="line"><span class="comment">     * 1.绝对不能在配置文件中去配置那个 DEFAULT_VIEW_INCLUSION。</span></span><br><span class="line"><span class="comment">     * 如果这么做了，就会发现C层配置的JsonView会完全失去作用</span></span><br><span class="line"><span class="comment">     * 2. 本问题中，spring 官方社区的回答比stackoverflow 还要靠谱。</span></span><br><span class="line"><span class="comment">     * 在 https://jira.spring.io/browse/SPR-13331 的回答中，甚至有了给出了github的地址</span></span><br><span class="line"><span class="comment">     * 3. 参考代码时，要使其它的配置完全相同，比如我在参考时，就是在已经设置了DEFAULT_VIEW_INCLUSION为true的前提下；</span></span><br><span class="line"><span class="comment">     *    而这个配置项，参考代码中并没有。进而没有在第一时间内验证出参考代码的正确性。</span></span><br><span class="line"><span class="comment">     * 正确的可被参考的代码：https://github.com/sdeleuze/SpringSampleProject</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 总结：问题解决了大概两天的时间。开始低估了问题了难度，当发现初步找的答案并不能解决实际问题时。</span></span><br><span class="line"><span class="comment">     * 并没有沉下心来去看每一篇google到的文章。</span></span><br><span class="line"><span class="comment">     * 最后，静心的仔细的学习了每一篇文章，并找到了相关的示例代码，同时删除了按照其它方法配置的不适用配置项后。</span></span><br><span class="line"><span class="comment">     * 问题得以解决。</span></span><br><span class="line"><span class="comment">     * 所以：</span></span><br><span class="line"><span class="comment">     * 1. 当发现低估问题的难度的时候，确诊关键字没有问题，就要静心来学习。</span></span><br><span class="line"><span class="comment">     * 2. 每找到一个方法，都值得一试。但不要将两种解决方案同时试。试第一种不行，就要将代码进行恢复。</span></span><br><span class="line"><span class="comment">     * 然后才能继续试第二种。</span></span><br><span class="line"><span class="comment">     * 3. 读懂找到资料的每一行英文，这很重要！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        ObjectMapper mapper = Jackson2ObjectMapperBuilder.json().defaultViewInclusion(<span class="keyword">true</span>).build();</span><br><span class="line">        converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter(mapper));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在使用时，我们可以直接使用<code>@JsonView</code>在控制器上，如果我们未设置实体中的注解信息，则会发现什么变化都没有发生。<br>如果我们想排除某此字段，则需要如下使用：</p>
<p>假设我们有以下实体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="keyword">private</span> Klass klass;    <span class="comment">// 班级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 班级</span></span><br><span class="line">Class Klass &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"klass"</span>)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;&gt;();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h2><p>在输出学生时，输出班级信息，同时忽略班级中的<code>students</code><br>控制器如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/Student"</span>)</span><br><span class="line">Class StudentController &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(/&#123;id&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(@PathVar....)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>建立一个接口，并用这个接口注解<code>@ManyToOne</code>, <code>@OneToMany</code>.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NoneJsonView</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>加入注解，只有在控制器中使用<code>NoneJsonView</code>时，才会被序列化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JsonView</span>(NoneJsonView.class)</span><br><span class="line">    <span class="keyword">private</span> Klass klass;    <span class="comment">// 班级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 班级</span></span><br><span class="line">Class Klass &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"klass"</span>)</span><br><span class="line">    <span class="meta">@JsonView</span>(NoneJsonView.class)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;&gt;();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在建立一个接口，用以输出指定字段<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StudentGet</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于我们想输出学生的班级信息，所以将注解加入到学生的班级字段上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JsonView</span>(&#123;NoneJsonView.class, StudentGet.class&#125;)</span><br><span class="line">    <span class="keyword">private</span> Klass klass;    <span class="comment">// 班级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在控制器上加入注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/Student"</span>)</span><br><span class="line">Class StudentController &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(/&#123;id&#125;)</span><br><span class="line">    <span class="meta">@JsonView</span>(StudentGet.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">get</span><span class="params">(@PathVar....)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们在控制器上使用的注解为<code>@JsonView(StudentGet.class)</code>表示：只有未加注解或是加了注解并且对应<code>@JsonView(StudentGet.class)</code>的字段，才会被序列化。<br>由于<code>Stuent</code>的全部字段都符合上述的规则，所以全部会被序列化。<br>而<code>Klass</code>中的<code>stuents</code>字段，由于加入了<code>@JsonView(NoneJsonView.class)</code>，但该注解并不对应<code>@JsonView(StudentGet.class)</code>, 所以将不被序列化。</p>
<p>目标实现</p>
<h2 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h2><p>输出某个班级时，对应输出其班级上所有的学生，但自动忽略学生上的班级信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/Klass"</span>)</span><br><span class="line">Class KlassController &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(/&#123;id&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Klass <span class="title">get</span><span class="params">(@PathVar....)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>新建注解，并且作用于班级的students中.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">KlassGet</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 班级</span></span><br><span class="line">Class Klass &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"klass"</span>)</span><br><span class="line">    <span class="meta">@JsonView</span>(&#123;NoneJsonView.class, KlassGet.calss&#125;)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Student&gt; students = <span class="keyword">new</span> HashSet&lt;&gt;();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在控制器上加入注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/Klass"</span>)</span><br><span class="line">Class KlassController &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(/&#123;id&#125;)</span><br><span class="line">    <span class="meta">@JsonView</span>(KlassGet.calss)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Klass <span class="title">get</span><span class="params">(@PathVar....)</span> </span>&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时，由于<code>Student</code>的<code>klass</code>字段，拥有注解。并且拥有的注解，不包含<code>@JsonView(KlassGet.calss)</code>，所以在序列化时，将被自动省略.</p>
<h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>加入上述配置前，使用<code>@JsonView</code>注解时，如果字段并未设置<code>@JsonView</code>注解。那么则默认 <strong>不进行</strong> 序列化。<br>加入上述配置后，我个人的理解是：如果字段并未设置<code>@JsonView</code>注解。那么则默认 <strong>进行</strong> 序列化。<br>加入配置的前后，对于加入<code>@JsonView</code>注解的字段，判断方法相同：符合，则序列化；不符合，不序列化。</p>
<p>这样，使用上述方法便解释了为什么加入配置后，<code>Page</code>类型便得以全部输出了。<br>这时由于<code>Page</code>并没有加入<code>@JsonView</code>，所以会全部自动序列化。</p>
<p>在实际的使用过程中，这种思想（只有加了<code>@JsonView</code>才可能不被序列化 ）结合<code>@JsonView</code>的使用，大幅的缩减注解代码量。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>我们将<code>@JsonView</code>注解的默认规则由：<br>只有加入了注解才可能 <strong>被</strong> 序列化<br>修改为:<br>-&gt; 只有加入了注解才可能 <strong>不被</strong> 序列化。<br>修改默认规则前：<code>Page</code>并没有加入<code>@JsonView</code>注解，默认忽略。<br>修改默认规则后：<code>Page</code>并没有加入<code>@JsonView</code>注解，默认自动转换。<br>同时，也解决了使用<code>@JsonView</code>注解时，需要大量加入注解代码的尴尬。</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring mvc </tag>
            
            <tag> spring boot </tag>
            
            <tag> @JsonView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在angularJs中进行json数据的格式化]]></title>
      <url>/2017/07/17/format-json-data-in-angularjs/</url>
      <content type="html"><![CDATA[<p>我们在angularJs的项目中，常常需要对<code>json</code>进行显式的查看，以便更清晰的了解到<code>json</code>数据内部结构与数值变化。本文将介绍一种非常不错的方法，来协助你查看前台绑定的<code>json</code>数据。</p>
<a id="more"></a>
<h2 id="格式化以前"><a href="#格式化以前" class="headerlink" title="格式化以前"></a>格式化以前</h2><p>比如：<br>我们在v层中加入以下代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;data&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>刷新前台，对应输出格式为:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"区县级器具用户"</span>,<span class="attr">"createTime"</span>:<span class="literal">null</span>,<span class="attr">"updateTime"</span>:<span class="literal">null</span>,<span class="attr">"preWorkflowNode"</span>:<span class="literal">null</span>,<span class="attr">"createUser"</span>:<span class="literal">null</span>,<span class="attr">"districtType"</span>:&#123;<span class="attr">"id"</span>:<span class="number">3</span>,<span class="attr">"name"</span>:<span class="string">"区\\县"</span>,<span class="attr">"pinyin"</span>:<span class="string">"quxian"</span>,<span class="attr">"createUser"</span>:<span class="literal">null</span>&#125;,<span class="attr">"workflowType"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"适用于器具用户新强检器具审批"</span>,<span class="attr">"pinyin"</span>:<span class="literal">null</span>,<span class="attr">"createTime"</span>:<span class="literal">null</span>,<span class="attr">"updateTime"</span>:<span class="literal">null</span>,<span class="attr">"description"</span>:<span class="string">"1.向上级管理部门提出申请；2.管理部门可以转给同区域或子区域的技术机构。3.技术机构可办结可返回给管理部门"</span>,<span class="attr">"createUser"</span>:<span class="literal">null</span>&#125;,<span class="attr">"departmentType"</span>:&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"器具用户"</span>,<span class="attr">"pinyin"</span>:<span class="string">"qijuyonghu"</span>,<span class="attr">"createTime"</span>:<span class="number">0</span>,<span class="attr">"updateTime"</span>:<span class="number">0</span>,<span class="attr">"createUser"</span>:<span class="literal">null</span>&#125;,<span class="attr">"containSonDistrict"</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使是浏览器为我们启用了自动换行，对于想查看<code>json</code>结构的我们，也是一件非常困难的事，这时候，我们需要结合<code>&lt;pre&gt;</code>与<code>json</code>过滤器来共同的定制该显示格式：</p>
<h2 id="格式化以后"><a href="#格式化以后" class="headerlink" title="格式化以后"></a>格式化以后</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123;data | json&#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们将得到如下格式的<code>json</code>数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"区县级器具用户"</span>,</span><br><span class="line">  <span class="attr">"createTime"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"updateTime"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"preWorkflowNode"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"createUser"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">"districtType"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"区\\县"</span>,</span><br><span class="line">    <span class="attr">"pinyin"</span>: <span class="string">"quxian"</span>,</span><br><span class="line">    <span class="attr">"createUser"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"workflowType"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"适用于器具用户新强检器具审批"</span>,</span><br><span class="line">    <span class="attr">"pinyin"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"createTime"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"updateTime"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"1.向上级管理部门提出申请；2.管理部门可以转给同区域或子区域的技术机构。3.技术机构可办结可返回给管理部门"</span>,</span><br><span class="line">    <span class="attr">"createUser"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"departmentType"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"器具用户"</span>,</span><br><span class="line">    <span class="attr">"pinyin"</span>: <span class="string">"qijuyonghu"</span>,</span><br><span class="line">    <span class="attr">"createTime"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"updateTime"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"createUser"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"containSonDistrict"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你习惯了用4个空格来代替缩进，那么你还可以这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;&#123;data | json : 4&#125;&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>刷新页面：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"区县级器具用户"</span>,</span><br><span class="line">    <span class="attr">"createTime"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"updateTime"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"preWorkflowNode"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"createUser"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"districtType"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"区\\县"</span>,</span><br><span class="line">        <span class="attr">"pinyin"</span>: <span class="string">"quxian"</span>,</span><br><span class="line">        <span class="attr">"createUser"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"workflowType"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"适用于器具用户新强检器具审批"</span>,</span><br><span class="line">        <span class="attr">"pinyin"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"createTime"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"updateTime"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"description"</span>: <span class="string">"1.向上级管理部门提出申请；2.管理部门可以转给同区域或子区域的技术机构。3.技术机构可办结可返回给管理部门"</span>,</span><br><span class="line">        <span class="attr">"createUser"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"departmentType"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"器具用户"</span>,</span><br><span class="line">        <span class="attr">"pinyin"</span>: <span class="string">"qijuyonghu"</span>,</span><br><span class="line">        <span class="attr">"createTime"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"updateTime"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"createUser"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"containSonDistrict"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>赶快试试吧。</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angularJs </tag>
            
            <tag> josn </tag>
            
            <tag> format </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring中如何用注解实现多个类自动装配同一个接口]]></title>
      <url>/2017/07/15/spring-qualifier/</url>
      <content type="html"><![CDATA[<p><strong>转载出处</strong> ：<a href="http://www.cnblogs.com/smileLuckBoy/p/5801678.html" target="_blank" rel="noopener">Spring的注解@Qualifier小结</a> </p>
<a id="more"></a>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>有如下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface EmployeeService &#123;</span><br><span class="line">    public EmployeeDto getEmployeeById(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时有下述两个实现类 EmployeeServiceImpl和EmployeeServiceImpl1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;service&quot;)</span><br><span class="line">public class EmployeeServiceImpl implements EmployeeService &#123;</span><br><span class="line">    public EmployeeDto getEmployeeById(Long id) &#123;</span><br><span class="line">        return new EmployeeDto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service(&quot;service1&quot;)</span><br><span class="line">public class EmployeeServiceImpl1 implements EmployeeService &#123;</span><br><span class="line">    public EmployeeDto getEmployeeById(Long id) &#123;</span><br><span class="line">        return new EmployeeDto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/emplayee.do&quot;)</span><br><span class="line">public class EmployeeInfoControl &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line">     </span><br><span class="line">    @RequestMapping(params = &quot;method=showEmplayeeInfo&quot;)</span><br><span class="line">    public void showEmplayeeInfo(HttpServletRequest request, HttpServletResponse response, EmployeeDto dto) &#123;</span><br><span class="line">        #略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;employeeInfoControl&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.test.service.EmployeeService com.test.controller.EmployeeInfoControl.employeeService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.test.service.EmployeeService] is defined: expected single matching bean but found 2: [service1, service2]</span><br></pre></td></tr></table></figure>
<h3 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h3><p>其实报错信息已经说得很明确了,在autoware时，由于有两个类实现了EmployeeService接口，所以Spring不知道应该绑定哪个实现类，所以抛出了如上错误。</p>
<h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><p>用到@Qualifier注解了，qualifier的意思是合格者，通过这个标示，表明了哪个实现类才是我们所需要的，我们修改调用代码，添加@Qualifier注解，需要注意的是@Qualifier的参数名称必须为我们之前定义@Service注解的名称之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/emplayee.do&quot;)</span><br><span class="line">public class EmployeeInfoControl &#123;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;service&quot;)</span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(params = &quot;method=showEmplayeeInfo&quot;)</span><br><span class="line">    public void showEmplayeeInfo(HttpServletRequest request, HttpServletResponse response, EmployeeDto dto) &#123;</span><br><span class="line">        #略</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mvn package命令]]></title>
      <url>/2017/07/08/mvn-package/</url>
      <content type="html"><![CDATA[<p><code>maven</code>是托管java项目的一个很好用的工具。但是对于初学java的我来说，也踩到了许多坑。简单说一下我在打包的时候遇到的问题。<br><a id="more"></a></p>
<h2 id="Find-question"><a href="#Find-question" class="headerlink" title="Find question"></a>Find question</h2><p>当时我执行<code>mvn package</code>之后就发现测试文件好多都报错了。</p>
<p><img src="/images/package_error.png" alt=""> </p>
<p>然后，我们一点儿一点儿着错误就会发现有报错信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Foreign key refering com.mengyunzhi.measurement.repository.ApplyType from com.mengyunzhi.measurement.repository.WorkflowTypeApplyType has the wrong number of column. should be 3</span><br></pre></td></tr></table></figure>
<h2 id="Analysis-question"><a href="#Analysis-question" class="headerlink" title="Analysis question"></a>Analysis question</h2><p>分析这句话就会发现值WorkflowTypeApplyType这张表里的外健约束from ApplyType有问题。</p>
<p>这个可能是因为我们开发的时候往往是在自己的分支上开发，但是一些简单组件的测试是由开发人员自己做的，我们进行<code>unit test</code>的时候已经编译了改动的文件。但是切到<code>development</code>分支的时候进行<code>mvn package</code>,然后过程如下：<br><img src="/images/package.png" alt=""> </p>
<p>虽然我们进行了编译，但是可能会留下曾经编译过的字节码文件(.class)。所以我们可以<code>rebuild project</code>, 将所有的编译文件clean然后全部重新编译。</p>
<h2 id="Solve-question"><a href="#Solve-question" class="headerlink" title="Solve question"></a>Solve question</h2><p>删除数据库，新建数据库。在linux, IDEA开发环境下 <strong>Build -&gt; Rebuild Project</strong>， 然后再执行<code>mvn package</code></p>
<h2 id="New-question"><a href="#New-question" class="headerlink" title="New question"></a>New question</h2><p>不会报错了之后，当我们进行打包的时候就会发现一个问题。我的电脑总是卡在这句话上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HHH000227: Running hbm2ddl schema export</span><br></pre></td></tr></table></figure>
<p>这句话表示<code>hibernate</code>按照持久化类和映射文件自动生成数据库架构, 把DDL脚本输出到标准输出，同时/或者执行DDL语句。</p>
<p>应为在<code>mvn  package</code>中我们可能会有多次这条语句，然后我们怎么解决这个慢的问题呢？</p>
<ul>
<li>设置 spring.jpa.hibernate.ddl-auto=create</li>
<li><p>随便执行一个单元测试应该也可以,当执行过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export</span><br><span class="line"> 2017-07-07 09:18:35.672  INFO 7652 --- [           main] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete</span><br></pre></td></tr></table></figure>
<p>说明数据表已经创建成功, 即可终止单元测试</p>
</li>
<li>修改：spring.jpa.hibernate.ddl-auto=none,禁用禁用ddl-auto</li>
<li>执行mvn test或者mvn package</li>
</ul>
<p>然后就会解决这个建立数据库结构慢的问题了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们总会遇到各种各样的问题，当我们有了一定的知识积累之后，我们就需要对遇到的问题一点点儿分析。不怕慢，就怕我们自己对未知事务的恐惧会阻挡我们前进。当然了，对于问题，我们最好先猜测一个原因再去百度问题的解决方法，因为过多的依赖百度会让我们停止对问题的思考。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>陈鋆:  <a href="Maven 各命令执行流程解析和说明">Maven 各命令执行流程解析和说明</a><br><a href="http://www.it165.net/admin/html/201411/4226.html" target="_blank" rel="noopener">[Nhibernate]SchemaExport工具的使用（一）通过映射文件修改数据表</a> </p>
]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hibernate级联操作]]></title>
      <url>/2017/07/06/cascade/</url>
      <content type="html"><![CDATA[<p>当我们处理实体之间关系的时候，很可能会涉及到一个实体发生改变的时候它所关联的实体也会发生改变，这就是我们所说的级联操作。当然，hibernate已经给我们设计好了我们所要用的简单的级联操作。<strong>详细的代码见 参考文章 的链接</strong><br><a id="more"></a></p>
<h2 id="级联保存"><a href="#级联保存" class="headerlink" title="级联保存"></a>级联保存</h2><h3 id="关联关系中比较常用：-OneToMany-ManyToMany-OneToOne"><a href="#关联关系中比较常用：-OneToMany-ManyToMany-OneToOne" class="headerlink" title="关联关系中比较常用：@OneToMany, @ManyToMany, @OneToOne"></a>关联关系中比较常用：@OneToMany, @ManyToMany, @OneToOne</h3><p>对于级联保存而言，是最基本的级联关系，估计也是我们最常用的关系。也就是保存本实体的时候，它所关联的实体也会自动保存。级联保存操作为<code>CascadeType.PERSIST</code></p>
<h2 id="级联更新"><a href="#级联更新" class="headerlink" title="级联更新"></a>级联更新</h2><h3 id="关联关系中比较常用：所有实体关系都适用"><a href="#关联关系中比较常用：所有实体关系都适用" class="headerlink" title="关联关系中比较常用：所有实体关系都适用"></a>关联关系中比较常用：所有实体关系都适用</h3><p>对于更新，当然也是我们最常见的情况。我们说级联更新基本上适用于所有的情况。但是对于<code>@OneToMany</code>的情况下，我们可能需要结合下面所讲到的<strong>孤立移除</strong>才能够完善。级联更新操作为<code>CascadeType.MERGE</code></p>
<h2 id="级联删除"><a href="#级联删除" class="headerlink" title="级联删除"></a>级联删除</h2><h3 id="关联关系中比较常用：-OneToMany，-OneToOne"><a href="#关联关系中比较常用：-OneToMany，-OneToOne" class="headerlink" title="关联关系中比较常用：@OneToMany， @OneToOne"></a>关联关系中比较常用：@OneToMany， @OneToOne</h3><p>我们可以这样想，当一个商品可以有多个价格，但是当我们从数据库中删除这个商品的时候，我们说这个商品所对应的价格也就没有任何意义了。所以要删除一个商品的正确顺序是先删除这个商品对应的价格然后删除这个商品，如果不这样的话删除商品的时候会被<strong>外健</strong>约束从而删除商品失败。而hibernate对应的就是级联删除则是<code>CascadeType.REMOVE</code></p>
<h2 id="孤立移除"><a href="#孤立移除" class="headerlink" title="孤立移除"></a>孤立移除</h2><h3 id="适用于：-OneToMany，-ManyToMany"><a href="#适用于：-OneToMany，-ManyToMany" class="headerlink" title="适用于：@OneToMany， @ManyToMany"></a>适用于：@OneToMany， @ManyToMany</h3><p>例如：<br><img src="/images/onetomany.png" alt=""><br>我们在器具类别实体中关联着多个规格型号，例如有规格型号1,规格型号2.这时我们更新的时候想要删除规格型号1,这时候我们就需要<code>orphanRemoval = true</code>来实现<code>孤立移除</code>,这样就可以孤立的删除规格型号1.具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 器具类别  实体</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">@ApiModel(value = &quot;InstrumentType (器具类别)&quot;, description = &quot;器具类别实体&quot;)</span><br><span class="line">public class InstrumentType implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private Long id;</span><br><span class="line">    @ApiModelProperty(&quot;名称&quot;)</span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    private String name;</span><br><span class="line">    @Column(nullable = false)</span><br><span class="line">    @ApiModelProperty(&quot;拼音&quot;)</span><br><span class="line">    private String pinyin;</span><br><span class="line"></span><br><span class="line">    @Lazy       //参照hibernate实战第七章第三节级联状态</span><br><span class="line">    @OneToMany(mappedBy = &quot;instrumentType&quot;, cascade = &#123;CascadeType.PERSIST, CascadeType.REMOVE, CascadeType.MERGE&#125;, orphanRemoval = true)</span><br><span class="line">    @ApiModelProperty(&quot;oneToMany 规格型号&quot;)</span><br><span class="line">    private List&lt;Specification&gt; specifications = new ArrayList&lt;&gt;();</span><br><span class="line">   // getter and setter ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>hibernate第七章第三节级联状态<br><a href="https://gaoliming123.github.io/2017/06/06/ManyToMany/" target="_blank" rel="noopener">Hibernate@ManyToMany总结</a> </p>
]]></content>
      
        <categories>
            
            <category> gaoliming </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cascade </tag>
            
            <tag> hibernate </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何重启服务器(freebsd系统)上的JAVA应用]]></title>
      <url>/2017/07/05/how-to-restart-a-new-javaj-application/</url>
      <content type="html"><![CDATA[<p>本文将阐述如何在<code>freebsd</code>系统中，重启<code>java</code>应用程序.<br><a id="more"></a></p>
<h1 id="获取jar程序"><a href="#获取jar程序" class="headerlink" title="获取jar程序"></a>获取jar程序</h1><p>获取jar程序的方法有很多，比如我们可以在本地进行<code>mvn package</code>，或是可以直接下载<code>gh-pages</code>分支上的<code>jar</code>文件。</p>
<p>假设我们拥有以下<code>jar</code>文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api-0.0.5-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></p>
<h1 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@www.mengyunzhi.cn -p 1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>windows客户端，<code>ssh</code>命令端口参考可能不同，请使用<code>$ ssh -help</code>来查看自定义端口的参数。</p>
</blockquote>
<p>其中<code>user</code>为用户名，<code>www.mengyunzhi.cn</code>为域名（也可以是IP地址）, <code>1234</code>为端口号。回车后，提示我们输入密码。成功后，将显示以下欢迎信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Show the version of FreeBSD installed:  freebsd-version ; uname -a</span><br><span class="line">Please include that output and any error messages when posting questions.</span><br><span class="line">Introduction to manual pages:  man man</span><br><span class="line">FreeBSD directory layout:      man hier</span><br><span class="line"></span><br><span class="line">Edit /etc/motd to change this login announcement.</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>
<h1 id="停止原应用"><a href="#停止原应用" class="headerlink" title="停止原应用"></a>停止原应用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps | grep java</span><br><span class="line">39297  0  R+   0:00.00 grep java</span><br><span class="line">39049  2- R    0:58.06 /usr/<span class="built_in">local</span>/openjdk8/bin/java -jar api-0.0.5-SNAPSHOT.jar --datasource.port=5678</span><br></pre></td></tr></table></figure>
<p>我们得到<code>pid</code>号如<code>39049</code>，继而使用<code>kill -9 pid</code>结束原进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -9 39049</span><br></pre></td></tr></table></figure></p>
<p>操作后，可以继续使用<code>ps | grep java</code>来查看进程是否成功结束。</p>
<h1 id="上传新应用"><a href="#上传新应用" class="headerlink" title="上传新应用"></a>上传新应用</h1><p>利用<code>sftp</code>命令进行上传。我们在本机新打开一个命令行或<code>bash</code>窗口，然后输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> 本地存放api-0.0.5-SNAPSHOT.jar文件的目录</span><br><span class="line">$ sftp -P 1234 user@www.mengyunzhi.cn</span><br><span class="line">$ 输入密码</span><br><span class="line">Connected to www.mengyunzhi.cn.</span><br><span class="line">sftp&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>windows客户端请先执行<code>sftp -help</code>查看如何指定端口及用户名</p>
</blockquote>
<h2 id="执行上传命令"><a href="#执行上传命令" class="headerlink" title="执行上传命令"></a>执行上传命令</h2><p>比如我们服务器上的应用程序存放位置为：<code>/mengyunzhi/api/8080.Measurement</code></p>
<p>首先进行服务器目标文件夹，然后执行<code>put</code>命令上传</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sftp&gt; <span class="built_in">cd</span> /mengyunzhi/api/8080.Measurement</span><br><span class="line">sftp&gt; put api-0.0.5-SNAPSHOT.jar </span><br><span class="line">Uploading api-0.0.5-SNAPSHOT.jar to /mengyunzhi/api/8080.Measurement/api-0.0.5-SNAPSHOT.jar</span><br><span class="line">api-0.0.5-SNAPSHOT.jar                                                                                                             100%   40MB   2.9MB/s   00:14    </span><br><span class="line">sftp&gt;</span><br></pre></td></tr></table></figure>
<p>传输完成，关闭当前窗口。</p>
<h1 id="启动新应用"><a href="#启动新应用" class="headerlink" title="启动新应用"></a>启动新应用</h1><p>我们切回到 停止原应用 的窗口，先进入程序所在目录，然后启动新程序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /mengyunzhi/api/8080.Measurement</span><br><span class="line">$ java -jar api-0.0.5-SNAPSHOT.jar --datasource.port=6789 &amp;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>--datasource.port=6789</code>指定数据库的端口。<code>&amp;</code>指定为后台运行，很重要！</p>
</blockquote>
<p>服务启动后，控制台将打印：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-07-05 16:15:01.802  INFO 39339 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)</span><br><span class="line">2017-07-05 16:15:01.818  INFO 39339 --- [           main] c.mengyunzhi.measurement.ApiApplication  : Started ApiApplication in 50.57 seconds (JVM running for 51.544)</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> freebsd </tag>
            
            <tag> java application </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何实现分页（M层）]]></title>
      <url>/2017/07/03/pageable/</url>
      <content type="html"><![CDATA[<p>今天学习了潘老师写的器具类别的分页，讲述一下对代码的理解。有不足之处，欢迎批评指正。</p>
<h1 id="将获取到的数据进行规定条数的分页"><a href="#将获取到的数据进行规定条数的分页" class="headerlink" title="将获取到的数据进行规定条数的分页"></a>将获取到的数据进行规定条数的分页</h1><h2 id="继承PagingAndSortingRepository"><a href="#继承PagingAndSortingRepository" class="headerlink" title="继承PagingAndSortingRepository"></a>继承PagingAndSortingRepository</h2><p>首先我们对获取到的所有的数据进行分页。我们应该知道，分页并不是CrudRepository里面自带的方法，所以我们需要引入。简单的方法是，我们可以在InstrumentTypeRepository中，将其进行对PagingAndSortingRepository的继承，然后在该类定义函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface InstrumentTypeRepository extends PagingAndSortingRepository&lt;InstrumentType, Long&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="M层直接调用方法"><a href="#M层直接调用方法" class="headerlink" title="M层直接调用方法"></a>M层直接调用方法</h2><p>这样，在InstrumentTypeServiceImpl类中就可以调用PagingAndSortingRepository中的分页方法了。下面是对分页数为20的代码的编写：</p>
<p>我们在InstrumentTypeServiceImpl中关于getAll的方法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;InstrumentType&gt; getAll()</span><br><span class="line">&#123;</span><br><span class="line">	List&lt;InstrumentType&gt; list = new ArrayList&lt;InstrumentType&gt;();</span><br><span class="line">	list = (List&lt;InstrumentType&gt;) instrumentTypeRepository.findAll(new PageRequest(page:1, size:20));</span><br><span class="line">	return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可是我们很轻易的就发现，这样写虽然很简单，但是不能动态的生成我们需要的分页数。假如我们想生成分页数为10的话，那么还得需要我们去手动的修改源代码。所以接下来我们看一看如何动态的生成分页的代码。</p>
<h1 id="动态生成分页"><a href="#动态生成分页" class="headerlink" title="动态生成分页"></a>动态生成分页</h1><h2 id="Repository中进行方法的定义"><a href="#Repository中进行方法的定义" class="headerlink" title="Repository中进行方法的定义"></a>Repository中进行方法的定义</h2><p>同样的，我们还是以InstrumentType为例。示例方法为通过学科id获取对应的全部的器具类别信息并进行分页。但是这次我们像往常一样只需要继承CrudRepository。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InstrumentTypeRepository extends CrudRepository&lt;InstrumentType, Long&gt;&#123;</span><br><span class="line">    Page&lt;InstrumentType&gt; findAllByDisciplineId(Long id, Pageable pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到在该类下定义了函数findAllByDisciplineId，其中传入的参数为学科id，和pageable对象。pageable需要进行Pageable类的引入，同样的Page类也需要进行引入，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.data.domain.Page;</span><br><span class="line">import org.springframework.data.domain.Pageable;</span><br></pre></td></tr></table></figure></p>
<p>当然，如果我们用的IDEA编译器的话，它会自动提示我们去引入该包。</p>
<blockquote>
<p>Pageable是Spring Data库中定义的一个接口，该接口是所有分页相关信息的一个抽象，通过该接口，我们可以得到和分页相关的所有信息，例如pageNumber、pageSize等。<br>Pageable定义了很多方法，但是我们需要用到的信息只有两个，一个是分页的信息（page、size），一个是排序的信息。在springmc的请求中只需要在方法的参数中直接定义一个pageable类型的对象，当Spring发现这个参数时，Spring会自动根据request的参数来组装该pageable对象，Spring支持的request参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page，第几页，从0开始，默认为第0页  </span><br><span class="line">size，每一页的大小，默认为20  </span><br><span class="line">sort，排序相关的信息，以property,property(,ASC|DESC)的方式组织，例如sort=firstname&amp;sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列。</span><br></pre></td></tr></table></figure></p>
<p>不太明白的一点是，findAllByDisciplineId这个方法名是自己起的，但是起名的格式该类下在有没有什么规定，才能实现通过学科id获取器具类别的信息。</p>
</blockquote>
<h2 id="Service层以及Service层的实现类"><a href="#Service层以及Service层的实现类" class="headerlink" title="Service层以及Service层的实现类"></a>Service层以及Service层的实现类</h2><p>然后再Service层我们定义分页的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;InstrumentType&gt; getAllByDisciplineId(Long id, Pageable pageable);</span><br></pre></td></tr></table></figure></p>
<p>其中返回值为page类型的数组对象，传入值为学科id以及pageable对象。</p>
<p>ServiceImpl中,我们进行方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Page&lt;InstrumentType&gt; getAllByDisciplineId(Long id, Pageable pageable) </span><br><span class="line">    &#123;</span><br><span class="line">        Page&lt;InstrumentType&gt; page = instrumentTypeRepository.findAllByDisciplineId(id, pageable);</span><br><span class="line">        return page;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在实现类中，我们将传入的pageable对象利用Repository类中定义的方法，返回值为类型为Page的数组对象。</p>
<h2 id="Test类中的测试"><a href="#Test类中的测试" class="headerlink" title="Test类中的测试"></a>Test类中的测试</h2><p>有了定义好的方法，下面我们对其进行测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void page() &#123;</span><br><span class="line">   	// 新建学科实体，设置name、pinyin属性并保存</span><br><span class="line">       Discipline discipline = new Discipline();</span><br><span class="line">       discipline.setName(&quot;namesdfsdfdf&quot;);</span><br><span class="line">       discipline.setPinyin(&quot;pinyin&quot;);</span><br><span class="line">       disciplineRepository.save(discipline);</span><br><span class="line">	// 新建器具类别实体，设置name、pinyin、学科类别属性并保存</span><br><span class="line">       InstrumentType instrumentType = new InstrumentType();</span><br><span class="line">       instrumentType.setName(&quot;name&quot;);</span><br><span class="line">       instrumentType.setPinyin(&quot;pinyin&quot;);</span><br><span class="line">       instrumentType.setDiscipline(discipline);</span><br><span class="line">       instrumentTypeRepository.save(instrumentType);</span><br><span class="line">	// 新建器具类别实体1，设置name、pinyin、学科类别属性并保存</span><br><span class="line">       InstrumentType instrumentType1 = new InstrumentType();</span><br><span class="line">       instrumentType1.setName(&quot;namesdfd&quot;);</span><br><span class="line">       instrumentType1.setPinyin(&quot;pinyinsdfsdf&quot;);</span><br><span class="line">       instrumentType1.setDiscipline(discipline);</span><br><span class="line">       instrumentTypeRepository.save(instrumentType1);		</span><br><span class="line">	// 定义pageRequest对象，设置分页信息。从第一页开始显示，分页大小为1。</span><br><span class="line">       final PageRequest pageRequest = new PageRequest(</span><br><span class="line">               page:1, size:1</span><br><span class="line">       );</span><br><span class="line">       Page&lt;InstrumentType&gt; page = instrumentTypeRepository.findAllByDisciplineId(discipline.getId(), pageRequest);</span><br><span class="line">       // 断言一共是两页，因为分页大小为1，有两条信息</span><br><span class="line">       assertThat(page.getTotalPages()).isEqualTo(2);</span><br><span class="line">       // 断言分页大小为1</span><br><span class="line">       assertThat(page.getContent().size()).isEqualTo(1);</span><br><span class="line">       // 删除器具类别实体，删除学科类别试题</span><br><span class="line">       instrumentTypeRepository.delete(instrumentType1);</span><br><span class="line">       instrumentTypeRepository.delete(instrumentType);</span><br><span class="line">       disciplineRepository.delete(discipline);</span><br><span class="line">       return;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以在C层去调用刚刚写好的关于分页的函数啦！</p>
]]></content>
      
        <categories>
            
            <category> zhangjiahao </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pageable </tag>
            
            <tag> PagingAndSortingRepository </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JPA参考文献的翻译（部分）]]></title>
      <url>/2017/06/29/translationOfJPADocument/</url>
      <content type="html"><![CDATA[<p>Spring Data JPA官方文档 <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank" rel="noopener">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/</a></p>
<h1 id="4-使用Spring数据仓库"><a href="#4-使用Spring数据仓库" class="headerlink" title="4.使用Spring数据仓库"></a>4.使用Spring数据仓库</h1><p>抽象的说，Spring数据仓库()目标是显著的（significantly）减少为各种持久化存储实现数据访问所需要的示例代码的数量。</p>
<blockquote>
<p>spring数据存储仓库文档和模块<br>这一章节解释Spring数据仓库的核心概念和接口，本章节的信息是从（pull from）Spring Data Common模块中提取的。它使用了JPA模块的配置（configuration）和代码实例。适应了XML声明的命名空间和类型，并且扩展了你正在使用的特定模块的类型的等价物。命名空间的引用（reference）涵盖了支持存储库API的所有Spring数据模块支持的XML配置，存储库查询关键字涵盖了通常由存储库抽象支持的查询方法关键字。有关模块的具体特性的详细信息，请参阅本文档模块的章节。</p>
</blockquote>
<a id="more"></a>
<h2 id="4-1核心概念"><a href="#4-1核心概念" class="headerlink" title="4.1核心概念"></a>4.1核心概念</h2><p>Spring数据仓库（Spring Data Repository）的中心接口是仓库（Repository）。它需要域类来管理，并且需要域类的id类型作为参数（argument）类型。接口起的主要作用就是作为一个标记接口去捕获要处理的类型并且帮助你去发现该接口的拓展接口。CrudRepository为正在被管理的实体类提供了复杂的（sophisticated）增删改查方法。</p>
<blockquote>
<p>示例3. CrudRepository接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface CrudRepository&lt;T, ID extends Serializable&gt;</span><br><span class="line">    extends Repository&lt;T, ID&gt; </span><br><span class="line">&#123;</span><br><span class="line">    &lt;S extends T&gt; S save(S entity); //保存给出的实体</span><br><span class="line">    T findOne(ID primaryKey);       //通过给出的id返回对应的实体</span><br><span class="line">    Iterable&lt;T&gt; findAll();          //返回所有的实体</span><br><span class="line">    Long count();                   //返回实体的数量</span><br><span class="line">    void delete(T entity);          //删除给出的实体</span><br><span class="line">    boolean exists(ID primaryKey);  //表示给出id的实体是否存在</span><br><span class="line">    // … more functionality omitted.//更多的方法省略了(omit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们也提供了持久特定于技术（technology-specific）的抽象例如：JpaRepository和MongoRepository。这些接口继承了CrudRepository并且暴露了底层的持久化技术的功能（capabilities）除了一些一般（generic）的持久性技术无关的接口，如:CrudRepository。</p>
</blockquote>
<p>在CrudRepository之上这里还有一个抽象的PagingAndSortingRepository，它添加了额外的方法来简化对实体的分页访问（paginated access）。</p>
<blockquote>
<p>示例4. PageAndSortingRepository</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt;</span><br><span class="line">  extends CrudRepository&lt;T, ID&gt; &#123;</span><br><span class="line">  Iterable&lt;T&gt; findAll(Sort sort);</span><br><span class="line">  Page&lt;T&gt; findAll(Pageable pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你想访问第二页的User并且分页大小是20，你可以简单的这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean</span><br><span class="line">Page&lt;User&gt; users = repository.findAll(new PageRequest(1, 20));</span><br></pre></td></tr></table></figure>
<p>除了查询方法以外，还可以查询计数和删除查询的查询派生也是可以用到的。</p>
<blockquote>
<p>示例5. 推导出查询的总数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;</span><br><span class="line">  Long countByLastname(String lastname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例6. 推导出删除的总数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface UserRepository extends CrudRepository&lt;User, Long&gt; &#123;</span><br><span class="line">  Long deleteByLastname(String lastname);</span><br><span class="line">  List&lt;User&gt; removeByLastname(String lastname);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 4.2 查询方式</span><br><span class="line"></span><br><span class="line">标准的增删改查功能（functionally）仓库对底层（underlying）的数据存储库（datastore）有查询操作。通过Spring Data,声明这些查询分以下四步：</span><br><span class="line"></span><br><span class="line">1. 声明一个借口继承Repository或者Repository的某一个子接口（subinterface）并且将它输入到它要处理的域类（domain class）和ID类型。</span><br></pre></td></tr></table></figure>
<p>interface PersonRepository extends Repository<person, long=""> { … }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 在这个接口声明查询方式</span><br></pre></td></tr></table></figure></person,></p>
<p>interface PersonRepository extends Repository<person, long=""> {<br>  List<person> findByLastname(String lastname);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 设置（set up）Spring为这些接口创建代理实例（proxy instance），通过JavaConfig:</span><br></pre></td></tr></table></figure></person></person,></p>
<p>import org.springframework.data.jpa.repository.config.EnableJpaRepositories;<br>@EnableJpaRepositories<br>class Config {}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">或者通过XML configuration:</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemalocation="http://www.springframework.org/schema/beans
     http://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/data/jpa
     http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"><br>   <jpa:repositories base-package="com.acme.repositories"><br></jpa:repositories></beans><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在本例中使用了JPA的命名空间，如果你正在为其他存储库使用存储仓库抽象，你需要为你的存储模块改变到一个合适的声明的命名空间。您需要将其更改为您的存储模块的适当名称空间声明，该声明应该有利于（in favor of）交换jpa，例如mongodb。</span><br><span class="line">另外，请注意，JavaConfig变量（variant）不会在默认情况下使用带注释的类的包。要定制（customize）这个包，可以扫描使用一个basePackage.数据存储特定存储库的属性@enable注解。</span><br><span class="line"></span><br><span class="line">4. 获取注入（inject）的repository实例（instance）且使用它。</span><br></pre></td></tr></table></figure></p>
<p>public class SomeClient {<br>  @Autowired<br>  private PersonRepository repository;<br>  public void doSomething() {<br>    List<person> persons = repository.findByLastname(“Matthews”);<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来的章节将详细的解释上面的每一步。</span><br><span class="line"></span><br><span class="line">## 4.3定义repository接口</span><br><span class="line"></span><br><span class="line">第一步你应该定义一个域类特定（specific）的repository的接口。这个接口必须继承Repository并且输入到域类和ID类型中。如果你想为这个域类型公开（expose）CRUD方法，继承CrudRepository而不是继承Repository。</span><br><span class="line"></span><br><span class="line">### 4.3.1 微调库（Fine-tuning）定义</span><br><span class="line"></span><br><span class="line">通常，你的Repository接口将会继承Repository,CrudRepository或者PagingAndSortingRepository。或者（Alternatively），如果你想继承Spring Data的接口，你也可以用@RepositoryDefinition注解你的repository。继承CrudRepository公开了一系列完整的方法来操作（manipulate）你的实体。如果你想选择这些公开的方法，只需要将这些公开的方法复制的进你的域存储库（domain repository）中。</span><br><span class="line">&gt; 这将会允许你在提供的Spring数据存储库功能之上定义你自己的抽象。</span><br><span class="line"></span><br><span class="line">示例7 选择公开的CRUD方法</span><br></pre></td></tr></table></figure></person></p>
<p>@NoRepositoryBean<br>interface MyBaseRepository<t, id="" extends="" serializable=""> extends Repository<t, id=""> {<br>  T findOne(ID id);<br>  T save(T entity);<br>}<br>interface UserRepository extends MyBaseRepository<user, long=""> {<br>  User findByEmailAddress(EmailAddress emailAddress);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">在第一步中你可以为你的所有的域存储库（domain repository）定义一个公有的基础接口（base interface）并且公开findOne()和save()等方法。这些方法将会被路由到（routed into）Spring Data提供的你选择的基本的存储repository实现。例如：SimpleJpaRepository，因为他们符合CrudRepository的方法声定义（signature）。所以UserRepository将会可以保存users，通过id寻找某一用户，并且通过email address触发（trigger）查询去寻找Users。</span><br><span class="line"></span><br><span class="line">&gt; 请注意，中间库接口（intermediate repository interface）使用@NoRepositoryBean注解。请确保你在所有的repository接口上添加了这个注解，Spring Data不应该在运行的时候创建实例。</span><br><span class="line"></span><br><span class="line">## 4.3.2 使用具有多个Spring数据模块的存储仓库（Repositories）</span><br><span class="line">在你的项目中使用独一无二的Spring Data模块将会使事情变得简单。在定义的范围内所有的repository接口都绑定到Spring Data模块中。有时候应用们需要使用不止一个Spring Data模块。在这样的情况下，在定义一个repository应该要求区分（distinguish）持久性技术。Spring Data进入严格的repository配置模式（mode）因为它能在类的路径下检测（detect）出复杂的repository工厂。严格的配置要求存储库或域类的详细信息，以决定关于存储库定义的Spring数据模块绑定:</span><br><span class="line"></span><br><span class="line">&gt; 1.如果repository的定义继承了特定于模块的repository，那么这就是特定的Spring data模块它的有效候选（valid candidate）。</span><br><span class="line">&gt; 2.如果域类带有特定于模块的类型注释，那么它就是Spring Data模块的有效候选。Spring Data模块接受第三方（third party）的注释（例如就像JPA的 @Entity），也提供了自己供Spring Data MongoDB/Spring Data Elasticsearch使用的注释例如@Document。</span><br><span class="line"></span><br><span class="line">示例8 使用Module-specific接口定义的Repository</span><br></pre></td></tr></table></figure></user,></t,></t,></p>
<p>interface MyRepository extends JpaRepository<user, long=""> { }<br>@NoRepositoryBean<br>interface MyBaseRepository<t, id="" extends="" serializable=""> extends JpaRepository<t, id=""> {<br>  …<br>}<br>interface UserRepository extends MyBaseRepository<user, long=""> {<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上例中，MyRepository和UserRepository在他们的类型分级结构（hierarchy）继承了JpaRepository。他们是Spring Data JPA模块的有效候选。</span><br><span class="line"></span><br><span class="line">示例9 使用一般的接口定义的Repository</span><br></pre></td></tr></table></figure></user,></t,></t,></user,></p>
<p>interface AmbiguousRepository extends Repository<user, long=""> {<br> …<br>}<br>@NoRepositoryBean<br>interface MyBaseRepository<t, id="" extends="" serializable=""> extends CrudRepository<t, id=""> {<br>  …<br>}<br>interface AmbiguousUserRepository extends MyBaseRepository<user, long=""> {<br>  …<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">AmbiguousRepository和AmbiguousUserRepository在他们的类型层次结构中仅仅继承了Repository和CrudRepository。使用一个独一无二的Spring数据模块是完全没问题的，复杂的模块不能区分这些repository应该绑定（bound）哪一个特定的Spring Data。</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure></user,></t,></t,></user,></p>
<p>示例10 使用域类和注解绑定Repository</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface PersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line">@Entity</span><br><span class="line">public class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line">interface UserRepository extends Repository&lt;User, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line">@Document</span><br><span class="line">public class User &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>PersonRepository引用了Person，Person类使用了JPA注解@Entity，所以很明显这个repository属于Spring Data JPA。 UserRepository使用了带有Spring Data MongoDB的@Document注解的 User。</p>
<p>示例11 使用带有混合注释的域类的Repository定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface JpaPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line">interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; &#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br><span class="line">@Entity</span><br><span class="line">@Document</span><br><span class="line">public class Person &#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个例子展示（show）了一个使用JPA和Spring Data MongoDB一起注解的域类。它定义了两个repository，JpaPersonRepository和MongoDBPersonRepository。一个是用于JPA的，另外一个是用于MongoDB的。Spring Data不再能够区分存储库（repository）从而导致未定义的行为。</p>
</blockquote>
<p>Repository类型细节和定义的域类注解是用于严格的repository配置，这写配置为专门的Spring Data模块识别出repository的候选。在同一域类型上使用多个持久性技术特定的注释可以跨多个持久性技术重用域类型，但是Spring Data不可以决定绑定repository的唯一模块。</p>
<p>最后一个方式去区分repository是确定repository的基础包。基础包定义浏览一个repository接口定义的开始点,这意味着（imply）让repository的定义在合适的包中。默认地，注解的驱动（annotation-driven）配置使用配置类（configuration class）中的包。在基于XML（XML-based）配置中的基本包是必需的。</p>
<p>示例12 基础包的注解驱动配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span><br><span class="line">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span><br><span class="line">interface Configuration &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-定义查询方法"><a href="#4-4-定义查询方法" class="headerlink" title="4.4 定义查询方法"></a>4.4 定义查询方法</h2><p>repository代理有两种方式从方法名去派生（derive）出特定于存储（store-specific）的查询，或者通过使用手动（manually）定义查询。可用的选项（available options）取决于真实的存储。然而，必须有一个策略，决定了创建什么实际查询。让我们看一下可用的选项吧。</p>
<h3 id="4-4-1-查询查找策略"><a href="#4-4-1-查询查找策略" class="headerlink" title="4.4.1 查询查找策略"></a>4.4.1 查询查找策略</h3><p>截下来的策略是可用于repository基础结构（infrastructure）以解决查询的。你可以在命名空间中通过query-lookup-strategy属性配置这个策略</p>
]]></content>
      
        <categories>
            
            <category> zhangjiahao </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JPA </tag>
            
            <tag> documents </tag>
            
            <tag> translation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[净水器API]]></title>
      <url>/2017/06/29/WaterPurifier-API/</url>
      <content type="html"><![CDATA[<p>净水器方提供API接口，负责处理单个净水器的请求信息。如获取充值信息，用户使用净水器信息等。</p>
<a id="more"></a>
<h1 id="API列表"><a href="#API列表" class="headerlink" title="API列表"></a>API列表</h1><ul>
<li><a href="./#getCurrentTime">getCurrentTime</a>  ，获取服务器当前时间</li>
<li><a href="./#getRechargeInfo">getRechargeInfo</a> ， 获取充值信息</li>
<li><a href="./#isRechargeOk">isRechargeOk</a>  ，反馈充值结果</li>
<li><a href="./#useInfo">useInfo</a> ，净水器使用信息</li>
</ul>
<h1 id="getCurrentTime"><a href="#getCurrentTime" class="headerlink" title="getCurrentTime"></a>getCurrentTime</h1><p>获取服务器当前时间</p>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="https://api.water.mengyunzhi.com/getCurrentTime" target="_blank" rel="noopener">https://api.water.mengyunzhi.com/getCurrentTime</a> </p>
<h2 id="支持格式"><a href="#支持格式" class="headerlink" title="支持格式"></a>支持格式</h2><p>JSON</p>
<h2 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>GET</p>
<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>无</p>
<h2 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /api/getCurrentTime HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=UTF-8</span><br><span class="line">Host: https://api.water.mengyunzhi.com</span><br></pre></td></tr></table></figure>
<h2 id="响应结果示例"><a href="#响应结果示例" class="headerlink" title="响应结果示例"></a>响应结果示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain;charset=ISO-8859-1</span><br><span class="line">Content-Length: 10</span><br><span class="line">  </span><br><span class="line">1497457292548</span><br></pre></td></tr></table></figure>
<h1 id="getRechargeInfo"><a href="#getRechargeInfo" class="headerlink" title="getRechargeInfo"></a>getRechargeInfo</h1><p>获取充值水量</p>
<h2 id="URL-1"><a href="#URL-1" class="headerlink" title="URL"></a>URL</h2><p><a href="https://api.water.mengyunzhi.com/getRechargeInfo" target="_blank" rel="noopener">https://api.water.mengyunzhi.com/getRechargeInfo</a></p>
<h2 id="支持格式-1"><a href="#支持格式-1" class="headerlink" title="支持格式"></a>支持格式</h2><p>JSON</p>
<h2 id="HTTP请求方式-1"><a href="#HTTP请求方式-1" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>GET</p>
<h2 id="请求参数-1"><a href="#请求参数-1" class="headerlink" title="请求参数"></a>请求参数</h2><p>无</p>
<h2 id="请求头信息"><a href="#请求头信息" class="headerlink" title="请求头信息"></a>请求头信息</h2><ul>
<li>id。类型：Long。说明：净水器编号。</li>
<li>timestamp。类型：String。说明：时间戳。</li>
<li>randomString。类型：String。说明：随机生成的字符串。</li>
<li>encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。</li>
</ul>
<h2 id="请求示例-1"><a href="#请求示例-1" class="headerlink" title="请求示例"></a>请求示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /api/getRechargeInfo</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=UTF-8</span><br><span class="line">Id:1</span><br><span class="line">Timestamp: 1497457292548</span><br><span class="line">RandomString: unzdtggyopn1fl7sx68b8olxr</span><br><span class="line">EncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd</span><br><span class="line">Host: https://api.water.mengyunzhi.com</span><br></pre></td></tr></table></figure>
<h2 id="响应结果示例-1"><a href="#响应结果示例-1" class="headerlink" title="响应结果示例"></a>响应结果示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Content-Length: 2</span><br><span class="line">   </span><br><span class="line">[&#123;</span><br><span class="line">	&quot;id&quot;: 1(充值编号),</span><br><span class="line">	&quot;shouldRecharge&quot;: 200(应充水量)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	&quot;id&quot;: 1(充值编号),</span><br><span class="line">	&quot;shouldRecharge&quot;: 300(应充水量)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h1 id="isRechargeOk"><a href="#isRechargeOk" class="headerlink" title="isRechargeOk"></a>isRechargeOk</h1><p>反馈充值结果</p>
<h2 id="URL-2"><a href="#URL-2" class="headerlink" title="URL"></a>URL</h2><p><a href="https://api.water.mengyunzhi.com/isRechargeOk" target="_blank" rel="noopener">https://api.water.mengyunzhi.com/isRechargeOk</a></p>
<h2 id="支持格式-2"><a href="#支持格式-2" class="headerlink" title="支持格式"></a>支持格式</h2><p>JSON</p>
<h2 id="HTTP请求方式-2"><a href="#HTTP请求方式-2" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>POST</p>
<h2 id="请求body信息"><a href="#请求body信息" class="headerlink" title="请求body信息"></a>请求body信息</h2><ul>
<li>id。类型：Long。说明：充值编号。</li>
<li>status。类型：String。说明：充值状态，充值成功（success）或者充值失败（error）。<blockquote>
<p>json数组格式</p>
</blockquote>
</li>
</ul>
<h2 id="请求头信息-1"><a href="#请求头信息-1" class="headerlink" title="请求头信息"></a>请求头信息</h2><ul>
<li>id。类型：Long。说明：净水器编号。</li>
<li>timestamp。类型：String。说明：时间戳。</li>
<li>randomString。类型：String。说明：随机生成的字符串。</li>
<li>encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。</li>
</ul>
<h2 id="请求示例-2"><a href="#请求示例-2" class="headerlink" title="请求示例"></a>请求示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /api/isRechargeOk HTTP/1.1</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Host: https://api.water.mengyunzhi.com</span><br><span class="line">Id: 1</span><br><span class="line">Timestamp: 1497457292548</span><br><span class="line">RandomString: unzdtggyopn1fl7sx68b8olxr</span><br><span class="line">EncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd</span><br><span class="line">   </span><br><span class="line">[&#123;</span><br><span class="line">	&quot;id&quot;: 1(充值编号),</span><br><span class="line">	&quot;status&quot;: &quot;success&quot;(充值状态)</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	&quot;id&quot;: 1(充值编号),</span><br><span class="line">	&quot;shouldRecharge&quot;: &quot;error&quot;(充值状态)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="响应结果示例-2"><a href="#响应结果示例-2" class="headerlink" title="响应结果示例"></a>响应结果示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<h1 id="useInfo"><a href="#useInfo" class="headerlink" title="useInfo"></a>useInfo</h1><p>净水器使用信息</p>
<h2 id="URL-3"><a href="#URL-3" class="headerlink" title="URL"></a>URL</h2><p><a href="https://api.water.mengyunzhi.com/useInfo" target="_blank" rel="noopener">https://api.water.mengyunzhi.com/useInfo</a></p>
<h2 id="支持格式-3"><a href="#支持格式-3" class="headerlink" title="支持格式"></a>支持格式</h2><p>JSON</p>
<h2 id="HTTP请求方式-3"><a href="#HTTP请求方式-3" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h2><p>POST</p>
<h2 id="请求参数-2"><a href="#请求参数-2" class="headerlink" title="请求参数"></a>请求参数</h2><ul>
<li>usedBeforeWaterQuality。类型：int。说明：净水前水质。</li>
<li>usedAfterWaterQuality。类型：int。说明：净水后水质。</li>
<li>usedWaterQuantity。类型：int。说明：用水量。</li>
</ul>
<h2 id="请求头信息-2"><a href="#请求头信息-2" class="headerlink" title="请求头信息"></a>请求头信息</h2><ul>
<li>id。类型：Long。说明：净水器编号。</li>
<li>timestamp。类型：String。说明：时间戳。</li>
<li>randomString。类型：String。说明：随机生成的字符串。</li>
<li>encryptionInfo。类型：String。将timestamp、randomString、”mengyunzhi”进行字符串拼接（格式：timestamp + randomString + “mengyunzhi”），并对拼接结果进行sha1加密，生成encryptionInfo。</li>
</ul>
<h2 id="请求示例-3"><a href="#请求示例-3" class="headerlink" title="请求示例"></a>请求示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /api/useInfo HTTP/1.1</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Host: https://api.water.mengyunzhi.com</span><br><span class="line">Id: 1</span><br><span class="line">Timestamp: 1497457292548</span><br><span class="line">RandomString: unzdtggyopn1fl7sx68b8olxr</span><br><span class="line">EncryptionInfo: 37cde59cfa3384c84d9bf7545be348bc880c79bd</span><br><span class="line">   </span><br><span class="line">&#123;</span><br><span class="line">	&quot;usedBeforeWaterQuality&quot;: 80（净水前水质）,</span><br><span class="line">	&quot;usedAfterWaterQuality&quot;: 90（净水后水质）,</span><br><span class="line">	&quot;usedWaterQuantity&quot;: 200（用水量）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应结果示例-3"><a href="#响应结果示例-3" class="headerlink" title="响应结果示例"></a>响应结果示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><p><img src="/images/1.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> chuhang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> API </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[监听指令的外部数据源变化]]></title>
      <url>/2017/06/27/watch-element-in-directives/</url>
      <content type="html"><![CDATA[<p>先给一个效果图。其中区域是一个指令，而用户是另一个指令。我们希望当区域为区县级别时，显示用户选择列表。非区域级别时，隐藏用户选择框。<br><img src="/2017/06/27/watch-element-in-directives/1.gif" title="效果"></p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>我们希望在用户指令中，监听区域指令发生的变量。大体思想是这样的。</p>
<ul>
<li>我们将区域做为用户指令的一个属性进行绑定。</li>
<li>在指令选择区域后，当前选择<strong>区域</strong>由指令回传给V层。</li>
<li>用户指令监听到这个变化，并做出响应</li>
</ul>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>控制器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'webappApp'</span>)</span><br><span class="line">    .controller(<span class="string">'MandatoryPassrateIndexCtrl'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        $scope.currentDistrict = &#123;&#125;;       <span class="comment">// 当前区域</span></span><br><span class="line">        $scope.user = &#123;&#125;;           <span class="comment">// 当前用户</span></span><br><span class="line">        $scope.appliance = &#123;&#125;;      <span class="comment">//当前器具</span></span><br><span class="line">     </span><br><span class="line">    &#125;]);</span><br></pre></td></tr></table></figure></p>
<p>V层<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-md-4 control-label"</span>&gt;</span>区域:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-8"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">yunzhi-district</span> <span class="attr">ng-model</span>=<span class="string">"currentDistrict"</span>&gt;</span><span class="tag">&lt;/<span class="name">yunzhi-district</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"col-md-4 control-label"</span>&gt;</span>用户:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-8"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">yunzhi-measurement-user</span> <span class="attr">ng-model</span>=<span class="string">"user"</span> <span class="attr">data-district</span>=<span class="string">"currentDistrict"</span>&gt;</span><span class="tag">&lt;/<span class="name">yunzhi-measurement-user</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>用户指令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'webappApp'</span>)</span><br><span class="line">    .directive(<span class="string">'yunzhiMeasurementUser'</span>, [<span class="string">'measurementUser'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">measurementUser</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            templateUrl: <span class="string">'views/directive/yunzhiMeasurementUser.html'</span>,</span><br><span class="line">            controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log($scope);</span><br><span class="line">            &#125;,</span><br><span class="line">            link: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope, element, attrs</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(attrs);</span><br><span class="line">                <span class="comment">// 监听传入的data-district是否发生了变化，如果发生了变化，则重新获取器具用户列表</span></span><br><span class="line">                scope.$watch(attrs.district, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//something</span></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台信息：<br><img src="/2017/06/27/watch-element-in-directives/1.png" title="效果"></p>
<p>观察控制台，我们发现：我们想监控是<code>ChildScope</code>中的<code>currentDistrict</code>，该项信息存在于<code>Attributes</code>的<code>disctrict</code>。所以，我们使用<code>scope.$watch(attrs.district,</code> 进行监听。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>我们引用局部<code>scope</code>变量，并进行双向数据绑定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">angular.module(<span class="string">'webappApp'</span>)</span><br><span class="line">    .directive(<span class="string">'yunzhiMeasurementUser'</span>, [<span class="string">'measurementUser'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">measurementUser</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            templateUrl: <span class="string">'views/directive/yunzhiMeasurementUser.html'</span>,</span><br><span class="line">            scope: &#123;</span><br><span class="line">                ngModel: <span class="string">'='</span>,            <span class="comment">// 双向绑定ngModel</span></span><br><span class="line">                district: <span class="string">'='</span>            <span class="comment">// 双向绑定data-district</span></span><br><span class="line">            &#125;,</span><br><span class="line">            controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log($scope);</span><br><span class="line">            &#125;,</span><br><span class="line">            link: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope, element, attrs</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(attrs);</span><br><span class="line">                <span class="comment">// 监听传入的data-district是否发生了变化，如果发生了变化，则重新获取器具用户列表</span></span><br><span class="line">                scope.$watch(<span class="string">'district'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//something</span></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台：<br><img src="/2017/06/27/watch-element-in-directives/2.png" title="效果"></p>
<p>此时，<code>scope</code>中的字段信息，为重命名后的字段，所以直接使用字符串<code>district</code>, 进行监听。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>无论哪种方式，最终我们要监听的数据位于<code>$scope</code>上。要监听前，我们需要对<code>$scope</code>进行打印，进而找到要监听的对象名称。最终将该名称以字符串的方式传入到<code>scope.$watch()</code>中以完成监听过程。</p>
<blockquote>
<p>调试，无论在哪种语言中，都具有最高的地位！</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AngularJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 使用@JsonView自定义输出字段]]></title>
      <url>/2017/06/27/spring-mvc-use-json-view-specifying-filed/</url>
      <content type="html"><![CDATA[<p>在前后台的分离开发中，我们常常直接输出实体的全部属性。这在大多数情况下都是没有问题的，但有些时候，直接输出全部属性的方法，可能会千万系统死循环的异常，进行影响到数据的输出。本文将阐述使用<code>@JsonView</code>注解来避免该问题。</p>
<a id="more"></a>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>比如，我们现在有个树状实体 区域，每个区域都有个父级区域，每个区域又有个子区域集合.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"District (区域)"</span>, description = <span class="string">"区域"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">District</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 实现了Serializable接口，用于序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"上级区域"</span>)</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="keyword">private</span> District parentDistrict;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"下级区域列表"</span>)</span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"parentDistrict"</span>)</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;District&gt; sonDistricts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>此时, 当我们查找到某个区域，并将其进行<code>json</code>序列化时，将得到一个如下的错误：<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to write HTTP message: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON document: Infinite recursion (StackOverflowError) (through reference chain: com.mengyunzhi.measurement.repository.District["sonDistricts"]-&gt;org.hibernate.collection.internal.PersistentBag[0]-&gt;com.mengyunzhi.measurement.repository.District["parentDistrict"]-&gt;...</span><br></pre></td></tr></table></figure></p>
<h1 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h1><p>这是由于在进行Json转化时，Spring MVC会自动获取实体上所有属性的值。也就是说<code>@Lazy</code>不起作用了。<br>这直接导致了：</p>
<ol>
<li>获取某个区域</li>
<li>获取某个区域的父区域</li>
<li>获取父区域的所有子区域</li>
<li>区域子区域的父区域<br>…</li>
</ol>
<p>死循环就这么产生了。</p>
<h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="使用-JsonIgnore"><a href="#使用-JsonIgnore" class="headerlink" title="使用@JsonIgnore"></a>使用@JsonIgnore</h2><p>千万死循环的原因是由于互相调用，所以，我们可以使用<code>@JsonIgnore</code>来忽略到任意一方，便可以达到解决问题的目的。但这个方法并不完美。一旦设置了该注解，在前台后分离的架构中，将永远不能够输出该字段的值。这并不是我们想看到的。</p>
<h2 id="使用-JsonView"><a href="#使用-JsonView" class="headerlink" title="使用@JsonView"></a>使用@JsonView</h2><p>使用<code>@JsonView</code>可以对字段输出进行自由的组合<br>参考官方文档：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-jsonview" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-jsonview</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"District (区域)"</span>, description = <span class="string">"区域"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">District</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithAll</span> </span>&#123;&#125;;    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithOutParentDistrict</span>  <span class="keyword">extends</span> <span class="title">WithAll</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithOutSonDistricts</span> <span class="keyword">extends</span> <span class="title">WithAll</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 实现了Serializable接口，用于序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="meta">@JsonView</span>(WithAll.class)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"区域名称"</span>)</span><br><span class="line">    <span class="meta">@JsonView</span>(WithAll.class)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"上级区域"</span>)</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JsonView</span>(WithOutSonDistricts.class)</span><br><span class="line">    <span class="keyword">private</span> District parentDistrict;</span><br><span class="line">    <span class="meta">@JsonView</span>(WithOutParentDistrict.class)</span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"parentDistrict"</span>)</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;District&gt; sonDistricts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在C层中，将入<code>@JsonView</code>以指定该C层，对应输出实体的哪些字段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"get (获取一条数据)"</span>, notes = <span class="string">"获取一条数据"</span>, nickname = <span class="string">"District_get"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/get/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@JsonView</span>(District.WithOutSonDistricts.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> District <span class="title">get</span><span class="params">(@ApiParam(value = <span class="string">"区域实体id"</span>)</span> @PathVariable Long id) </span>&#123;</span><br><span class="line">    <span class="comment">//获取一条数据</span></span><br><span class="line">    District district = districtService.get(id);</span><br><span class="line">    <span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，在进行json转化时，将不进行子区域的获取。<br>但新的问题又产生了，那就是我们以后在进行<code>json</code>输出时，要必须指定<code>JsonView</code>，否则就需要进行所有的转换。这会使得当我们获取一些关联数据时，发生错误。比如我们获取一个部门的时候，将自动获取这个部门对应的区域，那么此时，进行json转换时，还将循环的错误。</p>
<h2 id="使用-JsonView并去除-OneToMany"><a href="#使用-JsonView并去除-OneToMany" class="headerlink" title="使用@JsonView并去除@OneToMany"></a>使用@JsonView并去除@OneToMany</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"District (区域)"</span>, description = <span class="string">"区域"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">District</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithAll</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithOutParentDistrict</span>  <span class="keyword">extends</span> <span class="title">WithAll</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 实现了Serializable接口，用于序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.AUTO)</span><br><span class="line">    <span class="meta">@JsonView</span>(WithAll.class)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"上级区域"</span>)</span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="keyword">private</span> District parentDistrict;</span><br><span class="line">    <span class="meta">@JsonView</span>(WithOutParentDistrict.class)</span><br><span class="line">    <span class="meta">@Transient</span> <span class="comment">// 该字段并不存在于数据表中</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;District&gt; sonDistricts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>此时，我们便实现了：</p>
<ol>
<li>在不加<code>@JsonView</code>注解的情况下，由于<code>@Transient</code>的存在，使得<code>sonDistricts</code>保持为空集合。</li>
<li>在加入<code>@JsonView(District.WithOutParentDistrict.class)</code>的情况下，将输出<code>sonDistricts</code>同时，忽略输出<code>parentDistrict</code>.</li>
<li>使用的接口继承，便于代码在后期的扩展。</li>
</ol>
<p>为了上述实体的工作，我们还需要手动的去获取子区域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DistrictRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">District</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">District <span class="title">getByName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function">List&lt;District&gt; <span class="title">getAllByParentDistrictId</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> District <span class="title">getTreeByDistrict</span><span class="params">(District district)</span> </span>&#123;</span><br><span class="line">    List&lt;District&gt; districts = districtRepository.getAllByParentDistrictId(district.getId());</span><br><span class="line">    <span class="keyword">for</span>(District district1 : districts) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getTreeByDistrict(district1);</span><br><span class="line">    &#125;</span><br><span class="line">    district.setSonDistricts(districts);</span><br><span class="line">    <span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C层使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"getTreeById"</span>, notes = <span class="string">"获取当前用户所有的部门树"</span>, nickname = <span class="string">"District_getTreeById"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getTreeById/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@JsonView</span>(District.WithOutParentDistrict.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> District <span class="title">getTreeById</span><span class="params">(@ApiParam(value = <span class="string">"区域ID"</span>)</span> @PathVariable Long id) </span>&#123;</span><br><span class="line">    District district = districtService.get(id);</span><br><span class="line">    districtService.getTreeByDistrict(district);</span><br><span class="line">    <span class="keyword">return</span> district;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于jackjson在进行json序列化时，将默认序列化所有的字段。所以，我们需要使用<code>@JsonIgnore</code>或<code>@JsonProperty</code>来排除某些字段。但一味的全部排除有时又不能满足我们的需求。这时候，就需要使用定制性更强的<code>@JsonView</code>。<br>使用<code>@JsonView</code>虽然能够解决特殊的需求，但是如果由于实体间的关联关系。每进行一次输出，都定制一次<code>@JsonView</code>又过于麻烦。最终在实际的问题上，我们删除了<code>OneToMany</code>的关系，手动的维护了<code>OneToMany</code>的关系。这使我们只在进行特定输出时使用<code>@JsonView</code>来解决问题。</p>
<p>除了在实体中，直接建立接口以外，我们也可以单独的新建一个类，然后在这个类中，建立接口，或是抽象类。并将接口或是抽象类应用到实体的字段中。</p>
<p>在特殊的时候，以上的方法可以还解决不了我们的问题。如果是这样，我们就需要单独的建立用于进行<code>json</code>序列化输出的类了。然后在这个类中，去定义<code>get</code>函数，<code>spring mvc</code>，则会自动触发<code>get</code>中的方法，进而进行json的自动转换.</p>
<p>参考文档：<br><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-jsonview" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-jsonview</a></p>
<p>代码示例：</p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring MVC </tag>
            
            <tag> JsonView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[let's learn what is 'cascade = CascadeType.MERGE']]></title>
      <url>/2017/06/24/let-s-learn-what-is-cascade-CascadeType-MERGE/</url>
      <content type="html"><![CDATA[<p>通过用户 – 角色，来演示<code>cascade = CascadeType.MERGE</code>的作用.</p>
<ol>
<li>演示添加该属性时，进行用户编辑时，竟然一同编辑了角色的name.</li>
<li>去除<code>cascade = CascadeType.MERGE</code>后再次编辑。正常显示。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[在angularJs中，如何将list列表数据绑定到一系列的checkbox中。]]></title>
      <url>/2017/06/24/how-to-bind-to-list-of-checkbox-value-and-set-checked-with-angularjs/</url>
      <content type="html"><![CDATA[<p>在项目开发中，我们经常会遇到多到多的数据更新操作。比如，在一个用户可以拥有多个角色的系统中，我们需要更新某个用户的角色的操作。<br><a id="more"></a></p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>在进行数据更新前，我们需要知道，哪些角色是该用户已经拥有的，哪些角色又是该用户还没有拥有的。<br>那些已经拥有的角色，我们需要设置为默认选中；而那些还没有的角色，我们需要给出列表，但不能选中。<br>比如，我们现在编辑的用户，只拥有“器具用户”角色，那么我们期望的初始状态如下：<br><img src="/2017/06/24/how-to-bind-to-list-of-checkbox-value-and-set-checked-with-angularjs/1.png" title="为用户选择角色"></p>
<h1 id="数据前提"><a href="#数据前提" class="headerlink" title="数据前提"></a>数据前提</h1><p>想有上图中的效果，我们必须有两项基本的数据支持：</p>
<ol>
<li>系统共有多个种角色<code>roles</code></li>
<li>当前用户拥有的角色<code>user.roles</code><br>对于上图而言：<br><code>roles</code> = [技术机构,器具用户,系统管理员，管理部门，管理员];<br><code>user.roles</code> = [器具用户];</li>
</ol>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ul>
<li>将<code>user.roles</code>进行转换，做为该用户拥有的角色。</li>
<li>循环输出<code>roles</code>。</li>
<li>在每个循环子项中，判断当前<code>role</code>是否存在于<code>user.roles</code>中。<ul>
<li>存在，说明用户拥有此权限，选中。</li>
<li>不存在，说明用户并不拥有此权限，不选中。</li>
</ul>
</li>
<li>点击checkbox时，重新设置用户拥有的角色。</li>
<li>提交数据时，将用户拥有的角色数组进行逆转换。</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="将user-roles进行转换，做为该用户拥有的角色。"><a href="#将user-roles进行转换，做为该用户拥有的角色。" class="headerlink" title="将user.roles进行转换，做为该用户拥有的角色。"></a>将<code>user.roles</code>进行转换，做为该用户拥有的角色。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.roleIds = [];    <span class="comment">// 角色ID数组</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">// 将角色的ID单独取出，新建数组</span></span><br><span class="line">angular.forEach(self.data.roles, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    self.roleIds.push(value.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="循环输出roles"><a href="#循环输出roles" class="headerlink" title="循环输出roles"></a>循环输出<code>roles</code></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-repeat</span>=<span class="string">"role in roles"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span>&amp;nbsp;&amp;nbsp;&#123;&#123;role.name&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="在每个循环子项中，判断当前role是否存在于user-roles中。"><a href="#在每个循环子项中，判断当前role是否存在于user-roles中。" class="headerlink" title="在每个循环子项中，判断当前role是否存在于user.roles中。"></a>在每个循环子项中，判断当前<code>role</code>是否存在于<code>user.roles</code>中。</h2><ul>
<li>存在，说明用户拥有此权限，选中。</li>
<li>不存在，说明用户并不拥有此权限，不选中。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-repeat</span>=<span class="string">"role in roles"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">ng-checked</span>=<span class="string">"checked(role)"</span>&gt;</span>&amp;nbsp;&amp;nbsp;&#123;&#123;role.name&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测是否选中角色</span></span><br><span class="line">self.checked = <span class="function"><span class="keyword">function</span>(<span class="params">role</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// self.roleIds</span></span><br><span class="line">    <span class="keyword">if</span> (self.roleIds.indexOf(role.id) === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="点击checkbox时，重新设置用户拥有的角色。"><a href="#点击checkbox时，重新设置用户拥有的角色。" class="headerlink" title="点击checkbox时，重新设置用户拥有的角色。"></a>点击checkbox时，重新设置用户拥有的角色。</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-repeat</span>=<span class="string">"role in roles"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">ng-checked</span>=<span class="string">"checked(role)"</span> <span class="attr">ng-click</span>=<span class="string">"toggleSelection(role)"</span> &gt;</span>&amp;nbsp;&amp;nbsp;&#123;&#123;role.name&#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户切换角色时，实时的用户选中的角色信息进行更新</span></span><br><span class="line">self.toggleSelection = <span class="function"><span class="keyword">function</span>(<span class="params">role</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> idx = self.roleIds.indexOf(role.id);</span><br><span class="line">    <span class="keyword">if</span> (idx === <span class="number">-1</span>) &#123;</span><br><span class="line">        self.roleIds.push(role.id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          self.roleIds.splice(idx, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="提交数据时，将用户拥有的角色数组进行逆转换。"><a href="#提交数据时，将用户拥有的角色数组进行逆转换。" class="headerlink" title="提交数据时，将用户拥有的角色数组进行逆转换。"></a>提交数据时，将用户拥有的角色数组进行逆转换。</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.submit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> roles = [];</span><br><span class="line">            <span class="comment">// 进行逆转换</span></span><br><span class="line">            angular.forEach(self.roleIds, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                roles.push(&#123;<span class="attr">id</span>:value&#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            $scope.data.roles = roles;</span><br><span class="line">            UserServer.update($scope.data.id, $scope.data, <span class="function"><span class="keyword">function</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">204</span> === status) &#123;</span><br><span class="line">                    $location.path(<span class="string">'/system/Userfile'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"todo:提示错误信息"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ul>
<li>想实现基本的功能，需要有两个数据支持。<ul>
<li>所有的角色</li>
<li>用户拥有的角色</li>
</ul>
</li>
<li>要显示所有的角色列表，所以要对角色进行循环输出</li>
<li>每输出一个角色，都需要用方法来决定是否进行选中</li>
<li>用户每选中一个角色，都需要更新数据</li>
<li>在进行数据提交前，要转换为后台可以接收的数据规范</li>
</ul>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AngularJS </tag>
            
            <tag> checkbox </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何安装maven]]></title>
      <url>/2017/06/24/how-to-install-maven/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在做单元测试以及对项目文件进行打包的时候，我们需要用到mvntest、mvnpackage等命令，这样做的前提是我们的电脑中必须安装好了maven，那么maven应该如何安装呢？<br><a id="more"></a></p>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="下载maven"><a href="#下载maven" class="headerlink" title="下载maven"></a>下载maven</h2><p>首先我们应该去maven的下载官网：<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a>，找到如下图所示的文件进行下载。</p>
<p><img src="/images/downloadmaven.png" alt=""></p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>下载完毕后进行解压，将maven放到我们想放到的磁盘下面，打开文件发现里面有一个bin文件。例如笔者的bin文件放在了G:\maven\apache-maven-3.5.0下面，如下图所示：</p>
<p><img src="/images/locationMaven.png" alt=""></p>
<h2 id="配置系统变量"><a href="#配置系统变量" class="headerlink" title="配置系统变量"></a>配置系统变量</h2><p>接下来我们需要配置环境变量：控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;系统变量：</p>
<p><img src="/images/environmentalParam.png" alt=""></p>
<p>在系统变量下点击新建，输入系统变量的值(由maven安装位置决定)</p>
<p><img src="/images/systemEnvironment.png" alt=""></p>
<p>修改path值</p>
<p><img src="/images/path.png" alt=""></p>
<h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><p>打开cmd，输入mvn –version</p>
<p><img src="/images/maven.png" alt=""></p>
<p>如果出现这样的界面，恭喜你，maven已经成功安装到计算机中啦！</p>
]]></content>
      
        <categories>
            
            <category> zhangjiahao </category>
            
        </categories>
        
        
        <tags>
            
            <tag> maven </tag>
            
            <tag> install </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[建立指令的步骤]]></title>
      <url>/2017/06/24/how-to-establish-directive/</url>
      <content type="html"><![CDATA[<p>以本项目为例，写一下建立指令的步骤。</p>
<h1 id="新建指令"><a href="#新建指令" class="headerlink" title="新建指令"></a>新建指令</h1><p>在项目的<code>Webapp</code>目录下打开<code>git shell</code>，用<code>yoeman</code>建立新的指令以及指令对应的<code>test</code>文件。以新建岗位指令（post）为例。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo angular:directive yunzhipost</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="完成指令的内容以及样式"><a href="#完成指令的内容以及样式" class="headerlink" title="完成指令的内容以及样式"></a>完成指令的内容以及样式</h1><h2 id="完成yunzhipost-js"><a href="#完成yunzhipost-js" class="headerlink" title="完成yunzhipost.js"></a>完成yunzhipost.js</h2><ul>
<li><p>首先，在<code>yunzhipost.js</code>中先加入独立<code>scope</code>，将指令中的<code>post</code>属性双向绑定到<code>scope.post</code>上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scope: &#123;</span><br><span class="line">          <span class="comment">// 将指令中的post属性，双向绑定到scope.post</span></span><br><span class="line">          ngModel: <span class="string">'='</span></span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后指出指令的类型，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restrict: <span class="string">'EA'</span>,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>其中，<br>A（默认）为属性，在html文件中以<code>&lt;div hello&gt;&lt;/div&gt;</code>形式使用；<br>E为元素，在html文件中以<code>&lt;hello&gt;&lt;/hello&gt;</code>形式使用；<br>M为注释，在html文件中以<code>&lt;!-- directive:hello --&gt;</code>形式使用；<br>C为<code>css</code>样式类，在html文件中以<code>&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt;</code>形式使用。</p>
</blockquote>
<ul>
<li><p>然后指明该指令样式所在的模板文件地址，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">templateUrl: <span class="string">'views/directive/yunzhiPost.html'</span>,</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>controller</code>里面，写出该指令实现的方法，包括：初始化、获取后台数据等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">controller: <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">    $scope.posts = []; <span class="comment">// 初始化所有岗位</span></span><br><span class="line">    $scope.post = &#123;&#125;; <span class="comment">// 初始化岗位</span></span><br><span class="line">    $scope.post.selected = $scope.ngModel; <span class="comment">// 传值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户可见的岗位列表</span></span><br><span class="line">    postService.getCurrentUserPostArray(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        $scope.posts = data;</span><br><span class="line">        <span class="comment">// 如果大小不为0，而且用户并没有传入ngModel实体，则将第一个岗位给当前岗位</span></span><br><span class="line">        <span class="keyword">if</span> (data.length &gt; <span class="number">0</span> &amp;&amp; angular.equals($scope.ngModel, &#123;&#125;)) &#123;</span><br><span class="line">            $scope.post.selected = data[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*在<code>link</code>里面，监视内容是否变化，如果发生变化则利用数据的双向绑定，将值传回V层。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">link: <span class="function"><span class="keyword">function</span> <span class="title">postLink</span>(<span class="params">scope</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 监视岗位是否发生变化。如果发生变化，则重置ngModel的值。此时，利用双向数据绑定。将值传回V层</span></span><br><span class="line">    scope.$watch(<span class="string">'post'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        scope.ngModel = newValue.selected;</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h2 id="完成yunzhipost-js对应的V层样式"><a href="#完成yunzhipost-js对应的V层样式" class="headerlink" title="完成yunzhipost.js对应的V层样式"></a>完成yunzhipost.js对应的V层样式</h2><p>根据2.1中提到的模板文件地址，在V层的<code>directive</code>文件夹下，新建<code>yunzhiPost.html</code>文件，用于编写该指令对应的V层样式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--岗位--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ui-select</span> <span class="attr">ng-model</span>=<span class="string">"post.selected"</span> <span class="attr">theme</span>=<span class="string">"bootstrap"</span> <span class="attr">ng-disabled</span>=<span class="string">"disabled"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ui-select-match</span> <span class="attr">placeholder</span>=<span class="string">"请选择"</span>&gt;</span>&#123;&#123;$select.selected.name&#125;&#125;<span class="tag">&lt;/<span class="name">ui-select-match</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ui-select-choices</span> <span class="attr">repeat</span>=<span class="string">"post in posts | propsFilter: &#123;name: $select.search, pingyin: $select.search&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-bind-html</span>=<span class="string">"post.name | highlight: $select.search"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ui-select-choices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui-select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="完成指令的数据读取"><a href="#完成指令的数据读取" class="headerlink" title="完成指令的数据读取"></a>完成指令的数据读取</h1><p>在完成以上步骤后，只需要再对后台数据进行读取，这个指令就写完了！<br>同样的，我们首先用<code>yoeman</code>新建<code>service</code>文件，在<code>service</code>文件中实现对后台数据的获取。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo angular:service PostService</span><br></pre></td></tr></table></figure></p>
<p>执行完这条命令以后会自动生成相应的<code>js</code>文件。<br>以<code>PostService</code>文件为例，我们在<code>service</code>里面定义一个方法，用来获取在<code>data</code>文件夹中写入的模拟<code>json</code>数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getCurrentUserPostArray;</span><br><span class="line">getCurrentUserPostArray = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    $http.get(<span class="string">'data/post/getCurrentUserPostArray.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">        callback(response.data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    getCurrentUserPostArray: getCurrentUserPostArray</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>与后台数据对接的时候只需要把<code>json</code>数据删掉，将数据获取方式改为后台数据获取即可。</p>
</blockquote>
<h1 id="将指令写在V层"><a href="#将指令写在V层" class="headerlink" title="将指令写在V层"></a>将指令写在V层</h1><p>接下来，我们只要在V层需要的位置写入该指令就可以直接使用了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">yunzhi-post</span> <span class="attr">ng-model</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">yunzhi-post</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>感谢您花费时间阅读这份总结，有不对之处欢迎指正。</p>
]]></content>
      
        <categories>
            
            <category> chenyuanyuan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> yeoman </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C层自动化文档生成过程]]></title>
      <url>/2017/06/23/how-to-generate-auotomation-documents/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在前后台完全分离的项目中，前后台完成对接主要依据是开发文档，为了保证开发效率，我们引入了自动生成文档的注解，那么它是怎么工作的呢？另外在C层的测试类下，我们需要在文档中生成包含响应信息以及请求信息的文档，那么它们又是如何生成的呢？下面我们以部门类型（DepartmentType）的C层为例，说一下自动化文档生成的过程。<br><a id="more"></a></p>
<h1 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"DepartmentType (部门类型)"</span>, description = <span class="string">"部门 部门类型C层"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/DepartmentType"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentTypeController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> DepartmentTypeService departmentTypeService;  <span class="comment">// 部门类型</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"获取所有数据"</span>, notes = <span class="string">"获取所有数据（未排序 ）@author:panjie"</span>, nickname = <span class="string">"DepartmentType_getAll"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DepartmentType&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> departmentTypeService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在java代码中，如果我们想添加注解，那么首先我们应该引用@Api目录下的各种注解，其中对应于不同的注解有着不同的功能。<br>例如上例中，@Api(tags = “DepartmentType (部门类型)”, description = “部门 部门类型C层”) 这一行代码，我们将代码成功提交之后，会发现已经体现在了文档中。你也许会疑惑为什么没有看到nickname的作用呢？在后面我会说一下nickname的作用。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>首先我么会发现在1.5的目录中tags标签里面新增了刚才添加的内容了。如下图所示：</p>
<p><img src="/images/tags.png" alt=""></p>
<p>另外在第三章中关于各个模块的描述中，我们也同样可以看到新增内容，其中与代码对应情况如下：</p>
<p><img src="/images/all.png" alt=""></p>
<h1 id="生成请求信息和响应信息"><a href="#生成请求信息和响应信息" class="headerlink" title="生成请求信息和响应信息"></a>生成请求信息和响应信息</h1><p>我们会发现，除了上面提到的几个API标签对应的内容以外，还有Response等响应信息，那么这些又是怎么生成的呢？这就涉及到我们的ControllerTest类了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logger.info(<span class="string">"---- getAll方法测试 ----"</span>);</span><br><span class="line">    logger.info(<span class="string">"---- 创建一个部门类型实体 ----"</span>);</span><br><span class="line">    DepartmentType departmentType = <span class="keyword">new</span> DepartmentType();</span><br><span class="line">    System.out.println(departmentType);</span><br><span class="line">    logger.info(<span class="string">"保存该实体"</span>);</span><br><span class="line">    departmentTypeRepository.save(departmentType);</span><br><span class="line">    logger.info(<span class="string">"获取响应信息"</span>);</span><br><span class="line">    MvcResult mvcResult = <span class="keyword">this</span>.mockMvc.perform(get(<span class="string">"/DepartmentType/"</span>)</span><br><span class="line">            .contentType(<span class="string">"application/json"</span>)</span><br><span class="line">            .header(<span class="string">"x-auth-token"</span>, xAuthToken))</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andDo(document(<span class="string">"DepartmentType_getAll"</span>, preprocessResponse(prettyPrint())))</span><br><span class="line">            .andReturn();</span><br><span class="line"></span><br><span class="line">    List&lt;DepartmentType&gt; departmentTypeList = (List&lt;DepartmentType&gt;) departmentTypeRepository.findAll();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"断言获取到的数据条数与直接使用repository的实体数相同"</span>);</span><br><span class="line">    String content = mvcResult.getResponse().getContentAsString();</span><br><span class="line">    JSONArray JSONArray = net.sf.json.JSONArray.fromObject(content);</span><br><span class="line">    assertThat(JSONArray.size()).isEqualTo(departmentTypeList.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码是C层中getAll方法的单元测试内容，代码this.mockMvc.perform(get(“/DepartmentType/“)中，get方法内对应的参数，即为Controller中对于get方法定义出来的url，这样子才能用mockMvc向应用程序发出请求，才能够继续执行下面的header、andExpect等函数。其中andDo(document(“DepartmentType_getAll”, preprocessResponse(prettyPrint())))的作用是获取相应信息并且打印出来，其中document函数中第一个参数，与C层中的nickname相同，这样我们才能正确的获取到打印信息。</p>
<p>单元测试通过以后，我们提交代码并合并到development分支，我们便可以查看到完整的开发文档信息了。☺</p>
]]></content>
      
        <categories>
            
            <category> zhangjiahao </category>
            
        </categories>
        
        
        <tags>
            
            <tag> automation documents </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计量项目建立路由的流程]]></title>
      <url>/2017/06/23/how-to-establish-route/</url>
      <content type="html"><![CDATA[<p>通过这一段时间建立路由，明白了项目的整体文件之间的关系。下面以本次项目为例说一下在angularjs中建立路由的流程。</p>
<h1 id="确定菜单名称"><a href="#确定菜单名称" class="headerlink" title="确定菜单名称"></a>确定菜单名称</h1><p>将需求分析给出的原型中，每一个菜单名称翻译出来。可以以本次的计量项目需求为例<br><img src="/images\2017\06\23\how-to-establish-route/page1.jpg" alt=""><br>确定好每个菜单名对应的英文名称后，开始进行路由的建立</p>
<a id="more"></a>
<h1 id="采用yoeman建立路由"><a href="#采用yoeman建立路由" class="headerlink" title="采用yoeman建立路由"></a>采用yoeman建立路由</h1><p>打开<code>git shell</code>进入到本项目的<code>Webapp</code>文件下，输入下面命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yo angular:route supervise/organization/index --uri=supervise/organization</span><br></pre></td></tr></table></figure></p>
<p>这句命令的意思是，建立“监督抽查-授权检定机构监督抽查”这个菜单相对应的<code>controller</code>、<code>view</code>以及<code>test</code>中的文件。</p>
<blockquote>
<p>上面建立路由的方式是用<code>yoeman</code>对<code>angular js</code>建立路由的方式，但是由于本项目中套用了模板的<code>js</code>，所以按照上面的语句建立路由以后，需要手动对项目文件中的<code>scripts/app.js</code>、<code>scripts/config.js</code>等文件进行修改。</p>
</blockquote>
<h2 id="修改scripts-app-js文件"><a href="#修改scripts-app-js文件" class="headerlink" title="修改scripts/app.js文件"></a>修改scripts/app.js文件</h2><p>将本文件中因<code>yoeman</code>建立路由而生成的路由删掉。即删掉下述部分<br><img src="/images\2017\06\23\how-to-establish-route/page2.jpg" alt=""></p>
<h2 id="修改scripts-config-js文件"><a href="#修改scripts-config-js文件" class="headerlink" title="修改scripts/config.js文件"></a>修改scripts/config.js文件</h2><p>在本文件中，添加相应的路由<br><img src="/images\2017\06\23\how-to-establish-route/page3.jpg" alt=""></p>
<h2 id="修改控制器文件名"><a href="#修改控制器文件名" class="headerlink" title="修改控制器文件名"></a>修改控制器文件名</h2><p>此时，为了保证文件名和控制器名称保持一致，还需要修改一下控制器的文件名，即将<br><img src="/images\2017\06\23\how-to-establish-route/page4.jpg" alt=""><br>中的<code>index.js</code>改成<code>indexController.js</code>，然后在<code>scripts/index.html</code>中将<br><img src="/images\2017\06\23\how-to-establish-route/page5.jpg" alt=""><br>也对应的改为<code>indexController.js</code>。</p>
<p>这样，我们就完成了整个路由建立的过程。</p>
<hr>
<p>感谢您花费时间阅读这份总结，有不对之处欢迎指正。</p>
]]></content>
      
        <categories>
            
            <category> chenyuanyuan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> yeoman </tag>
            
            <tag> route </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 绑定json数据到多个实体上]]></title>
      <url>/2017/06/22/binding-json-data-to-two-entity/</url>
      <content type="html"><![CDATA[<p>在spring mvc的数据绑定定，我们可以轻松的将json对象绑定到一个实体上。但如何一次性的绑定到多个实体上的呢？<br><a id="more"></a></p>
<h1 id="绑定单个实体"><a href="#绑定单个实体" class="headerlink" title="绑定单个实体"></a>绑定单个实体</h1><p>绑定一个实体的时候，我们往往是这么做的：<br>比如，我们在新增用户时，需要绑定传入的用户信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">   <span class="meta">@ApiOperation</span>(value = <span class="string">"save 保存用户"</span>,nickname = <span class="string">"User_save"</span>,notes = <span class="string">"保存用户"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(@ApiParam(value = <span class="string">"用户"</span>)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">       userService.save(user);</span><br><span class="line">       <span class="keyword">return</span> user;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的，我们可以这样发送数据，进而完成数据绑定：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"username"</span>:<span class="string">"yunzhiclub"</span>, <span class="attr">"password"</span>:<span class="string">"123456"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>我们刚刚描述了绑定单个实体的方法，但如果我们需要一次发送多个实体到后台，又该怎么办呢？<br>比如，我们需要把部门和用户信息同时传给控制器做外理。<br>例如，前台我们将发送这样的数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"user"</span>:&#123;<span class="attr">"username"</span>:<span class="string">"zhangsan"</span>&#125;,</span><br><span class="line">    <span class="attr">"deparment"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"部门1"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>user</code>是一个实体的信息，而<code>department</code>是另一个实体的信息。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="新建内部静态类"><a href="#新建内部静态类" class="headerlink" title="新建内部静态类"></a>新建内部静态类</h2><p>比如我们现在的控制器为<code>UserController</code>,则在<code>UserController</code>中建立如下<strong>静态内部类</strong>：</p>
<blockquote>
<p>注意：必须声明为<strong>静态内部类</strong>，否则将得到一个未能成功绑定的400异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel</span>(value = <span class="string">"部门+用户"</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentUser</span> </span>&#123;</span><br><span class="line">       <span class="meta">@ApiModelProperty</span>(<span class="string">"部门"</span>)</span><br><span class="line">       <span class="keyword">private</span> Department department;</span><br><span class="line">       <span class="meta">@ApiModelProperty</span>(<span class="string">"用户"</span>)</span><br><span class="line">       <span class="keyword">private</span> User user;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DepartmentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> department;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(Department department)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.department = department;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> user;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.user = user;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>有了这个内部静态类，我们就可以将数据成功的绑定到上面两个内部实体上了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"register 注册后户"</span>, notes = <span class="string">"用户注册时，同时注册部门及用户信息"</span>, nickname = <span class="string">"User_register"</span>)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.NO_CONTENT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(@ApiParam(value = <span class="string">"用户注册信息：部门信息+用户信息"</span>)</span> @RequestBody DepartmentUser departmentUser) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，<code>departmentUser</code>就是我们绑定的信息。我们可以使用其中的<code>getUser()</code>和<code>getDepartment()</code>来获取绑定的值。我们还可以在<code>return</code>上打一个断点，启动调试模式来查看绑定的<code>departmentUser</code>的值.<br><img src="/2017/06/22/binding-json-data-to-two-entity/1.png" title="调试信息"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>json数据可以绑定到某<strong>一个</strong>实体类上。</li>
<li>实体类的本质是类</li>
<li>json数据可以绑定到任意类上。</li>
<li>json数据绑定到类的前提是：有相应字段的set方法。</li>
<li>要想绑定多个实体，需要将多个实体组合为一个实体。</li>
<li>发送数据时，将不同的实体数据做为json对象的不同属性发送。</li>
</ol>
<h1 id="代码片断"><a href="#代码片断" class="headerlink" title="代码片断"></a>代码片断</h1><blockquote>
<p><a href="https://github.com/yunzhiclub/MeasurementItemFrontEnd/blob/014fc96f75373e07a7d61d150b1e9beb7fb6b64e/api/src/main/java/com/mengyunzhi/measurement/controller/UserController.java" target="_blank" rel="noopener">问题相关项目代码</a>, <a href="https://github.com/yunzhiclub/MeasurementItemFrontEnd/blob/78a6e661bfd49c97d9d5fa9181bd493aa256e531/api/src/test/java/com/mengyunzhi/measurement/controller/UserControllerTest.java" target="_blank" rel="noopener">单元测试代码</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mengyunzhi.measurement.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mengyunzhi.measurement.Service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.mengyunzhi.measurement.repository.Department;</span><br><span class="line"><span class="keyword">import</span> com.mengyunzhi.measurement.repository.User;</span><br><span class="line"><span class="keyword">import</span> com.mengyunzhi.measurement.repository.WebAppMenu;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.ObjectNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.security.Principal;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by panjie on 17/5/17.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"User 用户"</span>, description = <span class="string">"用户管理"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/User"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Logger log = Logger.getLogger(UserController.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"login 登录"</span>, nickname = <span class="string">"User_login"</span>,</span><br><span class="line">            notes=<span class="string">"用户登录成功后，将会得到一个header 信息。客户端存储该值后，下次发送时做为header中的XXX进行发送"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(Principal user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-----------------登录成功----------------"</span>);</span><br><span class="line">        log.info(<span class="string">"登录用户:"</span> + user.getName());</span><br><span class="line">        <span class="comment">// 此函数触发，则说明登录成功</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"logout 注销"</span>, nickname = <span class="string">"User_logout"</span>,</span><br><span class="line">            notes = <span class="string">"参考资料：http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"-----------------注销----------------"</span>);</span><br><span class="line">        <span class="comment">// 获取当前认证信息</span></span><br><span class="line">        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在认证信息则调用注销操作</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != authentication) &#123;</span><br><span class="line">            <span class="keyword">new</span> SecurityContextLogoutHandler().logout(httpServletRequest, httpServletResponse, authentication);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getAll"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"getAll 获取所有用户"</span>,nickname = <span class="string">"User_getAll"</span>,notes = <span class="string">"获取所有用户"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"save 保存用户"</span>,nickname = <span class="string">"User_save"</span>,notes = <span class="string">"保存用户"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(@ApiParam(value = <span class="string">"用户"</span>)</span> @RequestBody User user)</span>&#123;</span><br><span class="line">        userService.save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/get/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"get 获取一个用户"</span>,nickname = <span class="string">"User_get"</span>,notes = <span class="string">"获取一个用户"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@ApiParam(value = <span class="string">"实体id"</span>)</span> @PathVariable Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"update (修改)"</span>, notes = <span class="string">"修改某条数据"</span>, nickname = <span class="string">"User_update"</span>)</span><br><span class="line">    <span class="meta">@ApiResponse</span>(code = <span class="number">204</span>, message = <span class="string">"更新成功"</span>)</span><br><span class="line">    <span class="meta">@PutMapping</span>(value = <span class="string">"/update/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@ApiParam(value = <span class="string">"实体ID"</span>)</span> @PathVariable Long id, @<span class="title">ApiParam</span><span class="params">(value = <span class="string">"用户实体"</span>)</span> @RequestBody User user, HttpServletResponse response) </span>&#123;</span><br><span class="line">        log.info(<span class="string">"---- 更新实体 -----"</span>);</span><br><span class="line">        log.info(<span class="string">"在数据更新中，可以直接调用M层的save方法."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userService.update(id, user);</span><br><span class="line">            response.setStatus(<span class="number">204</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ObjectNotFoundException e) &#123;</span><br><span class="line">            response.setStatus(<span class="number">404</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/delete/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"delete 保存用户"</span>,nickname = <span class="string">"User_delete"</span>,notes = <span class="string">"删除用户"</span>)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.NO_CONTENT)      <span class="comment">//删除成功返回状态码204</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@ApiParam(value = <span class="string">"用户"</span>)</span> @PathVariable Long id,HttpServletResponse response)</span>&#123;</span><br><span class="line">        log.info(<span class="string">"---- 删除实体 -----"</span>);</span><br><span class="line">        log.info(<span class="string">"在数据删除中，可以直接调用M层的delete方法."</span>);</span><br><span class="line">        userService.delete(id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getCurrentUserWebAppMenus/"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"getCurrentUserWebAppMenus 获取当前用户的菜单权限列表"</span>, nickname = <span class="string">"User_getCurrentUserWebAppMenus"</span>, notes = <span class="string">"查询前台菜单权限"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;WebAppMenu&gt; <span class="title">getCutUserWebAppMenus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getCurrentUserWebAppMenus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/checkUsernameIsExist/&#123;username&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"checkUsernameIsExist 检测用户名是否已经存在"</span>, nickname = <span class="string">"User_checkUsernameIsExist"</span>, notes = <span class="string">"存在：true,不存在:false @author:panjie"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsernameIsExist</span><span class="params">(@ApiParam(value = <span class="string">"用户名（邮箱），必须使用邮箱作为用户名"</span>)</span> @PathVariable String username) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.checkUsernameIsExist(username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/setUserStatusToNormalById/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"setUserStatusToNormalById 设置某个用户的状态为正常"</span>, notes = <span class="string">"author:panjie"</span>, nickname = <span class="string">"User_setUserStatusToNormalById"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserStatusToNormalById</span><span class="params">(@ApiParam(value = <span class="string">"用户id"</span>)</span> @PathVariable Long id) </span>&#123;</span><br><span class="line">        userService.setUserStatusToNormalById(id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/register"</span>)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"register 注册后户"</span>, notes = <span class="string">"用户注册时，同时注册部门及用户信息"</span>, nickname = <span class="string">"User_register"</span>)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.NO_CONTENT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(@ApiParam(value = <span class="string">"用户注册信息：部门信息+用户信息"</span>)</span> @RequestBody DepartmentUser departmentUser) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModel</span>(value = <span class="string">"部门+用户"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentUser</span> </span>&#123;</span><br><span class="line">        <span class="meta">@ApiModelProperty</span>(<span class="string">"部门"</span>)</span><br><span class="line">        <span class="keyword">private</span> Department department;</span><br><span class="line">        <span class="meta">@ApiModelProperty</span>(<span class="string">"用户"</span>)</span><br><span class="line">        <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DepartmentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> department;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDepartment</span><span class="params">(Department department)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.department = department;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.user = user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> spring mvc </tag>
            
            <tag> data binding </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[复写Bower.json文件比较好的方法]]></title>
      <url>/2017/06/20/Best-practice-when-overriding-main-files-of-bower-sub-dependencies/</url>
      <content type="html"><![CDATA[<h2 id="Override-Bower-Packages"><a href="#Override-Bower-Packages" class="headerlink" title="Override Bower Packages"></a>Override Bower Packages</h2><p>当我用 bower install 下载一个github上的 bower package时，下载完成之后，它自己带的bower.json文件里面并没有 “main”: “angular-locale_zh-cn.js”这种使得我们启动 grunt项目 来帮我们直接执行添加依赖的代码。 当然，我们自己可以在自己本地的bower.json文件中添加 这行语句，这样我们在本地可以 在执行grunt server 的时候，可以在我们设置的index.html文件中自动引入 angular-locale_zh-cn.js这个文件。 但是问题来了，我们下载的bower_components 文件是被在我们项目里面 ignore的，因此并不能同步到我们 所在的github项目中，对此我们得找出解决方案。</p>
<p>我们在启动项目的时候会自动 执行项目目录下的bower.json 文件，我们可以在项目的bower.json文件中直接复写 我们下载的本地的 bower.json文件。示例：</p>
<p><img src="/images/Override Bower.json.png" alt=""></p>
<p>这样，我们就可以 在启动项目 的时候 自动引入我们下载好的angular-locale_zh-cn.js文件。</p>
<p>当然，这个同样适用于 我们bower所下载的包里面的 bower.json文件中含有”main”的代码的情况，例如我们上图中给出的bootstrap，我们直接在项目的 bower.json文件中 复写就可以了。</p>
]]></content>
      
        <categories>
            
            <category> liuxi </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Bower </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[how to build SpringMVC application]]></title>
      <url>/2017/06/20/how-to-build-springmvc-application/</url>
      <content type="html"><![CDATA[<p>我们使用SpringMVC进行项目的开发后，如何生成可以运行的应用程序，又是该用什么方法启动应用程序为我们服务呢？本篇中，我们将简单进行讲解。</p>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>还是我们一直说的：我们想到的，大牛们早就做到了！<br>Spring的官方guide中的<a href="https://spring.io/guides/gs/maven/" target="_blank" rel="noopener">Building Java Projects with Maven</a>，非常清晰的为我们讲述了如果使用maven构建Java Projects。</p>
<p>鉴于本文在基本于mvn已经成功安装，并且项目已经成功在idea下进行开发的前提下，我们在此，只给出要点。<br><a id="more"></a></p>
<h1 id="清空数据表"><a href="#清空数据表" class="headerlink" title="清空数据表"></a>清空数据表</h1><p>为了给项目一个干净的初始化环境，也为了加快项目重构时的创建速度，我们首使用navicat删除当前数据库的所有数据表；或是，我们直接删除数据库，然后新建一个同名数据库。</p>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在项目初始化时，重新创建数据表</span><br><span class="line">spring.jpa.hibernate.ddl-auto=$&#123;jpa.ddl-auto:create&#125;</span><br></pre></td></tr></table></figure>
<p>将数据表设置为create方式，即在项目启动时，重新创建数据表，并且初始化系统数据.</p>
<h1 id="build-project"><a href="#build-project" class="headerlink" title="build project"></a>build project</h1><p>使用git bash进行项目文件夹（即存在pom.xml的文件夹）。<br>执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mvn package</span></span><br></pre></td></tr></table></figure></p>
<p>系统将首先进行<code>mvn test</code>，测试无误后，将自动在<code>./target</code>文件夹中，生成了一个<code>jar</code>文件。该<code>jar</code>文件即为java应用。</p>
<blockquote>
<p>如果你想跳过<code>mvn test</code>直接生成<code>.jar</code>文件，可以使用<code>mvn package -DskipTests</code>命令来替换<code>mvn package</code></p>
</blockquote>
<h1 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h1><p>我们进入jar文件所在路径，并使用java命令启动<code>jar</code>文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java -jar xxxxx.xxx.jar</span></span><br></pre></td></tr></table></figure></p>
<p>此时，应用程序就被我们启动了。</p>
<h1 id="布署到服务器"><a href="#布署到服务器" class="headerlink" title="布署到服务器"></a>布署到服务器</h1><p>有了jar文件，布署到服务器就简单了。我们可以使用任何方式来将<code>jar</code>文件复制到服务器中。U盘，文件共享，邮件什么都可以。</p>
<h2 id="准备数据库"><a href="#准备数据库" class="headerlink" title="准备数据库"></a>准备数据库</h2><p>在服务器上启动mysql（可以是xampp这种集成环境，也可以是单独安装的），然后使用navicat创建一个项目使用的数据库（名字要相同）。如果已经有数据库了，可以先删除，然后再创建。</p>
<h2 id="执行jar文件"><a href="#执行jar文件" class="headerlink" title="执行jar文件"></a>执行jar文件</h2><p>我们在服务器上存放jar文件的路径上启动<code>git bash</code>。然后和我们在本机执行过程一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java -jar xxxxx.xxx.jar</span></span><br></pre></td></tr></table></figure></p>
<p>程序就这样被启动了！</p>
<p>那么如何重新布署呢？<br>在执行上述操作前，我们只需要先关掉上次正在执行的<code>jar</code>程序就可以了。</p>
<h1 id="更改运行参数"><a href="#更改运行参数" class="headerlink" title="更改运行参数"></a>更改运行参数</h1><p>有时候，我们服务器的运行环境和本地可能会有些出入。比如服务器的数据库的端口不是3306。而是3633。这时候该怎么办呢？<br>我们通过观察程序的配置文件不能发现，有很多<code>${xxx:yyy}</code>的配置信息，这就是为我们自定义配置准备的。其中<code>xxx</code>是配置项，<code>yyy</code>是默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 在项目初始化时，重新创建数据表</span><br><span class="line">spring.jpa.hibernate.ddl-auto=$&#123;jpa.ddl-auto:create&#125;</span><br><span class="line"># 指定连接的类型为mysql 连接的地址为：localhost 端口为3306 ，数据为springmvc</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:$&#123;datasource.port:3306&#125;/measurement?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line"># 用户名为root</span><br><span class="line">spring.datasource.username=$&#123;datasource.username:root&#125;</span><br><span class="line"># 密码为空</span><br><span class="line">spring.datasource.password=$&#123;datasource.password:&#125;</span><br><span class="line">server.port=$&#123;port:8080&#125;</span><br></pre></td></tr></table></figure>
<p>比如，我们想将数据库的端口号改为3633，则应该使用:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java -jar xxx.xxx.jar --datasource.port=3633</span></span><br></pre></td></tr></table></figure></p>
<p>再比如，我们想将数据库的端口号改为3633的同时，还想将程序的端口修改为8081<br>则使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># java -jar xxx.xxx.jar --datasource.port=3633 --port=8081</span></span><br></pre></td></tr></table></figure></p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol>
<li>使用mvn package将生成一个jar程序。</li>
<li>使用java -jar xxx.jar来运行一个程序。</li>
<li>为了避免数据表不一致带来的问题，提前清空数据表。</li>
<li>程序运行以前，需要确保mysql服务已启动。</li>
<li>程序运行 = mysql服务运行 + jar应用程序运行。</li>
<li>可以在配置文件中加入<code>${}</code>来在程序启动时自定义配置信息。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FreeBSD中，重新启动并在后台运行jar文件]]></title>
      <url>/2017/06/19/rebuild-jar-file-in-freebsd/</url>
      <content type="html"><![CDATA[<p>在<code>freebsd</code>中，如果我们以<code>ssh</code>进行登录，直接启动<code>jar</code>文件的话，会发现，当窗口关闭后，运行的程序也被自动终止了。怎么样才能实现当对话关闭后，程序仍将继续运行呢？</p>
<h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><p>我们使用<code>mvn package</code>对应用程序进行打包后，后得到一个可以执行的<code>.jar</code>文件，可以在命令行中，使用<code>java -jar</code>来运行该<code>jar</code>文件。在进行后台运行时，需要在最后面加入<code>&amp;</code>，比如:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> java -jar api-0.0.3-SNAPSHOT.jar --datasource.port=3633 &amp;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="终止程序"><a href="#终止程序" class="headerlink" title="终止程序"></a>终止程序</h1><p>我们知道当运行程序时，可以按<code>ctrl+c</code>来终止程序。那么，如何终止正在后台运行的程序呢？</p>
<h2 id="找到程序的pid"><a href="#找到程序的pid" class="headerlink" title="找到程序的pid"></a>找到程序的pid</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ps -aux</span></span><br><span class="line">USER     PID  %CPU %MEM     VSZ    RSS TT  STAT STARTED         TIME COMMAND</span><br><span class="line">...</span><br><span class="line">root   90092   0.0  0.1   23572   1200  2- I    Tue10AM      0:00.05 _su (csh)</span><br><span class="line">root   90366   0.0  0.1   23572   2492  3- I    Tue10AM      0:00.02 _su (csh)</span><br><span class="line">root   90367   0.0  1.7  653332  35184  3- I    Tue10AM      0:02.49 node /usr/local/bin/http-server /mengyunzhi/webapp/8005/dist/ -p 8005</span><br><span class="line">root   94194   0.0 15.1 2151736 313104  4- S    Wed05PM      9:21.50 /usr/local/openjdk8/bin/java -jar api-0.0.3-SNAPSHOT.jar --datasource.port=3633</span><br></pre></td></tr></table></figure>
<p>我们发现，前面我们在后面执行过的命令的pid为94194</p>
<h2 id="终止pid"><a href="#终止pid" class="headerlink" title="终止pid"></a>终止pid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># kill -9 94194</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>将程序设置为后台运行，在窗口关闭时，程序仍然将自动运行。</li>
<li>后台运行的程序，需要使用<code>kill -9</code>来终止进程。</li>
<li>在使用<code>kill -9</code>来终止进行前，需要使用<code>ps -aux</code>来查看所想终止程序的进程号。</li>
</ol>
<p><hr><br>如果是nodejs的应用程序呢？比如http-server.</p>
<p>如果是启动<code>nodejs</code>中的程序，比如<code>http-server</code>，则需要使用<code>node</code>中的<code>forever</code>来<br>比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm install -g forever</span></span><br><span class="line"><span class="comment"># forever start `http-server /mengyunzhi/api/8080.Measurement/dist/ -p 8005` &amp;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> teacherPan </category>
            
        </categories>
        
        
        <tags>
            
            <tag> freebsd </tag>
            
            <tag> backgroud </tag>
            
            <tag> forever </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
